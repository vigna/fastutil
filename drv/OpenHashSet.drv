/*
 * Copyright (C) 2002-2024 Sebastiano Vigna
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package PACKAGE;

import it.unimi.dsi.fastutil.Hash;
import it.unimi.dsi.fastutil.HashCommon;
import static it.unimi.dsi.fastutil.HashCommon.arraySize;
import static it.unimi.dsi.fastutil.HashCommon.maxFill;

import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.NoSuchElementException;
#if KEYS_REFERENCE
import java.util.function.Consumer;
#ifndef Custom
import java.util.stream.Collector;
#endif
#endif

#ifdef Linked

#if KEYS_REFERENCE
import java.util.Comparator;
#endif

/**  A type-specific linked hash set with with a fast, small-footprint implementation.
 *
 * <p>Instances of this class use a hash table to represent a set. The table is
 * filled up to a specified <em>load factor</em>, and then doubled in size to
 * accommodate new entries. If the table is emptied below <em>one fourth</em>
 * of the load factor, it is halved in size; however, the table is never reduced to a
 * size smaller than that at creation time: this approach makes it
 * possible to create sets with a large capacity in which insertions and
 * deletions do not cause immediately rehashing. Moreover, halving is
 * not performed when deleting entries from an iterator, as it would interfere
 * with the iteration process.
 *
 * <p>Note that {@link #clear()} does not modify the hash table size.
 * Rather, a family of {@linkplain #trim() trimming
 * methods} lets you control the size of the table; this is particularly useful
 * if you reuse instances of this class.
 *
 * <p>Iterators generated by this set will enumerate elements in the same order in which they
 * have been added to the set (addition of elements already present
 * in the set does not change the iteration order). Note that this order has nothing in common with the natural
 * order of the keys. The order is kept by means of a doubly linked list, represented
 * <i>via</i> an array of longs parallel to the table.
 *
 * <p>This class implements the interface of a sorted set, so to allow easy
 * access of the iteration order: for instance, you can get the first element
 * in iteration order with {@code first()} without having to create an
 * iterator; however, this class partially violates the {@link java.util.SortedSet}
 * contract because all subset methods throw an exception and {@link
 * #comparator()} returns always {@code null}.
 *
 * <p>Additional methods, such as {@code addAndMoveToFirst()}, make it easy
 * to use instances of this class as a cache (e.g., with LRU policy).
 *
 * <p>The iterators provided by this class are type-specific {@linkplain
 * java.util.ListIterator list iterators}, and can be started at any
 * element <em>which is in the set</em> (if the provided element
 * is not in the set, a {@link NoSuchElementException} exception will be thrown).
 * If, however, the provided element is not the first or last element in the
 * set, the first access to the list index will require linear time, as in the worst case
 * the entire set must be scanned in iteration order to retrieve the positional
 * index of the starting element. If you use just the methods of a type-specific {@link it.unimi.dsi.fastutil.BidirectionalIterator},
 * however, all operations will be performed in constant time.
 *
 * @see Hash
 * @see HashCommon
 */

public class OPEN_HASH_SET KEY_GENERIC extends ABSTRACT_SORTED_SET KEY_GENERIC implements java.io.Serializable, Cloneable, Hash {

#else

#ifdef Custom

/** A type-specific hash set with a fast, small-footprint implementation whose {@linkplain it.unimi.dsi.fastutil.Hash.Strategy hashing strategy}
 * is specified at creation time.
 *
 * <p>Instances of this class use a hash table to represent a set. The table is
 * filled up to a specified <em>load factor</em>, and then doubled in size to
 * accommodate new entries. If the table is emptied below <em>one fourth</em>
 * of the load factor, it is halved in size; however, the table is never reduced to a
 * size smaller than that at creation time: this approach makes it
 * possible to create sets with a large capacity in which insertions and
 * deletions do not cause immediately rehashing. Moreover, halving is
 * not performed when deleting entries from an iterator, as it would interfere
 * with the iteration process.
 *
 * <p>Note that {@link #clear()} does not modify the hash table size.
 * Rather, a family of {@linkplain #trim() trimming
 * methods} lets you control the size of the table; this is particularly useful
 * if you reuse instances of this class.
 *
 * @see Hash
 * @see HashCommon
 */

public class OPEN_HASH_SET KEY_GENERIC extends ABSTRACT_SET KEY_GENERIC implements java.io.Serializable, Cloneable, Hash {

#else

/**  A type-specific hash set with with a fast, small-footprint implementation.
 *
 * <p>Instances of this class use a hash table to represent a set. The table is
 * filled up to a specified <em>load factor</em>, and then doubled in size to
 * accommodate new entries. If the table is emptied below <em>one fourth</em>
 * of the load factor, it is halved in size; however, the table is never reduced to a
 * size smaller than that at creation time: this approach makes it
 * possible to create sets with a large capacity in which insertions and
 * deletions do not cause immediately rehashing. Moreover, halving is
 * not performed when deleting entries from an iterator, as it would interfere
 * with the iteration process.
 *
 * <p>Note that {@link #clear()} does not modify the hash table size.
 * Rather, a family of {@linkplain #trim() trimming
 * methods} lets you control the size of the table; this is particularly useful
 * if you reuse instances of this class.
 *
 * @see Hash
 * @see HashCommon
 */

public class OPEN_HASH_SET KEY_GENERIC extends ABSTRACT_SET KEY_GENERIC implements java.io.Serializable, Cloneable, Hash {

#endif

#endif

	private static final long serialVersionUID = 0L;
	private static final boolean ASSERTS = ASSERTS_VALUE;

	/** The array of keys. */
	protected transient KEY_GENERIC_TYPE[] key;

	/** The mask for wrapping a position counter. */
	protected transient int mask;

	/** Whether this set contains the null key. */
	protected transient boolean containsNull;

#ifdef Custom
	/** The hash strategy of this custom set. */
	protected STRATEGY KEY_SUPER_GENERIC strategy;
#endif

#ifdef Linked
	/** The index of the first entry in iteration order. It is valid iff {@link #size} is nonzero; otherwise, it contains -1. */
	protected transient int first = -1;
	/** The index of the last entry in iteration order. It is valid iff {@link #size} is nonzero; otherwise, it contains -1. */
	protected transient int last = -1;
	/** For each entry, the next and the previous entry in iteration order,
	 * stored as {@code ((prev & 0xFFFFFFFFL) << 32) | (next & 0xFFFFFFFFL)}.
	 * The first entry contains predecessor -1, and the last entry
	 * contains successor -1. */
	protected transient long[] link;
#endif

	/** The current table size. Note that an additional element is allocated for storing the null key. */
	protected transient int n;

	/** Threshold after which we rehash. It must be the table size times {@link #f}. */
	protected transient int maxFill;

	/** We never resize below this threshold, which is the construction-time {#n}. */
	protected final transient int minN;

	/** Number of entries in the set (including the null key, if present). */
	protected int size;

	/** The acceptable load factor. */
	protected final float f;

#ifdef Custom
	/** Creates a new hash set.
	 *
	 * <p>The actual table size will be the least power of two greater than {@code expected}/{@code f}.
	 *
	 * @param expected the expected number of elements in the hash set.
	 * @param f the load factor.
	 * @param strategy the strategy.
	 */
	SUPPRESS_WARNINGS_KEY_UNCHECKED
	public OPEN_HASH_SET(final int expected, final float f, final STRATEGY KEY_SUPER_GENERIC strategy) {
		this.strategy = strategy;
#else
	/** Creates a new hash set.
	 *
	 * <p>The actual table size will be the least power of two greater than {@code expected}/{@code f}.
	 *
	 * @param expected the expected number of elements in the hash set.
	 * @param f the load factor.
	 */
	SUPPRESS_WARNINGS_KEY_UNCHECKED
	public OPEN_HASH_SET(final int expected, final float f) {
#endif
		if (f <= 0 || f >= 1) throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than 1");
		if (expected < 0) throw new IllegalArgumentException("The expected number of elements must be nonnegative");

		this.f = f;

		minN = n = arraySize(expected, f);
		mask = n - 1;
		maxFill = maxFill(n, f);
		key = KEY_GENERIC_ARRAY_CAST new KEY_TYPE[n + 1];
#ifdef Linked
		link = new long[n + 1];
#endif
	}


#ifdef Custom
	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
	 *
	 * @param expected the expected number of elements in the hash set.
	 * @param strategy the strategy.
	 */

	public OPEN_HASH_SET(final int expected, final STRATEGY KEY_SUPER_GENERIC strategy) {
		this(expected, DEFAULT_LOAD_FACTOR, strategy);
	}

#else
	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
	 *
	 * @param expected the expected number of elements in the hash set.
	 */

	public OPEN_HASH_SET(final int expected) {
		this(expected, DEFAULT_LOAD_FACTOR);
	}

#endif


#ifdef Custom
	/** Creates a new hash set with initial expected {@link Hash#DEFAULT_INITIAL_SIZE} elements
	 * and {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
	 * @param strategy the strategy.
	 */

	public OPEN_HASH_SET(final STRATEGY KEY_SUPER_GENERIC strategy) {
	this(DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR, strategy);
	}
#else
	/** Creates a new hash set with initial expected {@link Hash#DEFAULT_INITIAL_SIZE} elements
	 * and {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
	 */

	public OPEN_HASH_SET() {
		this(DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR);
	}
#endif


#ifdef Custom
	/** Creates a new hash set copying a given collection.
	 *
	 * @param c a {@link Collection} to be copied into the new hash set.
	 * @param f the load factor.
	 * @param strategy the strategy.
	 */

	public OPEN_HASH_SET(final Collection<? extends KEY_GENERIC_CLASS> c, final float f, final STRATEGY KEY_SUPER_GENERIC strategy) {
	this(c.size(), f, strategy);
		addAll(c);
	}
#else
	/** Creates a new hash set copying a given collection.
	 *
	 * @param c a {@link Collection} to be copied into the new hash set.
	 * @param f the load factor.
	 */

	public OPEN_HASH_SET(final Collection<? extends KEY_GENERIC_CLASS> c, final float f) {
		this(c.size(), f);
		addAll(c);
	}
#endif



#ifdef Custom
	/** Creates a new hash set  with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor
	 * copying a given collection.
	 *
	 * @param c a {@link Collection} to be copied into the new hash set.
	 * @param strategy the strategy.
	 */

	public OPEN_HASH_SET(final Collection<? extends KEY_GENERIC_CLASS> c, final STRATEGY KEY_SUPER_GENERIC strategy) {
		this(c, DEFAULT_LOAD_FACTOR, strategy);
	}

#else
	/** Creates a new hash set  with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor
	 * copying a given collection.
	 *
	 * @param c a {@link Collection} to be copied into the new hash set.
	 */

	public OPEN_HASH_SET(final Collection<? extends KEY_GENERIC_CLASS> c) {
		this(c, DEFAULT_LOAD_FACTOR);
	}
#endif


#ifdef Custom
	/** Creates a new hash set copying a given type-specific collection.
	 *
	 * @param c a type-specific collection to be copied into the new hash set.
	 * @param f the load factor.
	 * @param strategy the strategy.
	 */

	public OPEN_HASH_SET(final COLLECTION KEY_EXTENDS_GENERIC c, final float f, STRATEGY KEY_SUPER_GENERIC strategy) {
	this(c.size(), f, strategy);
		addAll(c);
	}
#else
	/** Creates a new hash set copying a given type-specific collection.
	 *
	 * @param c a type-specific collection to be copied into the new hash set.
	 * @param f the load factor.
	 */

	public OPEN_HASH_SET(final COLLECTION KEY_EXTENDS_GENERIC c, final float f) {
		this(c.size(), f);
		addAll(c);
	}
#endif


#ifdef Custom
	/** Creates a new hash set  with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor
	 * copying a given type-specific collection.
	 *
	 * @param c a type-specific collection to be copied into the new hash set.
	 * @param strategy the strategy.
	 */

	public OPEN_HASH_SET(final COLLECTION KEY_EXTENDS_GENERIC c, final STRATEGY KEY_SUPER_GENERIC strategy) {
		this(c, DEFAULT_LOAD_FACTOR, strategy);
	}
#else
	/** Creates a new hash set  with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor
	 * copying a given type-specific collection.
	 *
	 * @param c a type-specific collection to be copied into the new hash set.
	 */

	public OPEN_HASH_SET(final COLLECTION KEY_EXTENDS_GENERIC c) {
		this(c, DEFAULT_LOAD_FACTOR);
	}
#endif


#ifdef Custom
	/** Creates a new hash set using elements provided by a type-specific iterator.
	 *
	 * @param i a type-specific iterator whose elements will fill the set.
	 * @param f the load factor.
	 * @param strategy the strategy.
	 */

	public OPEN_HASH_SET(final STD_KEY_ITERATOR KEY_EXTENDS_GENERIC i, final float f, final STRATEGY KEY_SUPER_GENERIC strategy) {
		this(DEFAULT_INITIAL_SIZE, f, strategy);
		while(i.hasNext()) add(i.NEXT_KEY());
	}
#else
	/** Creates a new hash set using elements provided by a type-specific iterator.
	 *
	 * @param i a type-specific iterator whose elements will fill the set.
	 * @param f the load factor.
	 */

	public OPEN_HASH_SET(final STD_KEY_ITERATOR KEY_EXTENDS_GENERIC i, final float f) {
		this(DEFAULT_INITIAL_SIZE, f);
		while(i.hasNext()) add(i.NEXT_KEY());
	}
#endif

#ifdef Custom
	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor using elements provided by a type-specific iterator.
	 *
	 * @param i a type-specific iterator whose elements will fill the set.
	 * @param strategy the strategy.
	 */

	public OPEN_HASH_SET(final STD_KEY_ITERATOR KEY_EXTENDS_GENERIC i, final STRATEGY KEY_SUPER_GENERIC strategy) {
		this(i, DEFAULT_LOAD_FACTOR, strategy);
	}
#else
	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor using elements provided by a type-specific iterator.
	 *
	 * @param i a type-specific iterator whose elements will fill the set.
	 */

	public OPEN_HASH_SET(final STD_KEY_ITERATOR KEY_EXTENDS_GENERIC i) {
		this(i, DEFAULT_LOAD_FACTOR);
	}
#endif



#if KEYS_PRIMITIVE

#ifdef Custom
	/** Creates a new hash set using elements provided by an iterator.
	 *
	 * @param i an iterator whose elements will fill the set.
	 * @param f the load factor.
	 * @param strategy the strategy.
	 */

	public OPEN_HASH_SET(final Iterator<?> i, final float f, final STRATEGY KEY_SUPER_GENERIC strategy) {
		this(ITERATORS.AS_KEY_ITERATOR(i), f, strategy);
	}
#else
	/** Creates a new hash set using elements provided by an iterator.
	 *
	 * @param i an iterator whose elements will fill the set.
	 * @param f the load factor.
	 */

	public OPEN_HASH_SET(final Iterator<?> i, final float f) {
		this(ITERATORS.AS_KEY_ITERATOR(i), f);
	}

#endif


#ifdef Custom
	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor using elements provided by an iterator.
	 *
	 * @param i an iterator whose elements will fill the set.
	 * @param strategy the strategy.
	 */

	public OPEN_HASH_SET(final Iterator<?> i, final STRATEGY KEY_SUPER_GENERIC strategy) {
		this(ITERATORS.AS_KEY_ITERATOR(i), strategy);
	}
#else
	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor using elements provided by an iterator.
	 *
	 * @param i an iterator whose elements will fill the set.
	 */

	public OPEN_HASH_SET(final Iterator<?> i) {
		this(ITERATORS.AS_KEY_ITERATOR(i));
	}
#endif

#endif



#ifdef Custom
	/** Creates a new hash set and fills it with the elements of a given array.
	 *
	 * @param a an array whose elements will be used to fill the set.
	 * @param offset the first element to use.
	 * @param length the number of elements to use.
	 * @param f the load factor.
	 * @param strategy the strategy.
	 */

	public OPEN_HASH_SET(final KEY_GENERIC_TYPE[] a, final int offset, final int length, final float f, final STRATEGY KEY_SUPER_GENERIC strategy) {
	this(length < 0 ? 0 : length, f, strategy);
		ARRAYS.ensureOffsetLength(a, offset, length);
		for(int i = 0; i < length; i++) add(a[offset + i]);
	}
#else
	/** Creates a new hash set and fills it with the elements of a given array.
	 *
	 * @param a an array whose elements will be used to fill the set.
	 * @param offset the first element to use.
	 * @param length the number of elements to use.
	 * @param f the load factor.
	 */

	public OPEN_HASH_SET(final KEY_GENERIC_TYPE[] a, final int offset, final int length, final float f) {
		this(length < 0 ? 0 : length, f);
		ARRAYS.ensureOffsetLength(a, offset, length);
		for(int i = 0; i < length; i++) add(a[offset + i]);
	}
#endif

#ifdef Custom
	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor and fills it with the elements of a given array.
	 *
	 * @param a an array whose elements will be used to fill the set.
	 * @param offset the first element to use.
	 * @param length the number of elements to use.
	 * @param strategy the strategy.
	 */

	public OPEN_HASH_SET(final KEY_GENERIC_TYPE[] a, final int offset, final int length, final STRATEGY KEY_SUPER_GENERIC strategy) {
		this(a, offset, length, DEFAULT_LOAD_FACTOR, strategy);
	}
#else
	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor and fills it with the elements of a given array.
	 *
	 * @param a an array whose elements will be used to fill the set.
	 * @param offset the first element to use.
	 * @param length the number of elements to use.
	 */

	public OPEN_HASH_SET(final KEY_GENERIC_TYPE[] a, final int offset, final int length) {
		this(a, offset, length, DEFAULT_LOAD_FACTOR);
	}
#endif

#ifdef Custom
	/** Creates a new hash set copying the elements of an array.
	 *
	 * @param a an array to be copied into the new hash set.
	 * @param f the load factor.
	 * @param strategy the strategy.
	 */

	public OPEN_HASH_SET(final KEY_GENERIC_TYPE[] a, final float f, final STRATEGY KEY_SUPER_GENERIC strategy) {
		this(a, 0, a.length, f, strategy);
	}
#else
	/** Creates a new hash set copying the elements of an array.
	 *
	 * @param a an array to be copied into the new hash set.
	 * @param f the load factor.
	 */

	public OPEN_HASH_SET(final KEY_GENERIC_TYPE[] a, final float f) {
		this(a, 0, a.length, f);
	}
#endif

#ifdef Custom
	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor
	 * copying the elements of an array.
	 *
	 * @param a an array to be copied into the new hash set.
	 * @param strategy the strategy.
	 */

	public OPEN_HASH_SET(final KEY_GENERIC_TYPE[] a, final STRATEGY KEY_SUPER_GENERIC strategy) {
		this(a, DEFAULT_LOAD_FACTOR, strategy);
	}

#else
	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor
	 * copying the elements of an array.
	 *
	 * @param a an array to be copied into the new hash set.
	 */

	public OPEN_HASH_SET(final KEY_GENERIC_TYPE[] a) {
		this(a, DEFAULT_LOAD_FACTOR);
	}

	/** Creates a new empty hash set.
	 *
	 * @return a new empty hash set.
	 */
	public static KEY_GENERIC OPEN_HASH_SET KEY_GENERIC of() {
		return new OPEN_HASH_SET KEY_GENERIC_DIAMOND();
	}

	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor
	 * using the given element.
	 *
	 * @param e the element that the returned set will contain.
	 * @return a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor containing {@code e}.
	 */
	public static KEY_GENERIC OPEN_HASH_SET KEY_GENERIC of(final KEY_GENERIC_TYPE e) {
		OPEN_HASH_SET KEY_GENERIC result = new OPEN_HASH_SET KEY_GENERIC_DIAMOND(1, DEFAULT_LOAD_FACTOR);
		result.add(e);
		return result;
	}

	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor
	 * using the elements given.
	 *
	 * @param e0 the first element.
	 * @param e1 the second element.
	 * @return a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor containing {@code e0} and {@code e1}.
	 * @throws IllegalArgumentException if there were duplicate entries.
	 */
	public static KEY_GENERIC OPEN_HASH_SET KEY_GENERIC of(final KEY_GENERIC_TYPE e0, final KEY_GENERIC_TYPE e1) {
		OPEN_HASH_SET KEY_GENERIC result = new OPEN_HASH_SET KEY_GENERIC_DIAMOND(2, DEFAULT_LOAD_FACTOR);
		result.add(e0);
		if (!result.add(e1)) {
			throw new IllegalArgumentException("Duplicate element: " + e1);
		}
		return result;
	}

	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor
	 * using the elements given.
	 *
	 * @param e0 the first element.
	 * @param e1 the second element.
	 * @param e2 the third element.
	 * @return a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor containing {@code e0}, {@code e1}, and {@code e2}.
	 * @throws IllegalArgumentException if there were duplicate entries.
	 */
	public static KEY_GENERIC OPEN_HASH_SET KEY_GENERIC of(final KEY_GENERIC_TYPE e0, final KEY_GENERIC_TYPE e1, final KEY_GENERIC_TYPE e2) {
		OPEN_HASH_SET KEY_GENERIC result = new OPEN_HASH_SET KEY_GENERIC_DIAMOND(3, DEFAULT_LOAD_FACTOR);
		result.add(e0);
		if (!result.add(e1)) {
			throw new IllegalArgumentException("Duplicate element: " + e1);
		}
		if (!result.add(e2)) {
			throw new IllegalArgumentException("Duplicate element: " + e2);
		}
		return result;
	}

	/** Creates a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor
	 * using a list of elements.
	 *
	 * @param a a list of elements that will be used to initialize the new hash set.
	 * @return a new hash set with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor containing the elements of {@code a}.
	 * @throws IllegalArgumentException if a duplicate entry was encountered.
	 */
	SAFE_VARARGS
	public static KEY_GENERIC OPEN_HASH_SET KEY_GENERIC of(final KEY_GENERIC_TYPE... a) {
		OPEN_HASH_SET KEY_GENERIC result = new OPEN_HASH_SET KEY_GENERIC_DIAMOND(a.length, DEFAULT_LOAD_FACTOR);
		for (KEY_GENERIC_TYPE element : a) {
			if (!result.add(element)) {
				throw new IllegalArgumentException("Duplicate element " + element);
			}
		}
		return result;
	}
#endif

#ifndef Custom
#if KEYS_INT_LONG_DOUBLE
	/** Collects the result of a primitive {@code Stream} into a new hash set.
	 *
	 * <p>This method performs a terminal operation on the given {@code Stream}
	 *
	 * @apiNote Taking a primitive stream instead of returning something like a
	 * {@link java.util.stream.Collector Collector} is necessary because there is no
	 * primitive {@code Collector} equivalent in the Java API.
	 */
	public static KEY_GENERIC OPEN_HASH_SET KEY_GENERIC toSet(JDK_PRIMITIVE_STREAM stream) {
		return stream.collect(
			OPEN_HASH_SET::new,
			OPEN_HASH_SET::add,
			OPEN_HASH_SET::addAll);
	}

	/** Collects the result of a primitive {@code Stream} into a new hash set, potentially pre-allocated to handle the given size.
	 *
	 * <p>This method performs a terminal operation on the given {@code Stream}
	 *
	 * @apiNote Taking a primitive stream instead returning something like a
	 * {@link java.util.stream.Collector Collector} is necessary because there is no
	 * primitive {@code Collector} equivalent in the Java API.
	 */
	public static KEY_GENERIC OPEN_HASH_SET KEY_GENERIC toSetWithExpectedSize(JDK_PRIMITIVE_STREAM stream, int expectedSize) {
		if (expectedSize <= Hash.DEFAULT_INITIAL_SIZE) {
			// Already below default capacity. Just use all default construction instead of fiddling with atomics in SizeDecreasingSupplier
			return toSet(stream);
		}
		return stream.collect(
			new COLLECTIONS.SizeDecreasingSupplier<
#if KEYS_REFERENCE
					K,
#endif
					OPEN_HASH_SET KEY_GENERIC>(
				expectedSize, (int size) ->
					size <= Hash.DEFAULT_INITIAL_SIZE ? new OPEN_HASH_SET KEY_GENERIC() : new OPEN_HASH_SET KEY_GENERIC(size)),
			OPEN_HASH_SET::add,
			OPEN_HASH_SET::addAll);
	}
#elif KEYS_REFERENCE
	// Collector wants a function that returns the collection being added to.
	private OPEN_HASH_SET KEY_GENERIC combine(OPEN_HASH_SET KEY_EXTENDS_GENERIC toAddFrom) {
		addAll(toAddFrom);
		return this;
	}

	private static final Collector<KEY_TYPE, ?, OPEN_HASH_SET<KEY_TYPE>> TO_SET_COLLECTOR =
		Collector.of(
			OPEN_HASH_SET::new,
			OPEN_HASH_SET::add,
			OPEN_HASH_SET::combine
#ifndef Linked
			, Collector.Characteristics.UNORDERED
#endif
		);

	/** Returns a {@link Collector} that collects a {@code Stream}'s elements into a new hash set. */
	SUPPRESS_WARNINGS_KEY_UNCHECKED_RAWTYPES
	public static KEY_GENERIC Collector<KEY_GENERIC_TYPE, ?, OPEN_HASH_SET KEY_GENERIC> toSet() {
		return (Collector) TO_SET_COLLECTOR;
	}

	/** Returns a {@link Collector} that collects a {@code Stream}'s elements into a new hash set, potentially pre-allocated to handle the given size. */
	public static KEY_GENERIC Collector<KEY_GENERIC_TYPE, ?, OPEN_HASH_SET KEY_GENERIC> toSetWithExpectedSize(int expectedSize) {
		if (expectedSize <= Hash.DEFAULT_INITIAL_SIZE) {
			// Already below default capacity. Just use all default construction instead of fiddling with atomics in SizeDecreasingSupplier
			return toSet();
		}
		return Collector.of(
			new COLLECTIONS.SizeDecreasingSupplier<
#if KEYS_REFERENCE
					K,
#endif
					OPEN_HASH_SET KEY_GENERIC>(
			expectedSize, (int size) ->
				size <= Hash.DEFAULT_INITIAL_SIZE ? new OPEN_HASH_SET KEY_GENERIC() : new OPEN_HASH_SET KEY_GENERIC(size)),
		OPEN_HASH_SET::add,
		OPEN_HASH_SET::combine
#ifndef Linked
		, Collector.Characteristics.UNORDERED
#endif
		);
	}
#endif
#endif


#ifdef Custom
	/** Returns the hashing strategy.
	 *
	 * @return the hashing strategy of this custom hash set.
	 */

	public STRATEGY KEY_SUPER_GENERIC strategy() {
		return strategy;
	}
#endif

	private int realSize() {
		return containsNull ? size - 1 : size;
	}

	/** Ensures that this set can hold a certain number of elements without rehashing.
	 *
	 * @param capacity a number of elements; there will be no rehashing unless
	 * the set {@linkplain #size() size} exceeds this number.
	 */
	public void ensureCapacity(final int capacity) {
		final int needed = arraySize(capacity, f);
		if (needed > n) rehash(needed);
	}

	private void tryCapacity(final long capacity) {
		final int needed = (int)Math.min(1 << 30, Math.max(2, HashCommon.nextPowerOfTwo((long)Math.ceil(capacity / f))));
		if (needed > n) rehash(needed);
	}

#if KEYS_PRIMITIVE
	@Override
	public boolean addAll(COLLECTION c) {
		if (f <= .5) ensureCapacity(c.size()); // The resulting collection will be sized for c.size() elements
		else tryCapacity(size() + c.size()); // The resulting collection will be tentatively sized for size() + c.size() elements
		return super.addAll(c);
	}
#endif

	@Override
	public boolean addAll(Collection<? extends KEY_GENERIC_CLASS> c) {
		// The resulting collection will be at least c.size() big
		if (f <= .5) ensureCapacity(c.size()); // The resulting collection will be sized for c.size() elements
		else tryCapacity(size() + c.size()); // The resulting collection will be tentatively sized for size() + c.size() elements
		return super.addAll(c);
	}


	@Override
	public boolean add(final KEY_GENERIC_TYPE k) {
		int pos;

		if (KEY_EQUALS_NULL(k)) {
			if (containsNull) return false;
#ifdef Linked
			pos = n;
#endif
			containsNull = true;
#ifdef Custom
			key[n] = k;
#endif
		}
		else {
			KEY_GENERIC_TYPE curr;
			final KEY_GENERIC_TYPE[] key = this.key;

			// The starting point.
			if (! KEY_IS_NULL(curr = key[pos = KEY2INTHASH(k) & mask])) {
				if (KEY_EQUALS_NOT_NULL(curr, k)) return false;
				while(! KEY_IS_NULL(curr = key[pos = (pos + 1) & mask]))
					if (KEY_EQUALS_NOT_NULL(curr, k)) return false;
			}
			key[pos] = k;
		}

#ifdef Linked
		if (size == 0) {
			first = last = pos;
			// Special case of SET_UPPER_LOWER(link[pos], -1, -1);
			link[pos] = -1L;
		}
		else {
			SET_NEXT(link[last], pos);
			SET_UPPER_LOWER(link[pos], last, -1);
			last = pos;
		}
#endif

		if (size++ >= maxFill) rehash(arraySize(size + 1, f));
		if (ASSERTS) checkTable();
		return true;
	}

#if KEY_CLASS_Object
	/** Add a random element if not present, get the existing value if already present.
	 *
	 * This is equivalent to (but faster than) doing a:
	 * <pre>
	 * K exist = set.get(k);
	 * if (exist == null) {
	 *   set.add(k);
	 *   exist = k;
	 * }
	 * </pre>
	 */
	public KEY_GENERIC_TYPE addOrGet(final KEY_GENERIC_TYPE k) {
		int pos;

		if (KEY_EQUALS_NULL(k)) {
			if (containsNull) return key [n];
#ifdef Linked
			pos = n;
#endif
			containsNull = true;
#ifdef Custom
			key [n] = k;
#endif
		}
		else {
			KEY_GENERIC_TYPE curr;
			final KEY_GENERIC_TYPE[] key = this.key;

			// The starting point.
			if (! KEY_IS_NULL(curr = key[pos = KEY2INTHASH(k) & mask])) {
				if (KEY_EQUALS_NOT_NULL(curr, k)) return curr;
				while(! KEY_IS_NULL(curr = key[pos = (pos + 1) & mask]))
					if (KEY_EQUALS_NOT_NULL(curr, k)) return curr;
			}
			key[pos] = k;
		}

#ifdef Linked
		if (size == 0) {
			first = last = pos;
			// Special case of SET_UPPER_LOWER(link[pos], -1, -1);
			link[pos] = -1L;
		}
		else {
			SET_NEXT(link[last], pos);
			SET_UPPER_LOWER(link[pos], last, -1);
			last = pos;
		}
#endif

		if (size++ >= maxFill) rehash(arraySize(size + 1, f));
		if (ASSERTS) checkTable();
		return k;
	}
#endif

	/** Shifts left entries with the specified hash code, starting at the specified position,
	 * and empties the resulting free entry.
	 *
	 * @param pos a starting position.
	 */
	protected final void shiftKeys(int pos) {
		// Shift entries with the same hash.
		int last, slot;
		KEY_GENERIC_TYPE curr;
		final KEY_GENERIC_TYPE[] key = this.key;

		for(;;) {
			pos = ((last = pos) + 1) & mask;

			for(;;) {
				if (KEY_IS_NULL(curr = key[pos])) {
					key[last] = KEY_NULL;
					return;
				}
				slot = KEY2INTHASH(curr) & mask;
				if (last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos) break;
				pos = (pos + 1) & mask;
			}

			key[last] = curr;
#ifdef Linked
			fixPointers(pos, last);
#endif
		}
	}

	private boolean removeEntry(final int pos) {
		size--;
#ifdef Linked
		fixPointers(pos);
#endif
		shiftKeys(pos);
		if (n > minN && size < maxFill / 4 && n > DEFAULT_INITIAL_SIZE) rehash(n / 2);
		return true;
	}

	private boolean removeNullEntry() {
		containsNull = false;
		key[n] = KEY_NULL;
		size--;
#ifdef Linked
		fixPointers(n);
#endif
		if (n > minN && size < maxFill / 4 && n > DEFAULT_INITIAL_SIZE) rehash(n / 2);
		return true;
	}

	SUPPRESS_WARNINGS_KEY_UNCHECKED
	@Override
	public boolean remove(final KEY_TYPE k) {
		if (KEY_EQUALS_NULL(KEY_GENERIC_CAST k)) {
			if (containsNull) return removeNullEntry();
			return false;
		}

		KEY_GENERIC_TYPE curr;
		final KEY_GENERIC_TYPE[] key = this.key;
		int pos;

		// The starting point.
		if (KEY_IS_NULL(curr = key[pos = KEY2INTHASH_CAST(k) & mask])) return false;
		if (KEY_EQUALS_NOT_NULL_CAST(k, curr)) return removeEntry(pos);

		while(true) {
			if (KEY_IS_NULL(curr = key[pos = (pos + 1) & mask])) return false;
			if (KEY_EQUALS_NOT_NULL_CAST(k, curr)) return removeEntry(pos);
		}
	}

	SUPPRESS_WARNINGS_KEY_UNCHECKED
	@Override
	public boolean contains(final KEY_TYPE k) {
		if (KEY_EQUALS_NULL(KEY_GENERIC_CAST k)) return containsNull;

		KEY_GENERIC_TYPE curr;
		final KEY_GENERIC_TYPE[] key = this.key;
		int pos;

		// The starting point.
		if (KEY_IS_NULL(curr = key[pos = KEY2INTHASH_CAST(k) & mask])) return false;
		if (KEY_EQUALS_NOT_NULL_CAST(k, curr)) return true;

		while(true) {
			if (KEY_IS_NULL(curr = key[pos = (pos + 1) & mask])) return false;
			if (KEY_EQUALS_NOT_NULL_CAST(k, curr)) return true;
		}
	}

#if KEY_CLASS_Object
	/** Returns the element of this set that is equal to the given key, or {@code null}.
	 * @return the element of this set that is equal to the given key, or {@code null}.
	 */
	SUPPRESS_WARNINGS_KEY_UNCHECKED
	public K get(final Object k) {
		if (KEY_EQUALS_NULL(KEY_GENERIC_CAST k)) return key[n]; // This is correct independently of the value of containsNull and of the set being custom

		KEY_GENERIC_TYPE curr;
		final KEY_GENERIC_TYPE[] key = this.key;
		int pos;

		// The starting point.
		if (KEY_IS_NULL(curr = key[pos = KEY2INTHASH_CAST(k) & mask])) return null;
		if (KEY_EQUALS_NOT_NULL_CAST(k, curr)) return curr;
		// There's always an unused entry.
		while(true) {
			if (KEY_IS_NULL(curr = key[pos = (pos + 1) & mask])) return null;
			if (KEY_EQUALS_NOT_NULL_CAST(k, curr)) return curr;
		}
	}
#endif

#ifdef Linked

	/** Removes the first key in iteration order.
	 * @return the first key.
	 * @throws NoSuchElementException is this set is empty.
	 */
	public KEY_GENERIC_TYPE REMOVE_FIRST_KEY() {
		if (size == 0) throw new NoSuchElementException();
		final int pos = first;

		// Abbreviated version of fixPointers(pos)
		if (size == 1) first = last = -1;
		else {
			first = GET_NEXT(link[pos]);
			if (0 <= first) {
				// Special case of SET_PREV(link[first], -1)
				link[first] |= (-1 & 0xFFFFFFFFL) << 32;
			}
		}

		final KEY_GENERIC_TYPE k = key[pos];
		size--;
		if (KEY_EQUALS_NULL(k)) {
			containsNull = false;
			key[n] = KEY_NULL;
		}
		else shiftKeys(pos);
		if (n > minN && size < maxFill / 4 && n > DEFAULT_INITIAL_SIZE) rehash(n / 2);
		return k;
	}

	/** Removes the the last key in iteration order.
	 * @return the last key.
	 * @throws NoSuchElementException is this set is empty.
	 */
	public KEY_GENERIC_TYPE REMOVE_LAST_KEY() {
		if (size == 0) throw new NoSuchElementException();
		final int pos = last;

		// Abbreviated version of fixPointers(pos)
		if (size == 1) first = last = -1;
		else {
			last = GET_PREV(link[pos]);
			if (0 <= last) {
				// Special case of SET_NEXT(link[last], -1)
				link[last] |= -1 & 0xFFFFFFFFL;
			}
		}

		final KEY_GENERIC_TYPE k = key[pos];
		size--;
		if (KEY_EQUALS_NULL(k)) {
			containsNull = false;
			key[n] = KEY_NULL;
		}
		else shiftKeys(pos);
		if (n > minN && size < maxFill / 4 && n > DEFAULT_INITIAL_SIZE) rehash(n / 2);
		return k;
	}

	private void moveIndexToFirst(final int i) {
		if (size == 1 || first == i) return;
		if (last == i) {
			last = GET_PREV(link[i]);
			// Special case of SET_NEXT(link[last], -1);
			link[last] |= -1 & 0xFFFFFFFFL;
		}
		else {
			final long linki = link[i];
			final int prev = GET_PREV(linki);
			final int next = GET_NEXT(linki);
			COPY_NEXT(link[prev], linki);
			COPY_PREV(link[next], linki);
		}
		SET_PREV(link[first], i);
		SET_UPPER_LOWER(link[i], -1, first);
		first = i;
	}

	private void moveIndexToLast(final int i) {
		if (size == 1 ||  last == i) return;
		if (first == i) {
			first = GET_NEXT(link[i]);
			// Special case of SET_PREV(link[first], -1);
			link[first] |= (-1 & 0xFFFFFFFFL) << 32;
		}
		else {
			final long linki = link[i];
			final int prev = GET_PREV(linki);
			final int next = GET_NEXT(linki);
			COPY_NEXT(link[prev], linki);
			COPY_PREV(link[next], linki);
		}
		SET_NEXT(link[last], i);
		SET_UPPER_LOWER(link[i], last, -1);
		last = i;
	}

	/** Adds a key to the set; if the key is already present, it is moved to the first position of the iteration order.
	 *
	 * @param k the key.
	 * @return true if the key was not present.
	 */
	public boolean addAndMoveToFirst(final KEY_GENERIC_TYPE k) {
		int pos;

		if (KEY_EQUALS_NULL(k)) {
			if (containsNull) {
				moveIndexToFirst(n);
				return false;
			}
			containsNull = true;
			pos = n;
		}
		else {
			// The starting point.
			final KEY_GENERIC_TYPE key[] = this.key;
			pos = KEY2INTHASH(k) & mask;

			// There's always an unused entry. TODO
			while(! KEY_IS_NULL(key[pos])) {
				if (KEY_EQUALS_NOT_NULL(k, key[pos])) {
					moveIndexToFirst(pos);
					return false;
				}

				pos = (pos + 1) & mask;
			}
		}

		key[pos] = k;

		if (size == 0) {
			first = last = pos;
			// Special case of SET_UPPER_LOWER(link[pos], -1, -1);
			link[pos] = -1L;
		}
		else {
			SET_PREV(link[first], pos);
			SET_UPPER_LOWER(link[pos], -1, first);
			first = pos;
		}

		if (size++ >= maxFill) rehash(arraySize(size, f));
		if (ASSERTS) checkTable();
		return true;
	}

	/** Adds a key to the set; if the key is already present, it is moved to the last position of the iteration order.
	 *
	 * @param k the key.
	 * @return true if the key was not present.
	 */
	public boolean addAndMoveToLast(final KEY_GENERIC_TYPE k) {
		int pos;

		if (KEY_EQUALS_NULL(k)) {
			if (containsNull) {
				moveIndexToLast(n);
				return false;
			}
			containsNull = true;
			pos = n;
		}
		else {
			// The starting point.
			final KEY_GENERIC_TYPE key[] = this.key;
			pos = KEY2INTHASH(k) & mask;

			// There's always an unused entry.
			while(! KEY_IS_NULL(key[pos])) {
				if (KEY_EQUALS_NOT_NULL(k, key[pos])) {
					moveIndexToLast(pos);
					return false;
				}

				pos = (pos + 1) & mask;
			}
		}

		key[pos] = k;

		if (size == 0) {
			first = last = pos;
			// Special case of SET_UPPER_LOWER(link[pos], -1, -1);
			link[pos] = -1L;
		}
		else {
			SET_NEXT(link[last], pos);
			SET_UPPER_LOWER(link[pos], last, -1);
			last = pos;
		}

		if (size++ >= maxFill) rehash(arraySize(size, f));
		if (ASSERTS) checkTable();
		return true;
	}

#endif

	/* Removes all elements from this set.
	 *
	 * <p>To increase object reuse, this method does not change the table size.
	 * If you want to reduce the table size, you must use {@link #trim()}.
	 *
	 */
	@Override
	public void clear() {
		if (size == 0) return;
		size = 0;
		containsNull = false;
		Arrays.fill(key, KEY_NULL);
#ifdef Linked
		first = last = -1;
#endif
	}


	@Override
	public int size() {
		return size;
	}

	@Override
	public boolean isEmpty() {
		return size == 0;
	}

#ifdef Linked

	/** Modifies the {@link #link} vector so that the given entry is removed.
	 * This method will complete in constant time.
	 *
	 * @param i the index of an entry.
	 */
	protected void fixPointers(final int i) {
		if (size == 0) {
			first = last = -1;
			return;
		}
		if (first == i) {
			first = GET_NEXT(link[i]);
			if (0 <= first) {
				// Special case of SET_PREV(link[first], -1)
				link[first] |= (-1 & 0xFFFFFFFFL) << 32;
			}
			return;
		}
		if (last == i) {
			last = GET_PREV(link[i]);
			if (0 <= last) {
				// Special case of SET_NEXT(link[last], -1)
				link[last] |= -1 & 0xFFFFFFFFL;
			}
			return;
		}
		final long linki = link[i];
		final int prev = GET_PREV(linki);
		final int next = GET_NEXT(linki);
		COPY_NEXT(link[prev], linki);
		COPY_PREV(link[next], linki);
	}


	/** Modifies the {@link #link} vector for a shift from s to d.
	 * This method will complete in constant time.
	 *
	 * @param s the source position.
	 * @param d the destination position.
	 */
	protected void fixPointers(int s, int d) {
		if (size == 1) {
			first = last = d;
			// Special case of SET(link[d], -1, -1)
			link[d] = -1L;
			return;
		}
		if (first == s) {
			first = d;
			SET_PREV(link[GET_NEXT(link[s])], d);
			link[d] = link[s];
			return;
		}
		if (last == s) {
			last = d;
			SET_NEXT(link[GET_PREV(link[s])], d);
			link[d] = link[s];
			return;
		}
		final long links = link[s];
		final int prev = GET_PREV(links);
		final int next = GET_NEXT(links);
		SET_NEXT(link[prev], d);
		SET_PREV(link[next], d);
		link[d] = links;
	}


	/** Returns the first element of this set in iteration order.
	 *
	 * @return the first element in iteration order.
	 */
	@Override
	public KEY_GENERIC_TYPE FIRST() {
		if (size == 0) throw new NoSuchElementException();
		return key[first];
	}

	/** Returns the last element of this set in iteration order.
	 *
	 * @return the last element in iteration order.
	 */
	@Override
	public KEY_GENERIC_TYPE LAST() {
		if (size == 0) throw new NoSuchElementException();
		return key[last];
	}

	/** {@inheritDoc}
	 * @implSpec This implementation just throws an {@link UnsupportedOperationException}.*/
	@Override
	public SORTED_SET KEY_GENERIC tailSet(KEY_GENERIC_TYPE from) { throw new UnsupportedOperationException(); }

	/** {@inheritDoc}
	 * @implSpec This implementation just throws an {@link UnsupportedOperationException}.*/
	@Override
	public SORTED_SET KEY_GENERIC headSet(KEY_GENERIC_TYPE to) { throw new UnsupportedOperationException(); }

	/** {@inheritDoc}
	 * @implSpec This implementation just throws an {@link UnsupportedOperationException}.*/
	@Override
	public SORTED_SET KEY_GENERIC subSet(KEY_GENERIC_TYPE from, KEY_GENERIC_TYPE to) { throw new UnsupportedOperationException(); }

	/** {@inheritDoc}
	 * @implSpec This implementation just returns {@code null}.*/
	@Override
	public KEY_COMPARATOR KEY_SUPER_GENERIC comparator() { return null; }


	/** A list iterator over a linked set.
	 *
	 * <p>This class provides a list iterator over a linked hash set. The constructor runs in constant time.
	 */
	private final class SetIterator implements KEY_LIST_ITERATOR KEY_GENERIC {
		/** The entry that will be returned by the next call to {@link java.util.ListIterator#previous()} (or {@code null} if no previous entry exists). */
		int prev = -1;
		/** The entry that will be returned by the next call to {@link java.util.ListIterator#next()} (or {@code null} if no next entry exists). */
		int next = -1;
		/** The last entry that was returned (or -1 if we did not iterate or used {@link #remove()}). */
		int curr = -1;
		/** The current index (in the sense of a {@link java.util.ListIterator}). When -1, we do not know the current index.*/
		int index = -1;

		SetIterator() {
			next = first;
			index = 0;
		}

		SetIterator(KEY_GENERIC_TYPE from) {
			if (KEY_EQUALS_NULL(from)) {
				if (OPEN_HASH_SET.this.containsNull) {
					next = GET_NEXT(link[n]);
					prev = n;
					return;
				}
				else throw new NoSuchElementException("The key " + from + " does not belong to this set.");
			}

			if (KEY_EQUALS(key[last], from)) {
				prev = last;
				index = size;
				return;
			}

			// The starting point.
			final KEY_GENERIC_TYPE key[] = OPEN_HASH_SET.this.key;
			int pos = KEY2INTHASH(from) & mask;

			// There's always an unused entry.
			while(! KEY_IS_NULL(key[pos])) {
				if (KEY_EQUALS_NOT_NULL(key[pos], from)) {
					// Note: no valid index known.
					next = GET_NEXT(link[pos]);
					prev = pos;
					return;
				}
				pos = (pos + 1) & mask;
			}
			throw new NoSuchElementException("The key " + from + " does not belong to this set.");
		}

		@Override
		public boolean hasNext() { return next != -1; }
		@Override
		public boolean hasPrevious() { return prev != -1; }

		@Override
		public KEY_GENERIC_TYPE NEXT_KEY() {
			if (! hasNext()) throw new NoSuchElementException();

			curr = next;
			next = GET_NEXT(link[curr]);
			prev = curr;

			if (index >= 0) index++;
			if (ASSERTS) assert curr == n || ! KEY_IS_NULL(key[curr]) : "Position " + curr + " is not used";
			return key[curr];
		}

		@Override
		public KEY_GENERIC_TYPE PREV_KEY() {
			if (! hasPrevious()) throw new NoSuchElementException();

			curr = prev;
			prev = GET_PREV(link[curr]);
			next = curr;

			if (index >= 0) index--;

			return key[curr];
		}

		@Override
		public void forEachRemaining(final METHOD_ARG_KEY_CONSUMER action) {
			final KEY_GENERIC_TYPE key[] = OPEN_HASH_SET.this.key;
			final long link[] = OPEN_HASH_SET.this.link;

			while (next != -1) {
				curr = next;
				next = GET_NEXT(link[curr]);
				prev = curr;

				if (index >= 0) index++;
				if (ASSERTS) assert curr == n || ! KEY_IS_NULL(key[curr]) : "Position " + curr + " is not used";
				action.accept(key[curr]);
			}
		}

		private final void ensureIndexKnown() {
			if (index >= 0) return;
			if (prev == -1) {
				index = 0;
				return;
			}
			if (next == -1) {
				index = size;
				return;
			}
			int pos = first;
			index = 1;
			while(pos != prev) {
				pos = GET_NEXT(link[pos]);
				index++;
			}
		}

		@Override
		public int nextIndex() {
			ensureIndexKnown();
			return index;
		}

		@Override
		public int previousIndex() {
			ensureIndexKnown();
			return index - 1;
		}

		@Override
		public void remove() {
			ensureIndexKnown();
			if (curr == -1) throw new IllegalStateException();

			if (curr == prev) {
				/* If the last operation was a next(), we are removing an entry that preceeds
				 * the current index, and thus we must decrement it. */
				index--;
				prev = GET_PREV(link[curr]);
			}
			else
				next = GET_NEXT(link[curr]);

			size--;
			/* Now we manually fix the pointers. Because of our knowledge of next
			 * and prev, this is going to be faster than calling fixPointers(). */
			if (prev == -1) first = next;
			else
				SET_NEXT(link[prev], next);
			if (next == -1) last = prev;
			else
				SET_PREV(link[next], prev);

			int last, slot, pos = curr;
			curr = -1;

			if (pos == n) {
				OPEN_HASH_SET.this.containsNull = false;
				OPEN_HASH_SET.this.key[n] = KEY_NULL;
			}
			else {
				KEY_GENERIC_TYPE curr;
				final KEY_GENERIC_TYPE[] key = OPEN_HASH_SET.this.key;
				// We have to horribly duplicate the shiftKeys() code because we need to update next/prev.
				for(;;) {
					pos = ((last = pos) + 1) & mask;
					for(;;) {
						if (KEY_IS_NULL(curr = key[pos])) {
							key[last] = KEY_NULL;
							return;
						}
						slot = KEY2INTHASH(curr) & mask;
						if (last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos) break;
						pos = (pos + 1) & mask;
					}

					key[last] = curr;
					if (next == pos) next = last;
					if (prev == pos) prev = last;
					fixPointers(pos, last);
				}
			}
		}
	}

	/** Returns a type-specific list iterator on the elements in this set, starting from a given element of the set.
	 * Please see the class documentation for implementation details.
	 *
	 * @param from an element to start from.
	 * @return a type-specific list iterator starting at the given element.
	 * @throws IllegalArgumentException if {@code from} does not belong to the set.
	 */
	@Override
	public KEY_LIST_ITERATOR KEY_GENERIC iterator(KEY_GENERIC_TYPE from) {
		return new SetIterator(from);
	}

	/** Returns a type-specific list iterator on the elements in this set, starting from the first element.
	 * Please see the class documentation for implementation details.
	 *
	 * @return a type-specific list iterator starting at the first element.
	 */
	@Override
	public KEY_LIST_ITERATOR KEY_GENERIC iterator() {
		return new SetIterator();
	}

	private static final int SPLITERATOR_CHARACTERISTICS = SPLITERATORS.SET_SPLITERATOR_CHARACTERISTICS | java.util.Spliterator.ORDERED;

	/** {@inheritDoc}
	 *
	 * <p>There isn't a way to split efficiently while still preserving order for a linked data structure,
	 * so this implementation is just backed by the iterator. Thus, this spliterator is not well optimized
	 * for parallel streams.
	 *
	 * <p>Note, contrary to the specification of {@link java.util.SortedSet}, this spliterator does not,
	 * report {@link java.util.Spliterator#SORTED}. This is because iteration order is based on insertion
	 * order, not natural ordering.
	 */
	@Override
	public KEY_SPLITERATOR KEY_GENERIC spliterator() {
		return SPLITERATORS.asSpliterator(
			iterator(), it.unimi.dsi.fastutil.Size64.sizeOf(this), SPLITERATOR_CHARACTERISTICS);
	}

	@Override
	public void forEach(final METHOD_ARG_KEY_CONSUMER action) {
		int curr;
		int next = first;
		while (next != -1) {
			curr = next;
			next = GET_NEXT(link[curr]);
			if (ASSERTS) assert curr == n || ! KEY_IS_NULL(key[curr]) : "Position " + curr + " is not used";
			action.accept(key[curr]);
		}
	}

#else

	/** An iterator over a hash set. */

	private final class SetIterator implements KEY_ITERATOR KEY_GENERIC {
		/** The index of the last entry returned, if positive or zero; initially, {@link #n}. If negative, the last
			element returned was that of index {@code - pos - 1} from the {@link #wrapped} list. */
		int pos = n;
		/** The index of the last entry that has been returned (more precisely, the value of {@link #pos} if {@link #pos} is positive,
			or {@link Integer#MIN_VALUE} if {@link #pos} is negative). It is -1 if either
			we did not return an entry yet, or the last returned entry has been removed. */
		int last = -1;
		/** A downward counter measuring how many entries must still be returned. */
		int c = size;
		/** A boolean telling us whether we should return the null key. */
		boolean mustReturnNull = OPEN_HASH_SET.this.containsNull;
		/** A lazily allocated list containing elements that have wrapped around the table because of removals. */
		ARRAY_LIST KEY_GENERIC wrapped;

		@Override
		public boolean hasNext() {
			return c != 0;
		}

		@Override
		public KEY_GENERIC_TYPE NEXT_KEY() {
			if (! hasNext()) throw new NoSuchElementException();
			c--;
			if (mustReturnNull) {
				mustReturnNull = false;
				last = n;
				return key[n];
			}
			final KEY_GENERIC_TYPE key[] = OPEN_HASH_SET.this.key;
			for(;;) {
				if (--pos < 0) {
					// We are just enumerating elements from the wrapped list.
					last = Integer.MIN_VALUE;
					return wrapped.GET_KEY(- pos - 1);
				}
				if (! KEY_IS_NULL(key[pos])) return key[last = pos];
			}
		}


		/** Shifts left entries with the specified hash code, starting at the specified position,
		 * and empties the resulting free entry.
		 *
		 * @param pos a starting position.
		 */
		private final void shiftKeys(int pos) {
			// Shift entries with the same hash.
			int last, slot;
			KEY_GENERIC_TYPE curr;
			final KEY_GENERIC_TYPE[] key = OPEN_HASH_SET.this.key;

			for(;;) {
				pos = ((last = pos) + 1) & mask;

				for(;;) {
					if (KEY_IS_NULL(curr = key[pos])) {
						key[last] = KEY_NULL;
						return;
					}
					slot = KEY2INTHASH(curr) & mask;
					if (last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos) break;
					pos = (pos + 1) & mask;
				}

				if (pos < last) { // Wrapped entry.
					if (wrapped == null) wrapped = new ARRAY_LIST KEY_GENERIC_DIAMOND(2);
					wrapped.add(key[pos]);
				}

				key[last] = curr;
			}
		}

		@Override
		public void remove() {
			if (last == -1) throw new IllegalStateException();
			if (last == n) {
				OPEN_HASH_SET.this.containsNull = false;
				OPEN_HASH_SET.this.key[n] = KEY_NULL;
			}
			else if (pos >= 0) shiftKeys(last);
			else {
				// We're removing wrapped entries.
#if KEYS_REFERENCE
				OPEN_HASH_SET.this.remove(wrapped.set(- pos - 1, null));
#else
				OPEN_HASH_SET.this.remove(wrapped.GET_KEY(- pos - 1));
#endif
				last = -1; // Note that we must not decrement size
				return;
			}

			size--;
			last = -1; // You can no longer remove this entry.
			if (ASSERTS) checkTable();
		}

		@Override
		public void forEachRemaining(final METHOD_ARG_KEY_CONSUMER action) {
			final KEY_GENERIC_TYPE key[] = OPEN_HASH_SET.this.key;

			if (mustReturnNull) {
				mustReturnNull = false;
				last = n;
				action.accept(key[n]);
				c--;
			}

			while(c != 0) {
				if (--pos < 0) {
					// We are just enumerating elements from the wrapped list.
					last = Integer.MIN_VALUE;
					action.accept(wrapped.GET_KEY(- pos - 1));
					c--;
				} else if (! KEY_IS_NULL(key[pos])) {
					action.accept(key[last = pos]);
					c--;
				}
			}
		}
	}

	@Override
	public KEY_ITERATOR KEY_GENERIC iterator() {
		return new SetIterator();
	}

	private final class SetSpliterator implements KEY_SPLITERATOR KEY_GENERIC {
		private static final int POST_SPLIT_CHARACTERISTICS = SPLITERATORS.SET_SPLITERATOR_CHARACTERISTICS & ~java.util.Spliterator.SIZED;

		/** The index (which bucket) of the next item to give to the action.
		 * Unlike {@link SetIterator}, this counts up instead of down.
		 */
		int pos = 0;
		/** The maximum bucket (exclusive) to iterate to */
		int max = n;
		/** An upwards counter counting how many we have given */
		int c = 0;
		/** A boolean telling us whether we should return the null key. */
		boolean mustReturnNull = OPEN_HASH_SET.this.containsNull;
		boolean hasSplit = false;


		SetSpliterator() {}

		SetSpliterator(int pos, int max, boolean mustReturnNull, boolean hasSplit) {
			this.pos = pos;
			this.max = max;
			this.mustReturnNull = mustReturnNull;
			this.hasSplit = hasSplit;
		}

		@Override
		public boolean tryAdvance(final METHOD_ARG_KEY_CONSUMER action) {
			if (mustReturnNull) {
				mustReturnNull = false;
				++c;
				action.accept(key[n]);
				return true;
			}
			final KEY_GENERIC_TYPE key[] = OPEN_HASH_SET.this.key;
			while (pos < max) {
				if (! KEY_IS_NULL(key[pos])) {
					++c;
					action.accept(key[pos++]);
					return true;
				} else {
					++pos;
				}
			}
			return false;
		}

		@Override
		public void forEachRemaining(final METHOD_ARG_KEY_CONSUMER action) {
			final KEY_GENERIC_TYPE key[] = OPEN_HASH_SET.this.key;

			if (mustReturnNull) {
				mustReturnNull = false;
				action.accept(key[n]);
				++c;
			}

			while (pos < max) {
				if (! KEY_IS_NULL(key[pos])) {
					action.accept(key[pos]);
					++c;
				}
				++pos;
			}
		}

		@Override
		public int characteristics() {
			return hasSplit ? POST_SPLIT_CHARACTERISTICS : SPLITERATORS.SET_SPLITERATOR_CHARACTERISTICS;
		}

		@Override
		public long estimateSize() {
			if (!hasSplit) {
				// Root spliterator; we know how many are remaining.
				return size - c;
			} else {
				// After we split, we can no longer know exactly how many we have (or at least not efficiently).
				// (size / n) * (max - pos) aka currentTableDensity * numberOfBucketsLeft seems like a good estimate.
				return Math.min(size - c, (long)(((double)realSize() / n) * (max - pos)) + (mustReturnNull ? 1 : 0));
			}
		}

		@Override
		public SetSpliterator trySplit() {
			if (pos >= max - 1) return null;
			int retLen = (max - pos) >> 1;
			if (retLen <= 1) return null;
			int myNewPos = pos + retLen;
			int retPos = pos;
			int retMax = myNewPos;
			// Since null is returned first, and the convention is that the returned split is the prefix of elements,
			// the split will take care of returning null (if needed), and we won't return it anymore.
			SetSpliterator split = new SetSpliterator(retPos, retMax, mustReturnNull, true);
			this.pos = myNewPos;
			this.mustReturnNull = false;
			this.hasSplit = true;
			return split;
		}

		@Override
		public long skip(long n) {
			if (n < 0) throw new IllegalArgumentException("Argument must be nonnegative: " + n);
			if (n == 0) return 0;
			long skipped = 0;
			if (mustReturnNull) {
				mustReturnNull = false;
				++skipped;
				--n;
			}
			final KEY_GENERIC_TYPE key[] = OPEN_HASH_SET.this.key;
			while (pos < max && n > 0) {
				if (! KEY_IS_NULL(key[pos++])) {
					++skipped;
					--n;
				}
			}
			return skipped;
		}
	}

	@Override
	public KEY_SPLITERATOR KEY_GENERIC spliterator() {
		return new SetSpliterator();
	}

	@Override
	public void forEach(final METHOD_ARG_KEY_CONSUMER action) {
		if (containsNull) action.accept(key[n]);
		final KEY_GENERIC_TYPE key[] = this.key;
		for(int pos = n; pos-- != 0; ) if (! KEY_IS_NULL(key[pos])) action.accept(key[pos]);
	}

#endif


	/** Rehashes this set, making the table as small as possible.
	 *
	 * <p>This method rehashes the table to the smallest size satisfying the
	 * load factor. It can be used when the set will not be changed anymore, so
	 * to optimize access speed and size.
	 *
	 * <p>If the table size is already the minimum possible, this method
	 * does nothing.
	 *
	 * @return true if there was enough memory to trim the set.
	 * @see #trim(int)
	 */

	public boolean trim() {
		return trim(size);
	}


	/** Rehashes this set if the table is too large.
	 *
	 * <p>Let <var>N</var> be the smallest table size that can hold
	 * <code>max(n,{@link #size()})</code> entries, still satisfying the load factor. If the current
	 * table size is smaller than or equal to <var>N</var>, this method does
	 * nothing. Otherwise, it rehashes this set in a table of size
	 * <var>N</var>.
	 *
	 * <p>This method is useful when reusing sets.  {@linkplain #clear() Clearing a
	 * set} leaves the table size untouched. If you are reusing a set
	 * many times, you can call this method with a typical
	 * size to avoid keeping around a very large table just
	 * because of a few large transient sets.
	 *
	 * @param n the threshold for the trimming.
	 * @return true if there was enough memory to trim the set.
	 * @see #trim()
	 */

	public boolean trim(final int n) {
		final int l = HashCommon.nextPowerOfTwo((int)Math.ceil(n / f));
		if (l >= this.n || size > maxFill(l, f)) return true;
		try {
			rehash(l);
		}
		catch(OutOfMemoryError cantDoIt) { return false; }
		return true;
	}

	/** Rehashes the set.
	 *
	 * <p>This method implements the basic rehashing strategy, and may be
	 * overriden by subclasses implementing different rehashing strategies (e.g.,
	 * disk-based rehashing). However, you should not override this method
	 * unless you understand the internal workings of this class.
	 *
	 * @param newN the new size
	 */

	SUPPRESS_WARNINGS_KEY_UNCHECKED
	protected void rehash(final int newN) {
		final KEY_GENERIC_TYPE key[] = this.key;

		final int mask = newN - 1; // Note that this is used by the hashing macro
		final KEY_GENERIC_TYPE newKey[] = KEY_GENERIC_ARRAY_CAST new KEY_TYPE[newN + 1];

#ifdef Linked
		int i = first, prev = -1, newPrev = -1, t, pos;
		final long link[] = this.link;
		final long newLink[] = new long[newN + 1];
		first = -1;

		for(int j = size; j-- != 0;) {
			if (KEY_EQUALS_NULL(key[i])) pos = newN;
			else {
				pos = KEY2INTHASH(key[i]) & mask;
				while (! KEY_IS_NULL(newKey[pos])) pos = (pos + 1) & mask;
			}

			newKey[pos] = key[i];

			if (prev != -1) {
				SET_NEXT(newLink[newPrev], pos);
				SET_PREV(newLink[pos], newPrev);
				newPrev = pos;
			}
			else {
				newPrev = first = pos;
				// Special case of SET(newLink[pos], -1, -1);
				newLink[pos] = -1L;
			}

			t = i;
			i = GET_NEXT(link[i]);
			prev = t;
		}

		this.link = newLink;
		this.last = newPrev;
		if (newPrev != -1)
			// Special case of SET_NEXT(newLink[newPrev], -1);
			newLink[newPrev] |= -1 & 0xFFFFFFFFL;
#else
		int i = n, pos;

		for(int j = realSize(); j-- != 0;) {
			while(KEY_IS_NULL(key[--i]));
			if (! KEY_IS_NULL(newKey[pos = KEY2INTHASH(key[i]) & mask]))
				while (! KEY_IS_NULL(newKey[pos = (pos + 1) & mask]));
			newKey[pos] = key[i];
		}
#endif

		n = newN;
		this.mask = mask;
		maxFill = maxFill(n, f);
		this.key = newKey;
	}


	/** Returns a deep copy of this set.
	 *
	 * <p>This method performs a deep copy of this hash set; the data stored in the
	 * set, however, is not cloned. Note that this makes a difference only for object keys.
	 *
	 *  @return a deep copy of this set.
	 */
	@Override
	SUPPRESS_WARNINGS_KEY_UNCHECKED
	public OPEN_HASH_SET KEY_GENERIC clone() {
		OPEN_HASH_SET KEY_GENERIC c;
		try {
			c = (OPEN_HASH_SET KEY_GENERIC)super.clone();
		}
		catch(CloneNotSupportedException cantHappen) {
			throw new InternalError();
		}
		c.key = key.clone();
		c.containsNull = containsNull;
#ifdef Linked
		c.link = link.clone();
#endif
#ifdef Custom
		c.strategy = strategy;
#endif
		return c;
	}

	/** Returns a hash code for this set.
	 *
	 * This method overrides the generic method provided by the superclass.
	 * Since {@code equals()} is not overriden, it is important
	 * that the value returned by this method is the same value as
	 * the one returned by the overriden method.
	 *
	 * @return a hash code for this set.
	 */
	@Override
	public int hashCode() {
		int h = 0;
		for(int j = realSize(), i = 0; j-- != 0;) {
			while(KEY_IS_NULL(key[i])) i++;
#if KEYS_REFERENCE
			if (this != key[i])
#endif
				h += KEY2JAVAHASH_NOT_NULL(key[i]);
			i++;
		}

		// Zero / null have hash zero.
		return h;
	}


	private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {
		final KEY_ITERATOR KEY_GENERIC i = iterator();
		s.defaultWriteObject();
		for(int j = size; j-- != 0;) s.WRITE_KEY(i.NEXT_KEY());
	}


	SUPPRESS_WARNINGS_KEY_UNCHECKED
	private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {
		s.defaultReadObject();

		n = arraySize(size, f);
		maxFill = maxFill(n, f);
		mask = n - 1;

		final KEY_GENERIC_TYPE key[] = this.key = KEY_GENERIC_ARRAY_CAST new KEY_TYPE[n + 1];
#ifdef Linked
		final long link[] = this.link = new long[n + 1];
		int prev = -1;
		first = last = -1;
#endif

		KEY_GENERIC_TYPE k;

		for(int i = size, pos; i-- != 0;) {

			k = KEY_GENERIC_CAST s.READ_KEY();

			if (KEY_EQUALS_NULL(k)) {
				pos = n;
				containsNull = true;
			}
			else {
				if (! KEY_IS_NULL(key[pos = KEY2INTHASH(k) & mask]))
					while (! KEY_IS_NULL(key[pos = (pos + 1) & mask]));
			}

			key[pos] = k;

#ifdef Linked
			if (first != -1) {
				SET_NEXT(link[prev], pos);
				SET_PREV(link[pos], prev);
				prev = pos;
			}
			else {
				prev = first = pos;
				// Special case of SET_PREV(newLink[pos], -1);
				link[pos] |= (-1L & 0xFFFFFFFFL) << 32;
			}
#endif
		}

#ifdef Linked
		last = prev;
		if (prev != -1)
			// Special case of SET_NEXT(link[prev], -1);
			link[prev] |= -1 & 0xFFFFFFFFL;
#endif

		if (ASSERTS) checkTable();
	}


#ifdef ASSERTS_CODE
	private void checkTable() {
		assert (n & -n) == n : "Table length is not a power of two: " + n;
		assert n == key.length - 1;
		int n = key.length - 1;
		while(n-- != 0)
			if (! KEY_IS_NULL(key[n]) && ! contains(key[n]))
				throw new AssertionError("Hash table has key " + key[n] + " marked as occupied, but the key does not belong to the table");

#if KEYS_PRIMITIVE
		java.util.HashSet<KEY_GENERIC_CLASS> s = new java.util.HashSet<KEY_GENERIC_CLASS> ();
#else
		java.util.HashSet<Object> s = new java.util.HashSet<Object>();
#endif

		for(int i = key.length - 1; i-- != 0;)
			if (! KEY_IS_NULL(key[i]) && ! s.add(key[i])) throw new AssertionError("Key " + key[i] + " appears twice at position " + i);

#ifdef Linked
		KEY_LIST_ITERATOR KEY_GENERIC i = iterator();
		KEY_GENERIC_TYPE k;
		n = size();
		while(n-- != 0)
			if (! contains(k = i.NEXT_KEY()))
				throw new AssertionError("Linked hash table forward enumerates key " + k + ", but the key does not belong to the table");

		if (i.hasNext()) throw new AssertionError("Forward iterator not exhausted");

		n = size();
		if (n > 0) {
			i = iterator(LAST());
			while(n-- != 0)
				if (! contains(k = i.PREV_KEY()))
					throw new AssertionError("Linked hash table backward enumerates key " + k + ", but the key does not belong to the table");

			if (i.hasPrevious()) throw new AssertionError("Previous iterator not exhausted");
		}
#endif
	}
#else
	private void checkTable() {}
#endif

#ifdef TEST

	private static long seed = System.currentTimeMillis();
	private static java.util.Random r = new java.util.Random(seed);

	private static KEY_TYPE genKey() {
#if KEY_CLASS_Byte || KEY_CLASS_Short || KEY_CLASS_Character
		return (KEY_TYPE)(r.nextInt());
#elif KEYS_PRIMITIVE
		return r.NEXT_KEY();
#elif KEY_CLASS_Object
#ifdef Custom
		int i = r.nextInt(3);
		byte a[] = new byte[i];
		while(i-- != 0) a[i] = (byte)r.nextInt();
		return a;
#else
		return Integer.toBinaryString(r.nextInt());
#endif
#else
		return new java.io.Serializable() {};
#endif
	}


	private static final class ArrayComparator implements java.util.Comparator {
		public int compare(Object a, Object b) {
			byte[] aa = (byte[])a;
			byte[] bb = (byte[])b;
			int length = Math.min(aa.length, bb.length);
			for(int i = 0; i < length; i++) {
				if (aa[i] < bb[i]) return -1;
				if (aa[i] > bb[i]) return 1;
			}
			return aa.length == bb.length ? 0 : (aa.length < bb.length ? -1 : 1);
		}
	}

	private static final class MockSet extends java.util.TreeSet {
		private java.util.List list = new java.util.ArrayList();

		public MockSet(java.util.Comparator c) { super(c); }

		public boolean add(Object k) {
			if (! contains(k)) list.add(k);
			return super.add(k);
		}

		public boolean addAll(Collection c) {
			java.util.Iterator i = c.iterator();
			boolean result = false;
			while(i.hasNext()) result |= add(i.next());
			return result;
		}

		public boolean removeAll(Collection c) {
			java.util.Iterator i = c.iterator();
			boolean result = false;
			while(i.hasNext()) result |= remove(i.next());
			return result;
		}

		public boolean remove(Object k) {
			if (contains(k)) {
				int i = list.size();
				while(i-- != 0) if (comparator().compare(list.get(i), k) == 0) {
					list.remove(i);
					break;
				}
			}
			return super.remove(k);
		}

		private void justRemove(Object k) { super.remove(k); }

		public java.util.Iterator iterator() {
			return new java.util.Iterator() {
					final java.util.Iterator iterator = list.iterator();
					Object curr;
					public Object next() { return curr = iterator.next(); }
					public boolean hasNext() { return iterator.hasNext(); }
					public void remove() {
						justRemove(curr);
						iterator.remove();
					}
				};
		}
	}

	private static java.text.NumberFormat format = new java.text.DecimalFormat("#,###.00");
	private static java.text.FieldPosition fp = new java.text.FieldPosition(0);

	private static String format(double d) {
		StringBuffer s = new StringBuffer();
		return format.format(d, s, fp).toString();
	}

	private static final int WARMUP_CYCLES = 12;
	private static final int NUM_RUNS = 50;
	private static final int GC_EVERY = 5;

	private static void speedTest(int n, float f, boolean comp) {
#ifndef Custom
		int i, j;
		OPEN_HASH_SET m;
#ifdef Linked
		java.util.LinkedHashSet t;
#else
		java.util.HashSet t;
#endif

		KEY_TYPE k[] = new KEY_TYPE[n];
		KEY_TYPE nk[] = new KEY_TYPE[n];
		long ns;

		for(i = 0; i < n; i++) {
			k[i] = genKey();
			nk[i] = genKey();
		}

		double totAdd = 0, totYes = 0, totNo = 0, totIter = 0, totRemYes = 0, totRemNo = 0, toStreamSum = 0, d;

		if (comp) { for(j = 0; j < NUM_RUNS; j++) {

			if ((j + 1) % GC_EVERY == 0) System.gc();

#ifdef Linked
			t = new java.util.LinkedHashSet(16);
#else
			t = new java.util.HashSet(16);
#endif

			/* We add pairs to t. */
			ns = System.nanoTime();
			for(i = 0; i < n;  i++) t.add(KEY2OBJ(k[i]));
			d = (System.nanoTime() - ns) / (double)n;
			if (j >= WARMUP_CYCLES) totAdd += d;
			System.out.print("Add: " + format(d) + "ns ");

			/* We check for pairs in t. */
			ns = System.nanoTime();
			for(i = 0; i < n;  i++) t.contains(KEY2OBJ(k[i]));
			d = (System.nanoTime() - ns) / (double)n;
			if (j >= WARMUP_CYCLES) totYes += d;
			System.out.print("Yes: " + format(d) + "ns ");

			/* We check for pairs not in t. */
			ns = System.nanoTime();
			for(i = 0; i < n;  i++) t.contains(KEY2OBJ(nk[i]));
			d = (System.nanoTime() - ns) / (double)n;
			if (j >= WARMUP_CYCLES) totNo += d;
			System.out.print("No: " + format(d) + "ns ");

			/* We iterate on t. */
			ns = System.nanoTime();
			for(java.util.Iterator it = t.iterator(); it.hasNext(); it.next());
			d = (System.nanoTime() - ns) / (double)n;
			if (j >= WARMUP_CYCLES) totIter += d;
			System.out.print("Iter: " + format(d) + "ns ");

#if KEYS_PRIMITIVE && ! KEY_CLASS_Boolean
			/* We sum on t. */
			ns = System.nanoTime();
#if KEYS_BYTE_CHAR_SHORT_FLOAT
			// Since the primitive stream has to upcast to a widened primitive, for fairness we will upcast here too
#endif
#if KEY_CLASS_Character
			((java.util.Set<KEY_CLASS>)t).stream().MAP_TO_KEY_WIDENED(Character::charValue).sum();
#else
			((java.util.Set<KEY_CLASS>)t).stream().MAP_TO_KEY_WIDENED(KEY_CLASS::KEY_WIDENED_VALUE).sum();
#endif
			d = (System.nanoTime() - ns) / (double)n;
			if (j >= WARMUP_CYCLES) toStreamSum += d;
			System.out.print("Stream sum: " + format(d) + "ns ");
#endif

			// Too expensive in the linked case
#ifndef Linked
			/* We delete pairs not in t. */
			ns = System.nanoTime();
			for(i = 0; i < n;  i++) t.remove(KEY2OBJ(nk[i]));
			d = (System.nanoTime() - ns) / (double)n;
			if (j >= WARMUP_CYCLES) totRemNo += d;
			System.out.print("RemNo: " + format(d) + "ns ");

			/* We delete pairs in t. */
			ns = System.nanoTime();
			for(i = 0; i < n;  i++) t.remove(KEY2OBJ(k[i]));
			d = (System.nanoTime() - ns) / (double)n;
			if (j >= WARMUP_CYCLES) totRemYes += d;
			System.out.print("RemYes: " + format(d) + "ns ");
#endif

			System.out.println();
		}

		System.out.println();
		System.out.println("java.util Add: " + format(totAdd/(j-WARMUP_CYCLES)) + "ns Yes: " + format(totYes/(j-WARMUP_CYCLES)) + "ns No: " + format(totNo/(j-WARMUP_CYCLES)) + "ns Iter: " + format(totIter/(j-WARMUP_CYCLES)) + "ns StreamSum: " + format(toStreamSum/(j-WARMUP_CYCLES)) + "ns RemNo: " + format(totRemNo/(j-WARMUP_CYCLES)) + "ns RemYes: " + format(totRemYes/(j-WARMUP_CYCLES)) + "ns");

		System.out.println();

		totAdd = totYes = totNo = totIter = totRemYes = totRemNo = toStreamSum = 0;
		}

		for(j = 0; j < NUM_RUNS; j++) {

			if ((j + 1) % GC_EVERY == 0) System.gc();

			m = new OPEN_HASH_SET(16, f);

			/* We add pairs to m. */
			ns = System.nanoTime();
			for(i = 0; i < n;  i++) m.add(k[i]);
			d = (System.nanoTime() - ns) / (double)n;
			if (j >= WARMUP_CYCLES) totAdd += d;
			System.out.print("Add: " + format(d) + "ns ");

			/* We check for pairs in m. */
			ns = System.nanoTime();
			for(i = 0; i < n;  i++) m.contains(k[i]);
			d = (System.nanoTime() - ns) / (double)n;
			if (j >= WARMUP_CYCLES) totYes += d;
			System.out.print("Yes: " + format(d) + "ns ");

			/* We check for pairs not in m. */
			ns = System.nanoTime();
			for(i = 0; i < n;  i++) m.contains(nk[i]);
			d = (System.nanoTime() - ns) / (double)n;
			if (j >= WARMUP_CYCLES) totNo += d;
			System.out.print("No: " + format(d) + "ns ");

			/* We iterate on m. */
			ns = System.nanoTime();
			for(KEY_ITERATOR it = (KEY_ITERATOR)m.iterator(); it.hasNext(); it.NEXT_KEY());
			d = (System.nanoTime() - ns) / (double)n;
			if (j >= WARMUP_CYCLES) totIter += d;
			System.out.print("Iter: " + format(d) + "ns ");

#if KEYS_PRIMITIVE && ! KEY_CLASS_Boolean
			/* We sum on t. */
			ns = System.nanoTime();
			m.KEY_WIDENED_STREAM_METHOD().sum();
			d = (System.nanoTime() - ns) / (double)n;
			if (j >= WARMUP_CYCLES) toStreamSum += d;
			System.out.print("Stream sum: " + format(d) + "ns ");
#endif

			// Too expensive in the linked case
#ifndef Linked
			/* We delete pairs not in m. */
			ns = System.nanoTime();
			for(i = 0; i < n;  i++) m.remove(nk[i]);
			d = (System.nanoTime() - ns) / (double)n;
			if (j >= WARMUP_CYCLES) totRemNo += d;
			System.out.print("RemNo: " + format(d) + "ns ");

			/* We delete pairs in m. */
			ns = System.nanoTime();
			for(i = 0; i < n;  i++) m.remove(k[i]);
			d = (System.nanoTime() - ns) / (double)n;
			if (j >= WARMUP_CYCLES) totRemYes += d;
			System.out.print("RemYes: " + format(d) + "ns ");
#endif

			System.out.println();
		}


		System.out.println();
		System.out.println("fastutil Add: " + format(totAdd/(j-WARMUP_CYCLES)) + "ns Yes: " + format(totYes/(j-WARMUP_CYCLES)) + "ns No: " + format(totNo/(j-WARMUP_CYCLES)) + "ns Iter: " + format(totIter/(j-WARMUP_CYCLES)) + "ns StreamSum: " + format(toStreamSum/(j-WARMUP_CYCLES)) + "ns RemNo: " + format(totRemNo/(j-WARMUP_CYCLES)) + "ns RemYes: " + format(totRemYes/(j-WARMUP_CYCLES)) + "ns");

		System.out.println();
#endif
	}


	private static void fatal(String msg) {
		throw new AssertionError(msg);
	}

	private static void ensure(boolean cond, String msg) {
		if (cond) return;
		fatal(msg);
	}


	private static void printProbes(OPEN_HASH_SET m) {
		long totProbes = 0;
		double totSquareProbes = 0;
		int maxProbes = 0;
		final double f = (double)m.size / m.n;
		for(int i = 0, c = 0; i < m.n; i++) {
			if (! KEY_IS_NULL(m.key[i])) c++;
			else {
				if (c != 0) {
					final long p = (c + 1) * (c + 2) / 2;
					totProbes += p;
					totSquareProbes += (double)p * p;
				}
				maxProbes = Math.max(c, maxProbes);
				c = 0;
				totProbes++;
				totSquareProbes++;
			}
		}

		final double expected = (double)totProbes / m.n;
		System.err.println("Expected probes: " + (
			3 * Math.sqrt(3) * (f / ((1 - f) * (1 - f))) + 4 / (9 * f) - 1
		) + "; actual: " + expected + "; stddev: " + Math.sqrt(totSquareProbes / m.n - expected * expected)  + "; max probes: " + maxProbes);
	}


	private static void runTest(int n, float f) throws Exception {
#if !defined(Custom) || KEYS_REFERENCE

		int c;
#ifdef Custom
		OPEN_HASH_SET m = new OPEN_HASH_SET(Hash.DEFAULT_INITIAL_SIZE, f, it.unimi.dsi.fastutil.bytes.ByteArrays.HASH_STRATEGY);
#else
		OPEN_HASH_SET m = new OPEN_HASH_SET(Hash.DEFAULT_INITIAL_SIZE, f);
#endif
#ifdef Linked
#ifdef Custom
		java.util.Set t = new MockSet(new ArrayComparator());
#else
		java.util.Set t = new java.util.LinkedHashSet();
#endif
#else
#ifdef Custom
		java.util.Set t = new java.util.TreeSet(new ArrayComparator());
#else
		java.util.Set t = new java.util.HashSet();
#endif
#endif

		/* First of all, we fill t with random data. */

		for(int i=0; i<f * n;  i++) t.add(KEY2OBJ(genKey()));

		/* Now we add to m the same data */

		m.addAll(t);

		ensure(m.equals(t), "Error (" + seed + "): !m.equals(t) after insertion");;
		ensure(t.equals(m), "Error (" + seed + "): !t.equals(m) after insertion");;
		printProbes(m);

		/* Now we check that m actually holds that data. */

		for(java.util.Iterator i=t.iterator(); i.hasNext();) {
			Object e = i.next();
			ensure(m.contains(e), "Error (" + seed + "): m and t differ on a key ("+e+") after insertion (iterating on t)");
		}

		/* Now we check that m actually holds that data, but iterating on m. */

		c = 0;
		for(java.util.Iterator i=m.iterator(); i.hasNext();) {
			Object e = i.next();
			c++;
			ensure(t.contains(e), "Error (" + seed + "): m and t differ on a key ("+e+") after insertion (iterating on m)");
		}

		ensure(c == t.size(), "Error (" + seed + "): m has only " + c + " keys instead of " + t.size() + " after insertion (iterating on m)");
		/* Now we check that inquiries about random data give the same answer in m and t. For
		 * m we use the polymorphic method. */

		for(int i=0; i<n;  i++) {
			KEY_TYPE T = genKey();
			ensure(m.contains(T) == t.contains(KEY2OBJ(T)), "Error (" + seed + "): divergence in keys between t and m (polymorphic method)");
		}

		/* Again, we check that inquiries about random data give the same answer in m and t, but
		 * for m we use the standard method. */

		for(int i=0; i<n;  i++) {
			KEY_TYPE T = genKey();
			ensure(m.contains(KEY2OBJ(T)) == t.contains(KEY2OBJ(T)), "Error (" + seed + "): divergence between t and m (standard method)");
		}


		/* Now we put and remove random data in m and t, checking that the result is the same. */

		for(int i=0; i<20*n;  i++) {
			KEY_TYPE T = genKey();
			ensure(m.add(KEY2OBJ(T)) == t.add(KEY2OBJ(T)), "Error (" + seed + "): divergence in add() between t and m");
			T = genKey();
			ensure(m.remove(KEY2OBJ(T)) == t.remove(KEY2OBJ(T)), "Error (" + seed + "): divergence in remove() between t and m");
		}

		ensure(m.equals(t), "Error (" + seed + "): !m.equals(t) after removal");;
		ensure(t.equals(m), "Error (" + seed + "): !t.equals(m) after removal");;

		/* Now we check that m actually holds that data. */

		for(java.util.Iterator i=t.iterator(); i.hasNext();) {
			Object e = i.next();
			ensure(m.contains(e), "Error (" + seed + "): m and t differ on a key ("+e+") after removal (iterating on t)");
		}

		/* Now we check that m actually holds that data, but iterating on m. */

		for(java.util.Iterator i=m.iterator(); i.hasNext();) {
			Object e = i.next();
			ensure(t.contains(e), "Error (" + seed + "): m and t differ on a key ("+e+") after removal (iterating on m)");
		}

		printProbes(m);

		/* Now we make m into an array, make it again a set and check it is OK. */
		KEY_TYPE a[] = m.TO_KEY_ARRAY();

#ifdef Custom
		ensure(new OPEN_HASH_SET(a, m.strategy()).equals(m), "Error (" + seed + "): toArray() output (or array-based constructor) is not OK");
#else
		ensure(new OPEN_HASH_SET(a).equals(m), "Error (" + seed + "): toArray() output (or array-based constructor) is not OK");
#endif

		/* Now we check cloning. */

		ensure(m.equals(((OPEN_HASH_SET)m).clone()), "Error (" + seed + "): m does not equal m.clone()");
		ensure(((OPEN_HASH_SET)m).clone().equals(m), "Error (" + seed + "): m.clone() does not equal m");

		/* Now test that the sets hold the same data using streams */
		{
#if KEYS_REFERENCE
			java.util.stream.Stream<KEY_TYPE> i = m.stream();
			java.util.stream.Stream<KEY_TYPE> j = t.stream();
#elif KEY_CLASS_Boolean
			java.util.stream.Stream<KEY_CLASS> i = m.stream();
			java.util.stream.Stream<KEY_CLASS> j = t.stream();
#else
			JDK_PRIMITIVE_STREAM i = m.KEY_WIDENED_STREAM_METHOD();
			java.util.stream.Stream<KEY_CLASS> j = t.stream();
#endif

#if (!defined Linked || defined Custom) && KEYS_REFERENCE
			// There is no good way to order arbitrary, non-Comparable objects in a consistent way.
			// Ordering by Object.hashCode is tempting, but can conflict (two difference objects can have the same hashCode)
			// Thus, we will dump into a JDK set, whose equals method will make sure they have the same in any order.
			java.util.Set iSet = i.collect(java.util.stream.Collectors.toSet());
			java.util.Set jSet = j.collect(java.util.stream.Collectors.toSet());
			ensure(iSet.equals(jSet), "! same contents in stream");
#else
#if !defined Linked && !KEYS_REFERENCE
			// Impose ordering to make arrays consistent even though backing data is not ordered.
			i = i.sorted();
			j = j.sorted();
#endif
#if KEYS_REFERENCE || KEY_CLASS_Boolean
			Object[] iArray = i.toArray();
			Object[] jArray = j.toArray();
#elif KEY_CLASS_Character
			int[] iArray = i.toArray();
			int[] jArray = j.mapToInt(Character::charValue).toArray();
#else
			KEY_TYPE_WIDENED[] iArray = i.toArray();
			KEY_TYPE_WIDENED[] jArray = j.MAP_TO_KEY_WIDENED(Number::KEY_WIDENED_VALUE).toArray();
#endif
			ensure(java.util.Arrays.equals(iArray, jArray), "! sorted arrays equal");
#endif
		}

		int h = m.hashCode();

		/* Now we save and read m. */

		{
			java.io.File ff = new java.io.File("it.unimi.dsi.fastutil.test." + m.getClass().getSimpleName() + "." + n);
			java.io.OutputStream os = new java.io.FileOutputStream(ff);
			java.io.ObjectOutputStream oos = new java.io.ObjectOutputStream(os);

			oos.writeObject(m);
			oos.close();

			java.io.InputStream is = new java.io.FileInputStream(ff);
			java.io.ObjectInputStream ois = new java.io.ObjectInputStream(is);

			m = (OPEN_HASH_SET)ois.readObject();
			ois.close();
			ff.delete();
		}

#if !KEYS_USE_REFERENCE_EQUALITY
		ensure(m.hashCode() == h, "Error (" + seed + "): hashCode() changed after save/read");;

		printProbes(m);

		/* Now we check that m actually holds that data, but iterating on m. */

		for(java.util.Iterator i=m.iterator(); i.hasNext();) {
			Object e = i.next();
			ensure(t.contains(e), "Error (" + seed + "): m and t differ on a key ("+e+") after save/read");
		}
#else
		m.clear();
		m.addAll(t);
#endif

		/* Now we put and remove random data in m and t, checking that the result is the same. */

		for(int i=0; i<20*n;  i++) {
			KEY_TYPE T = genKey();
			ensure(m.add(KEY2OBJ(T)) == t.add(KEY2OBJ(T)), "Error (" + seed + "): divergence in add() between t and m after save/read");
			T = genKey();
			ensure(m.remove(KEY2OBJ(T)) == t.remove(KEY2OBJ(T)), "Error (" + seed + "): divergence in remove() between t and m after save/read");
		}

		ensure(m.equals(t), "Error (" + seed + "): !m.equals(t) after post-save/read removal");;
		ensure(t.equals(m), "Error (" + seed + "): !t.equals(m) after post-save/read removal");;


#ifdef Linked


		/* Now we play with iterators, but only in the linked case. */

		{
			java.util.ListIterator i, j;
			Object I, J;
			i = (java.util.ListIterator)m.iterator();
			j = new java.util.LinkedList(t).listIterator();

			for(int k = 0; k < 2*n; k++) {
				ensure(i.hasNext() == j.hasNext(), "Error (" + seed + "): divergence in hasNext()");
				ensure(i.hasPrevious() == j.hasPrevious(), "Error (" + seed + "): divergence in hasPrevious()");

				if (r.nextFloat() < .8 && i.hasNext()) {
#ifdef Custom
					ensure(m.strategy().equals(i.next(), J = j.next()), "Error (" + seed + "): divergence in next()");
#else
					ensure(i.next().equals(J = j.next()), "Error (" + seed + "): divergence in next()");
#endif
					if (r.nextFloat() < 0.5) {
						i.remove();
						j.remove();
						t.remove(J);
					}
				}
				else if (r.nextFloat() < .2 && i.hasPrevious()) {
#ifdef Custom
					ensure(m.strategy().equals(i.previous(), J = j.previous()), "Error (" + seed + "): divergence in previous()");
#else
					ensure(i.previous().equals(J = j.previous()), "Error (" + seed + "): divergence in previous()");
#endif
					if (r.nextFloat() < 0.5) {
						i.remove();
						j.remove();
						t.remove(J);
					}
				}

				ensure(i.nextIndex() == j.nextIndex(), "Error (" + seed + "): divergence in nextIndex()");
				ensure(i.previousIndex() == j.previousIndex(), "Error (" + seed + "): divergence in previousIndex()");

			}

		}

		if (t.size() > 0) {
			java.util.ListIterator i, j;
			Object J;
			j = new java.util.LinkedList(t).listIterator();
			int e = r.nextInt(t.size());
			Object from;
			do from = j.next(); while(e-- != 0);

			i = (java.util.ListIterator)m.iterator(KEY_OBJ2TYPE(from));

			for(int k = 0; k < 2*n; k++) {
				ensure(i.hasNext() == j.hasNext(), "Error (" + seed + "): divergence in hasNext() (iterator with starting point " + from + ")");
				ensure(i.hasPrevious() == j.hasPrevious(), "Error (" + seed + "): divergence in hasPrevious() (iterator with starting point " + from + ")");

				if (r.nextFloat() < .8 && i.hasNext()) {
#ifdef Custom
					ensure(m.strategy().equals(i.next(), J = j.next()), "Error (" + seed + "): divergence in next() (iterator with starting point " + from + ")");
#else
					ensure(i.next().equals(J = j.next()), "Error (" + seed + "): divergence in next() (iterator with starting point " + from + ")");
#endif

					if (r.nextFloat() < 0.5) {
						i.remove();
						j.remove();
						t.remove(J);
					}
				}
				else if (r.nextFloat() < .2 && i.hasPrevious()) {
#ifdef Custom
					ensure(m.strategy().equals(i.previous(), J = j.previous()), "Error (" + seed + "): divergence in previous() (iterator with starting point " + from + ")");
#else
					ensure(i.previous().equals(J = j.previous()), "Error (" + seed + "): divergence in previous() (iterator with starting point " + from + ")");
#endif

					if (r.nextFloat() < 0.5) {
						i.remove();
						j.remove();
						t.remove(J);
					}
				}

				ensure(i.nextIndex() == j.nextIndex(), "Error (" + seed + "): divergence in nextIndex() (iterator with starting point " + from + ")");
				ensure(i.previousIndex() == j.previousIndex(), "Error (" + seed + "): divergence in previousIndex() (iterator with starting point " + from + ")");

			}

		}

		/* Now we check that m actually holds that data. */

		ensure(m.equals(t), "Error (" + seed + "): ! m.equals(t) after iteration");
		ensure(t.equals(m), "Error (" + seed + "): ! t.equals(m) after iteration");



#endif

		/* Now we take out of m everything, and check that it is empty. */

		for(java.util.Iterator i=m.iterator(); i.hasNext();) { i.next(); i.remove();}

		ensure(m.isEmpty(), "Error (" + seed + "): m is not empty (as it should be)");

#if KEY_CLASS_Integer || KEY_CLASS_Long
		m = new OPEN_HASH_SET(n, f);
		t.clear();
		int x;

		/* Now we torture-test the hash table. This part is implemented only for integers and longs. */

		int p = m.key.length - 1;

		for(int i=0; i<p; i++) {
			for (int j=0; j<20; j++) {
				m.add(i+(r.nextInt() % 10)*p);
				m.remove(i+(r.nextInt() % 10)*p);
			}

			for (int j=-10; j<10; j++) m.remove(i+j*p);
		}

		t.addAll(m);

		/* Now all table entries are REMOVED. */

		int k = 0;
		for(int i=0; i<(p*f)/10; i++) {
			for (int j=0; j<10; j++) {
				k++;
				x = i+(r.nextInt() % 10)*p;
				ensure(m.add(x) == t.add(KEY2OBJ(x)), "Error (" + seed + "): m and t differ on a key during torture-test insertion.");
			}
		}

		ensure(m.equals(t), "Error (" + seed + "): !m.equals(t) after torture-test insertion");;
		ensure(t.equals(m), "Error (" + seed + "): !t.equals(m) after torture-test insertion");;

		for(int i=0; i<(p*f)/10; i++) {
			for (int j=0; j<10; j++) {
				x = i+(r.nextInt() % 10)*p;
				ensure(m.remove(x) == t.remove(KEY2OBJ(x)), "Error (" + seed + "): m and t differ on a key during torture-test removal.");
			}
		}

		ensure(m.equals(t), "Error (" + seed + "): !m.equals(t) after torture-test removal");;
		ensure(t.equals(m), "Error (" + seed + "): !t.equals(m) after torture-test removal");;

		ensure(m.equals(m.clone()), "Error (" + seed + "): !m.equals(m.clone()) after torture-test removal");;
		ensure(((OPEN_HASH_SET)m.clone()).equals(m), "Error (" + seed + "): !m.clone().equals(m) after torture-test removal");;

		m.trim();

		ensure(m.equals(t), "Error (" + seed + "): !m.equals(t) after trim()");;
		ensure(t.equals(m), "Error (" + seed + "): !t.equals(m) after trim()");;
#endif

		System.out.println("Test OK");
		return;
#endif
	}


	public static void main(String args[]) throws Exception {
		float f = Hash.DEFAULT_LOAD_FACTOR;
		int n  = Integer.parseInt(args[1]);
		if (args.length>2) f = Float.parseFloat(args[2]);
		if (args.length > 3) r = new java.util.Random(seed = Long.parseLong(args[3]));

		try {
			if ("speedTest".equals(args[0]) || "speedComp".equals(args[0])) speedTest(n, f, "speedComp".equals(args[0]));
			else if ("test".equals(args[0])) runTest(n, f);
		} catch(Throwable e) {
			e.printStackTrace(System.err);
			System.err.println("seed: " + seed);
			throw e;
		}
	}

#endif

}
