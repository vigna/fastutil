/*
 * Copyright (C) 2002-2024 Sebastiano Vigna
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package PACKAGE;

import it.unimi.dsi.fastutil.BigList;
import it.unimi.dsi.fastutil.BigArrays;
import java.util.Collection;
import java.util.List;
import java.util.Random;

/** A class providing static methods and objects that do useful things with type-specific big lists.
 *
 * @see java.util.Collections
 * @see it.unimi.dsi.fastutil.BigList
 */

public final class BIG_LISTS {

	private BIG_LISTS() {}

	/** Shuffles the specified big list using the specified pseudorandom number generator.
	 *
	 * @param l the big list to be shuffled.
	 * @param random a pseudorandom number generator.
	 * @return {@code l}.
	 */
	public static KEY_GENERIC BIG_LIST KEY_GENERIC shuffle(final BIG_LIST KEY_GENERIC l, final Random random) {
		for(long i = l.size64(); i-- != 0;) {
			final long p = (random.nextLong() & 0x7FFFFFFFFFFFFFFFL) % (i + 1);
			final KEY_GENERIC_TYPE t = l.GET_KEY(i);
			l.set(i, l.GET_KEY(p));
			l.set(p, t);
		}
		return l;
	}


	/** An immutable class representing an empty type-specific big list.
	 *
	 * <p>This class may be useful to implement your own in case you subclass
	 * a type-specific list.
	 */

	public static class EmptyBigList KEY_GENERIC extends COLLECTIONS.EmptyCollection KEY_GENERIC implements BIG_LIST KEY_GENERIC, java.io.Serializable, Cloneable {

		private static final long serialVersionUID = -7046029254386353129L;

		protected EmptyBigList() {}

		@Override
		public KEY_GENERIC_TYPE GET_KEY(long i) { throw new IndexOutOfBoundsException(); }

		@Override
		public boolean REMOVE(KEY_TYPE k) { throw new UnsupportedOperationException(); }

		@Override
		public KEY_GENERIC_TYPE REMOVE_KEY(long i) { throw new UnsupportedOperationException(); }

		@Override
		public void add(final long index, final KEY_GENERIC_TYPE k) { throw new UnsupportedOperationException(); }

		@Override
		public KEY_GENERIC_TYPE set(final long index, final KEY_GENERIC_TYPE k) { throw new UnsupportedOperationException(); }

		@Override
		public long indexOf(KEY_TYPE k) { return -1; }

		@Override
		public long lastIndexOf(KEY_TYPE k) { return -1; }

		@Override
		public boolean addAll(long i, Collection<? extends KEY_GENERIC_CLASS> c) { throw new UnsupportedOperationException(); }

#if KEYS_PRIMITIVE
		@Override
		public boolean addAll(COLLECTION c) { throw new UnsupportedOperationException(); }

		@Override
		public boolean addAll(BIG_LIST c) { throw new UnsupportedOperationException(); }

		@Override
		public boolean addAll(long i, COLLECTION c) { throw new UnsupportedOperationException(); }

		@Override
		public boolean addAll(long i, BIG_LIST c) { throw new UnsupportedOperationException(); }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public void add(final long index, final KEY_GENERIC_CLASS k) { throw new UnsupportedOperationException(); }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public boolean add(final KEY_GENERIC_CLASS k) { throw new UnsupportedOperationException(); }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public KEY_GENERIC_CLASS get(long i) { throw new IndexOutOfBoundsException(); }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public KEY_GENERIC_CLASS set(final long index, final KEY_GENERIC_CLASS k) { throw new UnsupportedOperationException(); }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public KEY_GENERIC_CLASS remove(long k) { throw new UnsupportedOperationException(); }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public long indexOf(Object k) { return -1; }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public long lastIndexOf(Object k) { return -1; }
#endif

		@Override
		SUPPRESS_WARNINGS_KEY_UNCHECKED
		public KEY_BIG_LIST_ITERATOR KEY_GENERIC listIterator() { return BIG_LIST_ITERATORS.EMPTY_BIG_LIST_ITERATOR; }

		@Override
		SUPPRESS_WARNINGS_KEY_UNCHECKED
		public KEY_BIG_LIST_ITERATOR KEY_GENERIC iterator() { return BIG_LIST_ITERATORS.EMPTY_BIG_LIST_ITERATOR; }

		@Override
		SUPPRESS_WARNINGS_KEY_UNCHECKED
		public KEY_BIG_LIST_ITERATOR KEY_GENERIC listIterator(long i) { if (i == 0) return BIG_LIST_ITERATORS.EMPTY_BIG_LIST_ITERATOR; throw new IndexOutOfBoundsException(String.valueOf(i)); }

		@Override
		SUPPRESS_WARNINGS_KEY_UNCHECKED
		public KEY_SPLITERATOR KEY_GENERIC spliterator() { return SPLITERATORS.EMPTY_SPLITERATOR; }

		@Override
		public BIG_LIST KEY_GENERIC subList(long from, long to) { if (from == 0 && to == 0) return this; throw new IndexOutOfBoundsException(); }

		@Override
		public void getElements(long from, KEY_TYPE[][] a, long offset, long length) { BigArrays.ensureOffsetLength(a, offset, length); if (from != 0) throw new IndexOutOfBoundsException(); }

		@Override
		public void removeElements(long from, long to) { throw new UnsupportedOperationException(); }

		@Override
		public void addElements(long index, final KEY_GENERIC_TYPE a[][], long offset, long length) { throw new UnsupportedOperationException(); }

		@Override
		public void addElements(long index, final KEY_GENERIC_TYPE a[][]) { throw new UnsupportedOperationException(); }

		@Override
		public void size(long s)  { throw new UnsupportedOperationException(); }

		@Override
		public long size64() { return 0; }

#if ! KEYS_USE_REFERENCE_EQUALITY
		@Override
		public int compareTo(final BigList<? extends KEY_GENERIC_CLASS> o) {
			if (o == this) return 0;
			return ((BigList<?>)o).isEmpty() ? 0 : -1;
		}
#endif
		@Override
		public Object clone() { return EMPTY_BIG_LIST; }

		@Override
		public int hashCode() { return 1; }

		@Override
		@SuppressWarnings("rawtypes")
		public boolean equals(Object o) { return o instanceof BigList && ((BigList)o).isEmpty(); }

		@Override
		public String toString() { return "[]"; }

		private Object readResolve() { return EMPTY_BIG_LIST; }
	}

	/** An empty big list (immutable). It is serializable and cloneable.
	 */
	SUPPRESS_WARNINGS_KEY_RAWTYPES
	public static final EmptyBigList EMPTY_BIG_LIST = new EmptyBigList();

#if KEYS_REFERENCE
	/** Returns an empty big list (immutable). It is serializable and cloneable.
	 *
	 * <p>This method provides a typesafe access to {@link #EMPTY_BIG_LIST}.
	 * @return an empty big list (immutable).
	 */
	@SuppressWarnings("unchecked")
	public static KEY_GENERIC BIG_LIST KEY_GENERIC emptyList() {
		return EMPTY_BIG_LIST;
	}
#endif

	/** An immutable class representing a type-specific singleton big list.
	 *
	 * <p>This class may be useful to implement your own in case you subclass
	 * a type-specific big list.
	 */

	public static class Singleton KEY_GENERIC extends ABSTRACT_BIG_LIST KEY_GENERIC implements java.io.Serializable, Cloneable {

		private static final long serialVersionUID = -7046029254386353129L;

		private final KEY_GENERIC_TYPE element;

		protected Singleton(final KEY_GENERIC_TYPE element) { this.element = element; }

		@Override
		public KEY_GENERIC_TYPE GET_KEY(final long i) { if (i == 0) return element; throw new IndexOutOfBoundsException(); }

		@Override
		public boolean REMOVE(KEY_TYPE k) { throw new UnsupportedOperationException(); }

		@Override
		public KEY_GENERIC_TYPE REMOVE_KEY(final long i) { throw new UnsupportedOperationException(); }

		@Override
		public boolean contains(final KEY_TYPE k) { return KEY_EQUALS(k, element); }

		@Override
		public long indexOf(final KEY_TYPE k) { return KEY_EQUALS(k, element) ? 0 : -1; }

		/* Slightly optimized w.r.t. the one in ABSTRACT_SET. */

		@Override
		public KEY_TYPE[] TO_KEY_ARRAY() {
			KEY_TYPE a[] = {element};
			return a;
		}

		@Override
		public KEY_BIG_LIST_ITERATOR KEY_GENERIC listIterator() { return BIG_LIST_ITERATORS.singleton(element); }

		@Override
		public KEY_BIG_LIST_ITERATOR KEY_GENERIC listIterator(long i) {
			if (i > 1 || i < 0) throw new  IndexOutOfBoundsException();
			KEY_BIG_LIST_ITERATOR KEY_GENERIC l = listIterator();
			if (i == 1) l.NEXT_KEY();
			return l;
		}

		@Override
		public KEY_SPLITERATOR KEY_GENERIC spliterator() { return SPLITERATORS.singleton(element); }

		@Override
		SUPPRESS_WARNINGS_KEY_UNCHECKED
		public BIG_LIST KEY_GENERIC subList(final long from, final long to) {
			ensureIndex(from);
			ensureIndex(to);
			if (from > to) throw new IndexOutOfBoundsException("Start index (" + from + ") is greater than end index (" + to + ")");

			if (from != 0 || to != 1) return EMPTY_BIG_LIST;
			return this;
		}

		@Override
		public boolean addAll(long i, Collection<? extends KEY_GENERIC_CLASS> c) { throw new UnsupportedOperationException(); }

		@Override
		public boolean addAll(final Collection<? extends KEY_GENERIC_CLASS> c) { throw new UnsupportedOperationException(); }

		@Override
		public boolean removeAll(final Collection<?> c) { throw new UnsupportedOperationException(); }

		@Override
		public boolean retainAll(final Collection<?> c) { throw new UnsupportedOperationException(); }

#if KEYS_PRIMITIVE

		@Override
		public boolean addAll(BIG_LIST c) { throw new UnsupportedOperationException(); }

		@Override
		public boolean addAll(long i, BIG_LIST c) { throw new UnsupportedOperationException(); }

		@Override
		public boolean addAll(long i, COLLECTION c) { throw new UnsupportedOperationException(); }

		@Override
		public boolean addAll(final COLLECTION c) { throw new UnsupportedOperationException(); }

		@Override
		public boolean removeAll(final COLLECTION c) { throw new UnsupportedOperationException(); }

		@Override
		public boolean retainAll(final COLLECTION c) { throw new UnsupportedOperationException(); }

#endif

		@Override
		public void clear() { throw new UnsupportedOperationException(); }

		@Override
		public long size64() { return 1; }

		@Override
		public Object clone() { return this; }
	}

	/** Returns a type-specific immutable big list containing only the specified element. The returned big list is serializable and cloneable.
	 *
	 * @param element the only element of the returned big list.
	 * @return a type-specific immutable big list containing just {@code element}.
	 */

	public static KEY_GENERIC BIG_LIST KEY_GENERIC singleton(final KEY_GENERIC_TYPE element) { return new Singleton KEY_GENERIC_DIAMOND(element); }

#if KEYS_PRIMITIVE

	/** Returns a type-specific immutable big list containing only the specified element. The returned big list is serializable and cloneable.
	 *
	 * @param element the only element of the returned big list.
	 * @return a type-specific immutable big list containing just {@code element}.
	 */

	public static KEY_GENERIC BIG_LIST KEY_GENERIC singleton(final Object element) { return new Singleton KEY_GENERIC_DIAMOND(KEY_OBJ2TYPE(element)); }

#endif


	/** A synchronized wrapper class for big lists. */

	public static class SynchronizedBigList KEY_GENERIC extends COLLECTIONS.SynchronizedCollection KEY_GENERIC implements BIG_LIST KEY_GENERIC, java.io.Serializable {

		private static final long serialVersionUID = -7046029254386353129L;

		protected final BIG_LIST KEY_GENERIC list; // Due to the large number of methods that are not in COLLECTION, this is worth caching.

		protected SynchronizedBigList(final BIG_LIST KEY_GENERIC l, final Object sync) {
			super(l, sync);
			this.list = l;
		}

		protected SynchronizedBigList(final BIG_LIST KEY_GENERIC l) {
			super(l);
			this.list = l;
		}

		@Override
		public KEY_GENERIC_TYPE GET_KEY(final long i) { synchronized(sync) { return list.GET_KEY(i); } }

		@Override
		public KEY_GENERIC_TYPE set(final long i, final KEY_GENERIC_TYPE k) { synchronized(sync) { return list.set(i, k); } }

		@Override
		public void add(final long i, final KEY_GENERIC_TYPE k) { synchronized(sync) { list.add(i, k); } }

		@Override
		public KEY_GENERIC_TYPE REMOVE_KEY(final long i) { synchronized(sync) { return list.REMOVE_KEY(i); } }

		@Override
		public long indexOf(final KEY_TYPE k) { synchronized(sync) { return list.indexOf(k); } }

		@Override
		public long lastIndexOf(final KEY_TYPE k) { synchronized(sync) { return list.lastIndexOf(k); } }

		@Override
		public boolean addAll(final long index, final Collection<? extends KEY_GENERIC_CLASS> c) { synchronized(sync) { return list.addAll(index, c); } }

		@Override
		public void getElements(final long from, final KEY_TYPE a[][], final long offset, final long length) { synchronized(sync) { list.getElements(from, a, offset, length); } }

		@Override
		public void removeElements(final long from, final long to) { synchronized(sync) { list.removeElements(from, to); } }

		@Override
		public void addElements(long index, final KEY_GENERIC_TYPE a[][], long offset, long length) { synchronized(sync) { list.addElements(index, a, offset, length); } }

		@Override
		public void addElements(long index, final KEY_GENERIC_TYPE a[][]) { synchronized(sync) { list.addElements(index, a); } }

		/* {@inheritDoc}
		 * @deprecated Use {@link #size64()} instead.
		 */
		@Deprecated
		@Override
		public void size(final long size) { synchronized(sync) { list.size(size); } }

		@Override
		public long size64() { synchronized(sync) { return list.size64(); } }

		@Override
		public KEY_BIG_LIST_ITERATOR KEY_GENERIC iterator() { return list.listIterator(); }

		@Override
		public KEY_BIG_LIST_ITERATOR KEY_GENERIC listIterator() { return list.listIterator(); }

		@Override
		public KEY_BIG_LIST_ITERATOR KEY_GENERIC listIterator(final long i) { return list.listIterator(i); }

		@Override
		public BIG_LIST KEY_GENERIC subList(final long from, final long to) { synchronized(sync) { return synchronize(list.subList(from, to), sync); } }

		@Override
		public boolean equals(final Object o) { if (o == this) return true; synchronized(sync) { return list.equals(o); } }

		@Override
		public int hashCode() { synchronized(sync) { return list.hashCode(); } }

#if ! KEYS_USE_REFERENCE_EQUALITY
		@Override
		public int compareTo(final BigList<? extends KEY_GENERIC_CLASS> o) { synchronized(sync) { return list.compareTo(o); } }
#endif

#if KEYS_PRIMITIVE
		@Override
		public boolean addAll(final long index, final COLLECTION c) { synchronized(sync) { return list.addAll(index, c); } }

		@Override
		public boolean addAll(final long index, BIG_LIST l) { synchronized(sync) { return list.addAll(index, l); } }

		@Override
		public boolean addAll(BIG_LIST l) { synchronized(sync) { return list.addAll(l); } }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public void add(final long i, KEY_GENERIC_CLASS k) { synchronized(sync) { list.add(i, k); } }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public KEY_GENERIC_CLASS get(final long i) { synchronized(sync) { return list.get(i); } }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public KEY_GENERIC_CLASS set(final long index, KEY_GENERIC_CLASS k) { synchronized(sync) { return list.set(index, k); } }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public KEY_GENERIC_CLASS remove(final long i) { synchronized(sync) { return list.remove(i); } }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public long indexOf(final Object o) { synchronized(sync) { return list.indexOf(o); } }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public long lastIndexOf(final Object o) { synchronized(sync) { return list.lastIndexOf(o); } }
#endif
	}


	/** Returns a synchronized type-specific big list backed by the given type-specific big list.
	 *
	 * @param l the big list to be wrapped in a synchronized big list.
	 * @return a synchronized view of the specified big list.
	 * @see java.util.Collections#synchronizedList(List)
	 */
	public static KEY_GENERIC BIG_LIST KEY_GENERIC synchronize(final BIG_LIST KEY_GENERIC l) { return new SynchronizedBigList KEY_GENERIC_DIAMOND(l); }

	/** Returns a synchronized type-specific big list backed by the given type-specific big list, using an assigned object to synchronize.
	 *
	 * @param l the big list to be wrapped in a synchronized big list.
	 * @param sync an object that will be used to synchronize the access to the big list.
	 * @return a synchronized view of the specified big list.
	 * @see java.util.Collections#synchronizedList(List)
	 */

	public static KEY_GENERIC BIG_LIST KEY_GENERIC synchronize(final BIG_LIST KEY_GENERIC l, final Object sync) { return new SynchronizedBigList KEY_GENERIC_DIAMOND(l, sync); }



	/** An unmodifiable wrapper class for big lists. */

	public static class UnmodifiableBigList KEY_GENERIC extends COLLECTIONS.UnmodifiableCollection KEY_GENERIC implements BIG_LIST KEY_GENERIC, java.io.Serializable {

		private static final long serialVersionUID = -7046029254386353129L;

		protected final BIG_LIST KEY_EXTENDS_GENERIC list; // Due to the large number of methods that are not in COLLECTION, this is worth caching.

		protected UnmodifiableBigList(final BIG_LIST KEY_EXTENDS_GENERIC l) {
			super(l);
			this.list = l;
		}

		@Override
		public KEY_GENERIC_TYPE GET_KEY(final long i) { return list.GET_KEY(i); }

		@Override
		public KEY_GENERIC_TYPE set(final long i, final KEY_GENERIC_TYPE k) { throw new UnsupportedOperationException(); }

		@Override
		public void add(final long i, final KEY_GENERIC_TYPE k) { throw new UnsupportedOperationException(); }

		@Override
		public KEY_GENERIC_TYPE REMOVE_KEY(final long i) { throw new UnsupportedOperationException(); }

		@Override
		public long indexOf(final KEY_TYPE k) { return list.indexOf(k); }

		@Override
		public long lastIndexOf(final KEY_TYPE k) { return list.lastIndexOf(k); }

		@Override
		public boolean addAll(final long index, final Collection<? extends KEY_GENERIC_CLASS> c) { throw new UnsupportedOperationException(); }

		@Override
		public void getElements(final long from, final KEY_TYPE a[][], final long offset, final long length) { list.getElements(from, a, offset, length); }

		@Override
		public void removeElements(final long from, final long to) { throw new UnsupportedOperationException(); }

		@Override
		public void addElements(long index, final KEY_GENERIC_TYPE a[][], long offset, long length) { throw new UnsupportedOperationException(); }

		@Override
		public void addElements(long index, final KEY_GENERIC_TYPE a[][]) { throw new UnsupportedOperationException(); }

		/* {@inheritDoc}
		 * @deprecated Use {@link #size64()} instead.
		 */
		@Deprecated
		@Override
		public void size(final long size) { list.size(size); }

		@Override
		public long size64() { return list.size64(); }

		@Override
		public KEY_BIG_LIST_ITERATOR KEY_GENERIC iterator() { return listIterator(); }

		@Override
		public KEY_BIG_LIST_ITERATOR KEY_GENERIC listIterator() { return BIG_LIST_ITERATORS.unmodifiable(list.listIterator()); }

		@Override
		public KEY_BIG_LIST_ITERATOR KEY_GENERIC listIterator(final long i) { return BIG_LIST_ITERATORS.unmodifiable(list.listIterator(i)); }

		@Override
		public BIG_LIST KEY_GENERIC subList(final long from, final long to) { return unmodifiable(list.subList(from, to)); }

		@Override
		public boolean equals(final Object o) { if (o == this) return true; return list.equals(o); }

		@Override
		public int hashCode() { return list.hashCode(); }

#if ! KEYS_USE_REFERENCE_EQUALITY
		@Override
#if KEYS_PRIMITIVE
		public int compareTo(final BigList<? extends KEY_GENERIC_CLASS> o) { return list.compareTo(o); }
#else
		@SuppressWarnings("unchecked")
		public int compareTo(final BigList<? extends KEY_GENERIC_CLASS> o) { return ((BIG_LIST KEY_GENERIC)list).compareTo(o); }
#endif
#endif

#if KEYS_PRIMITIVE
		@Override
		public boolean addAll(final long index, final COLLECTION c) { throw new UnsupportedOperationException(); }

		@Override
		public boolean addAll(final BIG_LIST l) { throw new UnsupportedOperationException(); }

		@Override
		public boolean addAll(final long index, final BIG_LIST l) { throw new UnsupportedOperationException(); }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public KEY_GENERIC_CLASS get(final long i) { return list.get(i); }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public void add(final long i, KEY_GENERIC_CLASS k) { throw new UnsupportedOperationException(); }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public KEY_GENERIC_CLASS set(final long index, KEY_GENERIC_CLASS k) { throw new UnsupportedOperationException(); }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public KEY_GENERIC_CLASS remove(final long i) { throw new UnsupportedOperationException(); }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public long indexOf(final Object o) { return list.indexOf(o); }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public long lastIndexOf(final Object o) { return list.lastIndexOf(o); }
#endif
	}


	/** Returns an unmodifiable type-specific big list backed by the given type-specific big list.
	 *
	 * @param l the big list to be wrapped in an unmodifiable big list.
	 * @return an unmodifiable view of the specified big list.
	 * @see java.util.Collections#unmodifiableList(List)
	 */
	public static KEY_GENERIC BIG_LIST KEY_GENERIC unmodifiable(final BIG_LIST KEY_EXTENDS_GENERIC l) { return new UnmodifiableBigList KEY_GENERIC_DIAMOND(l); }

	/** A class exposing a list as a big list. */

	public static class ListBigList KEY_GENERIC extends ABSTRACT_BIG_LIST KEY_GENERIC implements java.io.Serializable {

		private static final long serialVersionUID = -7046029254386353129L;

		private final LIST KEY_GENERIC list;

		protected ListBigList(final LIST KEY_GENERIC list) {
			this.list = list;
		}

		private int intIndex(long index) {
			if (index >= Integer.MAX_VALUE) throw new IndexOutOfBoundsException("This big list is restricted to 32-bit indices");
			return (int)index;
		}

		@Override
		public long size64() { return list.size(); }

		@Override
		public void size(final long size) { list.size(intIndex(size)); }

		@Override
		public KEY_BIG_LIST_ITERATOR KEY_GENERIC iterator() { return BIG_LIST_ITERATORS.asBigListIterator(list.iterator()); }

		@Override
		public KEY_BIG_LIST_ITERATOR KEY_GENERIC listIterator() { return BIG_LIST_ITERATORS.asBigListIterator(list.listIterator()); }

		@Override
		public KEY_BIG_LIST_ITERATOR KEY_GENERIC listIterator(final long index) { return BIG_LIST_ITERATORS.asBigListIterator(list.listIterator(intIndex(index))); }

		@Override
		public boolean addAll(final long index, final Collection<? extends KEY_GENERIC_CLASS> c) { return list.addAll(intIndex(index), c); }

		@Override
		public BIG_LIST KEY_GENERIC subList(long from, long to) { return new ListBigList KEY_GENERIC_DIAMOND(list.subList(intIndex(from), intIndex(to))); }

		@Override
		public boolean contains(final KEY_TYPE key) { return list.contains(key); }

		@Override
		public KEY_TYPE[] TO_KEY_ARRAY() { return list.TO_KEY_ARRAY(); }

		@Override
		public void removeElements(final long from, final long to) { list.removeElements(intIndex(from), intIndex(to)); }

#if KEYS_PRIMITIVE
		/* {@inheritDoc}
		 * @deprecated Please use {@code toArray()} instead&mdash;this method is redundant and will be removed in the future.
		 */
		@Deprecated
		@Override
		public KEY_TYPE[] TO_KEY_ARRAY(KEY_TYPE[] a) { return list.toArray(a); }

		@Override
		public boolean addAll(long index, COLLECTION KEY_GENERIC c) { return list.addAll(intIndex(index), c); }

		@Override
		public boolean addAll(COLLECTION KEY_GENERIC c) { return list.addAll(c); }

		@Override
		public boolean addAll(long index, BIG_LIST KEY_GENERIC c) { return list.addAll(intIndex(index), c); }

		@Override
		public boolean addAll(BIG_LIST KEY_GENERIC c) { return list.addAll(c); }

		@Override
		public boolean containsAll(COLLECTION KEY_GENERIC c) { return list.containsAll(c); }

		@Override
		public boolean removeAll(COLLECTION KEY_GENERIC c) { return list.removeAll(c); }

		@Override
		public boolean retainAll(COLLECTION KEY_GENERIC c) { return list.retainAll(c); }
#endif
		@Override
		public void add(long index, KEY_GENERIC_TYPE key) { list.add(intIndex(index), key); }

		@Override
		public boolean add(KEY_GENERIC_TYPE key) { return list.add(key); }

		@Override
		public KEY_GENERIC_TYPE GET_KEY(long index) { return list.GET_KEY(intIndex(index)); }

		@Override
		public long indexOf(KEY_TYPE k) { return list.indexOf(k); }

		@Override
		public long lastIndexOf(KEY_TYPE k) { return list.lastIndexOf(k); }

		@Override
		public KEY_GENERIC_TYPE REMOVE_KEY(long index) { return list.REMOVE_KEY(intIndex(index)); }

		@Override
		public KEY_GENERIC_TYPE set(long index, KEY_GENERIC_TYPE k) { return list.set(intIndex(index), k); }

		@Override
		public boolean isEmpty() { return list.isEmpty(); }

		@Override
		public <T> T[] toArray(T[] a) { return list.toArray(a); }

		@Override
		public boolean containsAll(Collection<?> c) { return list.containsAll(c); }

		@Override
		public boolean addAll(Collection<? extends KEY_GENERIC_CLASS> c) { return list.addAll(c); }

		@Override
		public boolean removeAll(Collection<?> c) { return list.removeAll(c); }

		@Override
		public boolean retainAll(Collection<?> c) { return list.retainAll(c); }

		@Override
		public void clear() { list.clear(); }

		@Override
		public int hashCode() { return list.hashCode(); }
	}

	/** Returns a big list backed by the specified list.
	*
	* @param list a list.
	* @return a big list backed by the specified list.
	*/
	public static KEY_GENERIC BIG_LIST KEY_GENERIC asBigList(final LIST KEY_GENERIC list) { return new ListBigList KEY_GENERIC_DIAMOND(list); }




#ifdef TEST

	private static KEY_TYPE genKey() {
#if KEY_CLASS_Byte || KEY_CLASS_Short || KEY_CLASS_Character
		return (KEY_TYPE)(r.nextInt());
#elif KEYS_PRIMITIVE
		return r.NEXT_KEY();
#elif KEY_CLASS_Object
		return Integer.toBinaryString(r.nextInt());
#else
		return new java.io.Serializable() {};
#endif
	}


	private static void testLists(KEY_TYPE k, BIG_LIST m, BIG_LIST t, int level) throws Exception {
		int n = 100;
		int c;

		long ms;
		boolean mThrowsIllegal, tThrowsIllegal, mThrowsNoElement, tThrowsNoElement, mThrowsIndex, tThrowsIndex, mThrowsUnsupp, tThrowsUnsupp;
		boolean rt = false, rm = false;
		Object Rt = null, Rm = null;

		if (level == 0) return;

		/* Now we check that m and t are equal. */
		if (!m.equals(t) || ! t.equals(m)) System.err.println("m: " + m + " t: " + t);

		ensure(m.equals(t), "Error (" + level + ", " + seed + "): ! m.equals(t) at start");
		ensure(t.equals(m), "Error (" + level + ", " + seed + "): ! t.equals(m) at start");

		/* Now we check that m actually holds that data. */
		for(java.util.Iterator i=t.iterator(); i.hasNext();) {
			ensure(m.contains(i.next()), "Error (" + level + ", " + seed + "): m and t differ on an entry after insertion (iterating on t)");
		}

		/* Now we check that m actually holds that data, but iterating on m. */
		for(java.util.Iterator i=m.listIterator(); i.hasNext();) {
			ensure(t.contains(i.next()), "Error (" + level + ", " + seed + "): m and t differ on an entry after insertion (iterating on m)");
		}

		/* Now we check that inquiries about random data give the same answer in m and t. For
		   m we use the polymorphic method. */

		for(int i=0; i<n;  i++) {
			KEY_TYPE T = genKey();

			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			try {
				m.contains(T);
			}
			catch (java.util.NoSuchElementException e) { mThrowsNoElement = true; }
			catch (IllegalArgumentException e) { mThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { mThrowsIndex = true; }

			try {
				t.contains(KEY2OBJ(T));
			}
			catch (java.util.NoSuchElementException e) { tThrowsNoElement = true; }
			catch (IllegalArgumentException e) { tThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { tThrowsIndex = true; }

			ensure(mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): contains() divergence in java.util.NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m);
			ensure(mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): contains() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m);
			ensure(mThrowsIndex == tThrowsIndex, "Error (" + level + ", " + seed + "): contains() divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m);
			if (!mThrowsNoElement && !mThrowsIllegal && !mThrowsIndex) ensure(m.contains(KEY2OBJ(T)) == t.contains(KEY2OBJ(T)), "Error (" + level + ", " + seed + "): divergence in keys between t and m (polymorphic method) " + m);
		}

		/* Again, we check that inquiries about random data give the same answer in m and t, but
		   for m we use the standard method. */

		for(int i=0; i<n;  i++) {
			KEY_TYPE T = genKey();

			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			try {
				m.contains(KEY2OBJ(T));
			}
			catch (java.util.NoSuchElementException e) { mThrowsNoElement = true; }
			catch (IllegalArgumentException e) { mThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { mThrowsIndex = true; }
			catch (UnsupportedOperationException e) { mThrowsUnsupp = true; }

			try {
				t.contains(KEY2OBJ(T));
			}
			catch (java.util.NoSuchElementException e) { tThrowsNoElement = true; }
			catch (IllegalArgumentException e) { tThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { tThrowsIndex = true; }
			catch (UnsupportedOperationException e) { tThrowsUnsupp = true; }

			ensure(mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): contains() divergence in java.util.NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m);
			ensure(mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): contains() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m);
			ensure(mThrowsIndex == tThrowsIndex, "Error (" + level + ", " + seed + "): contains() divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m);
			ensure(mThrowsUnsupp == tThrowsUnsupp, "Error (" + level + ", " + seed + "): contains() divergence in UnsupportedOperationException for " + T + " (" + mThrowsUnsupp + ", " + tThrowsUnsupp + ") " + m);
			if (!mThrowsNoElement && !mThrowsIllegal && !mThrowsIndex && !mThrowsUnsupp) ensure(m.contains(KEY2OBJ(T)) ==  t.contains(KEY2OBJ(T)), "Error (" + level + ", " + seed + "): divergence between t and m (standard method) " + m);
		}

		/* Now we add and remove random data in m and t, checking that the result is the same. */

		for(int i=0; i<20*n;  i++) {
			KEY_TYPE T = genKey();

			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			try {
				rm = m.add(KEY2OBJ(T));
			}
			catch (java.util.NoSuchElementException e) { mThrowsNoElement = true; }
			catch (IllegalArgumentException e) { mThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { mThrowsIndex = true; }
			catch (UnsupportedOperationException e) { mThrowsUnsupp = true; }

			try {
				rt = t.add(KEY2OBJ(T));
			}
			catch (java.util.NoSuchElementException e) { tThrowsNoElement = true; }
			catch (IllegalArgumentException e) { tThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { tThrowsIndex = true; }
			catch (UnsupportedOperationException e) { tThrowsUnsupp = true; }

			ensure(mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): add() divergence in java.util.NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m);
			ensure(mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): add() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m);
			ensure(mThrowsIndex == tThrowsIndex, "Error (" + level + ", " + seed + "): add() divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m);
			ensure(mThrowsUnsupp == tThrowsUnsupp, "Error (" + level + ", " + seed + "): add() divergence in UnsupportedOperationException for " + T + " (" + mThrowsUnsupp + ", " + tThrowsUnsupp + ") " + m);
			if (!mThrowsNoElement && !mThrowsIllegal && !mThrowsIndex && !mThrowsUnsupp) ensure(rm == rt, "Error (" + level + ", " + seed + "): divergence in add() between t and m " + m);

			T = genKey();

			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			try {
				rm = m.remove(KEY2OBJ(T));
			}
			catch (java.util.NoSuchElementException e) { mThrowsNoElement = true; }
			catch (IllegalArgumentException e) { mThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { mThrowsIndex = true; }
			catch (UnsupportedOperationException e) { mThrowsUnsupp = true; }

			try {
				rt = t.remove(KEY2OBJ(T));
			}
			catch (java.util.NoSuchElementException e) { tThrowsNoElement = true; }
			catch (IllegalArgumentException e) { tThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { tThrowsIndex = true; }
			catch (UnsupportedOperationException e) { tThrowsUnsupp = true; }

			if (! KEY_EQUALS(T, k) && mThrowsUnsupp && ! tThrowsUnsupp) mThrowsUnsupp = true; // Stupid bug in Collections.singleton()

			ensure(mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): remove() divergence in java.util.NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m);
			ensure(mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): remove() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m);
			ensure(mThrowsIndex == tThrowsIndex, "Error (" + level + ", " + seed + "): remove() divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m);
			ensure(mThrowsUnsupp == tThrowsUnsupp, "Error (" + level + ", " + seed + "): remove() divergence in UnsupportedOperationException for " + T + " (" + mThrowsUnsupp + ", " + tThrowsUnsupp + ") " + m);
			if (!mThrowsNoElement && !mThrowsIllegal && !mThrowsIndex && !mThrowsUnsupp) ensure(rm == rt, "Error (" + level + ", " + seed + "): divergence in remove() between t and m " + m);
		}

		ensure(m.equals(t), "Error (" + level + ", " + seed + "): ! m.equals(t) after removal " + m);
		ensure(t.equals(m), "Error (" + level + ", " + seed + "): ! t.equals(m) after removal " + m);

		/* Now we add and remove random data in m and t at specific positions, checking that the result is the same. */

		for(int i=0; i<20*n;  i++) {
			KEY_TYPE T = genKey();

			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			int pos = r.nextInt(2);

			try {
				m.add(pos, KEY2OBJ(T));
			}
			catch (java.util.NoSuchElementException e) { mThrowsNoElement = true; }
			catch (IllegalArgumentException e) { mThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { mThrowsIndex = true; }
			catch (UnsupportedOperationException e) { mThrowsUnsupp = true; }

			try {
				t.add(pos, KEY2OBJ(T));
			}
			catch (java.util.NoSuchElementException e) { tThrowsNoElement = true; }
			catch (IllegalArgumentException e) { tThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { tThrowsIndex = true; }
			catch (UnsupportedOperationException e) { tThrowsUnsupp = true; }

			ensure(mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): add() at " + pos + " divergence in java.util.NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m);
			ensure(mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): add() at " + pos + " divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m);
			ensure(mThrowsIndex == tThrowsIndex, "Error (" + level + ", " + seed + "): add() at " + pos + " divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m);
			ensure(mThrowsUnsupp == tThrowsUnsupp, "Error (" + level + ", " + seed + "): add() at " + pos + " divergence in UnsupportedOperationException for " + T + " (" + mThrowsUnsupp + ", " + tThrowsUnsupp + ") " + m);

			T = genKey();

			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			pos = r.nextInt(2);

			try {
				Rm = m.remove(pos);
			}
			catch (java.util.NoSuchElementException e) { mThrowsNoElement = true; }
			catch (IllegalArgumentException e) { mThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { mThrowsIndex = true; }
			catch (UnsupportedOperationException e) { mThrowsUnsupp = true; }

			try {
				Rt = t.remove(pos);
			}
			catch (java.util.NoSuchElementException e) { tThrowsNoElement = true; }
			catch (IllegalArgumentException e) { tThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { tThrowsIndex = true; }
			catch (UnsupportedOperationException e) { tThrowsUnsupp = true; }


			ensure(mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): remove() at " + pos + " divergence in java.util.NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m);
			ensure(mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): remove() at " + pos + " divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m);
			ensure(mThrowsIndex == tThrowsIndex, "Error (" + level + ", " + seed + "): remove() at " + pos + " divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m);
			ensure(mThrowsUnsupp == tThrowsUnsupp, "Error (" + level + ", " + seed + "): remove() at " + pos + " divergence in UnsupportedOperationException for " + T + " (" + mThrowsUnsupp + ", " + tThrowsUnsupp + ") " + m);
			if (!mThrowsNoElement && !mThrowsIllegal && !mThrowsIndex && !mThrowsUnsupp) ensure(Rm == Rt || Rm != null && Rm.equals(Rt), "Error (" + level + ", " + seed + "): divergence in remove() at " + pos + " between t and m " + m);
		}

		ensure(m.equals(t), "Error (" + level + ", " + seed + "): ! m.equals(t) after removal " + m);
		ensure(t.equals(m), "Error (" + level + ", " + seed + "): ! t.equals(m) after removal " + m);

		/* Now we add and remove random collections in m and t, checking that the result is the same. */

		for(int i=0; i<20*n;  i++) {
			KEY_TYPE T = genKey();

			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			try {
				rm = m.addAll(java.util.Collections.singleton(KEY2OBJ(T)));
			}
			catch (java.util.NoSuchElementException e) { mThrowsNoElement = true; }
			catch (IllegalArgumentException e) { mThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { mThrowsIndex = true; }
			catch (UnsupportedOperationException e) { mThrowsUnsupp = true; }

			try {
				rt = t.addAll(java.util.Collections.singleton(KEY2OBJ(T)));
			}
			catch (java.util.NoSuchElementException e) { tThrowsNoElement = true; }
			catch (IllegalArgumentException e) { tThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { tThrowsIndex = true; }
			catch (UnsupportedOperationException e) { tThrowsUnsupp = true; }

			ensure(mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): addAll() divergence in java.util.NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m);
			ensure(mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): addAll() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m);
			ensure(mThrowsIndex == tThrowsIndex, "Error (" + level + ", " + seed + "): addAll() divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m);
			ensure(mThrowsUnsupp == tThrowsUnsupp, "Error (" + level + ", " + seed + "): addAll() divergence in UnsupportedOperationException for " + T + " (" + mThrowsUnsupp + ", " + tThrowsUnsupp + ") " + m);
			if (!mThrowsNoElement && !mThrowsIllegal && !mThrowsIndex && !mThrowsUnsupp) ensure(rm == rt, "Error (" + level + ", " + seed + "): divergence in addAll() between t and m " + m);

			T = genKey();

			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			try {
				rm = m.removeAll(java.util.Collections.singleton(KEY2OBJ(T)));
			}
			catch (java.util.NoSuchElementException e) { mThrowsNoElement = true; }
			catch (IllegalArgumentException e) { mThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { mThrowsIndex = true; }
			catch (UnsupportedOperationException e) { mThrowsUnsupp = true; }

			try {
				rt = t.removeAll(java.util.Collections.singleton(KEY2OBJ(T)));
			}
			catch (java.util.NoSuchElementException e) { tThrowsNoElement = true; }
			catch (IllegalArgumentException e) { tThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { tThrowsIndex = true; }
			catch (UnsupportedOperationException e) { tThrowsUnsupp = true; }


			ensure(mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): removeAll() divergence in java.util.NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m);
			ensure(mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): removeAll() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m);
			ensure(mThrowsIndex == tThrowsIndex, "Error (" + level + ", " + seed + "): removeAll() divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m);
			ensure(mThrowsUnsupp == tThrowsUnsupp, "Error (" + level + ", " + seed + "): removeAll() divergence in UnsupportedOperationException for " + T + " (" + mThrowsUnsupp + ", " + tThrowsUnsupp + ") " + m);
			if (!mThrowsNoElement && !mThrowsIllegal && !mThrowsIndex && !mThrowsUnsupp) ensure(rm == rt, "Error (" + level + ", " + seed + "): divergence in removeAll() between t and m " + m);
		}

		ensure(m.equals(t), "Error (" + level + ", " + seed + "): ! m.equals(t) after set removal " + m);
		ensure(t.equals(m), "Error (" + level + ", " + seed + "): ! t.equals(m) after set removal " + m);

		/* Now we add random collections at specific positions in m and t, checking that the result is the same. */

		for(int i=0; i<20*n;  i++) {
			KEY_TYPE T = genKey();

			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			int pos = r.nextInt(2);

			try {
				rm = m.addAll(pos, java.util.Collections.singleton(KEY2OBJ(T)));
			}
			catch (java.util.NoSuchElementException e) { mThrowsNoElement = true; }
			catch (IllegalArgumentException e) { mThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { mThrowsIndex = true; }
			catch (UnsupportedOperationException e) { mThrowsUnsupp = true; }

			try {
				rt = t.addAll(pos, java.util.Collections.singleton(KEY2OBJ(T)));
			}
			catch (java.util.NoSuchElementException e) { tThrowsNoElement = true; }
			catch (IllegalArgumentException e) { tThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { tThrowsIndex = true; }
			catch (UnsupportedOperationException e) { tThrowsUnsupp = true; }

			ensure(mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): addAll() at " + pos + " divergence in java.util.NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m);
			ensure(mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): addAll() at " + pos + " divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m);
			ensure(mThrowsIndex == tThrowsIndex, "Error (" + level + ", " + seed + "): addAll() at " + pos + " divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m);
			ensure(mThrowsUnsupp == tThrowsUnsupp, "Error (" + level + ", " + seed + "): addAll() at " + pos + " divergence in UnsupportedOperationException for " + T + " (" + mThrowsUnsupp + ", " + tThrowsUnsupp + ") " + m);
			if (!mThrowsNoElement && !mThrowsIllegal && !mThrowsIndex && !mThrowsUnsupp) ensure(rm == rt, "Error (" + level + ", " + seed + "): divergence in addAll() at " + pos + " between t and m " + m);

		}

		ensure(m.equals(t), "Error (" + level + ", " + seed + "): ! m.equals(t) after set removal " + m);
		ensure(t.equals(m), "Error (" + level + ", " + seed + "): ! t.equals(m) after set removal " + m);

		/* Now we check that m actually holds the same data. */

		for(java.util.Iterator i=t.iterator(); i.hasNext();) {
			ensure(m.contains(i.next()), "Error (" + level + ", " + seed + "): m and t differ on an entry after removal (iterating on t)");
		}

		/* Now we check that m actually holds that data, but iterating on m. */

		for(java.util.Iterator i=m.listIterator(); i.hasNext();) {
			ensure(t.contains(i.next()), "Error (" + level + ", " + seed + "): m and t differ on an entry after removal (iterating on m)");
		}

		if (m instanceof Singleton) {
			ensure(m.equals(((Singleton)m).clone()), "Error (" + level + ", " + seed + "): m does not equal m.clone()");
			ensure(((Singleton)m).clone().equals(m), "Error (" + level + ", " + seed + "): m.clone() does not equal m");
		}

		int h = m.hashCode();

		/* Now we save and read m. */

		BIG_LIST m2 = null;

		{
			java.io.File ff = new java.io.File("it.unimi.dsi.fastutil.test." + m.getClass().getSimpleName() + "." + n);
			java.io.OutputStream os = new java.io.FileOutputStream(ff);
			java.io.ObjectOutputStream oos = new java.io.ObjectOutputStream(os);

			oos.writeObject(m);
			oos.close();

			java.io.InputStream is = new java.io.FileInputStream(ff);
			java.io.ObjectInputStream ois = new java.io.ObjectInputStream(is);

			m2 = (BIG_LIST)ois.readObject();
			ois.close();
			ff.delete();
		}

#if ! KEYS_USE_REFERENCE_EQUALITY

		ensure(m2.hashCode() == h, "Error (" + level + ", " + seed + "): hashCode() changed after save/read");

		/* Now we check that m2 actually holds that data. */

		ensure(m2.equals(t), "Error (" + level + ", " + seed + "): ! m2.equals(t) after save/read");
		ensure(t.equals(m2), "Error (" + level + ", " + seed + "): ! t.equals(m2) after save/read");
#endif

		if (! m.isEmpty()) {
			long start = (r.nextLong() & 0x7FFFFFFFFFFFFFFFL) % m.size64();
			long end = start + (r.nextLong() & 0x7FFFFFFFFFFFFFFFL) % (m.size64() - start);
			//System.err.println("Checking subList from " + start + " to " + end + " (level=" + (level+1) + ")...");
			testLists(k, m.subList(start, end), t.subList(start, end), level - 1);

			ensure(m.equals(t), () -> "Error (" + level + ", " + seed + m + t + "): ! m.equals(t) after subList");
			ensure(t.equals(m), "Error (" + level + ", " + seed + "): ! t.equals(m) after subList");

		}

		return;
	}

	private static void test() throws Exception {
		KEY_TYPE k = genKey();
		BIG_LIST m = new Singleton(k);
		BIG_LIST u = BIG_LISTS.unmodifiable(BIG_LISTS.asBigList(LISTS.singleton(KEY2OBJ(k))));
		testLists(k, m, u, 3);
		System.out.println("Test OK");
	}

	private static long seed = System.currentTimeMillis();
	private static java.util.Random r = new java.util.Random(seed);

	private static java.text.NumberFormat format = new java.text.DecimalFormat("#,###.00");
	private static java.text.FieldPosition fp = new java.text.FieldPosition(0);

	private static String format(double d) {
		StringBuffer s = new StringBuffer();
		return format.format(d, s, fp).toString();
	}

	private static void fatal(String msg) {
		throw new AssertionError(msg);
	}

	private static void ensure(boolean cond, String msg) {
		if (cond) return;
		fatal(msg);
	}

	private static void ensure(boolean cond, java.util.function.Supplier<String> msgSupplier) {
		if (cond) return;
		fatal(msgSupplier.get());
	}

	/** This method expects as first argument a lower-cased type (e.g., "int"),
	 * and as second optional argument a seed. */

	public static void main(String arg[]) throws Exception {
		if (arg.length > 1) r = new java.util.Random(seed = Long.parseLong(arg[1]));

		try {
			test();
		} catch(Throwable e) {
			e.printStackTrace(System.err);
			System.err.println("seed: " + seed);
			throw e;
		}
	}

#endif

}
