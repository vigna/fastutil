/*		 
 * Copyright (C) 2002-2015 Sebastiano Vigna
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License. 
 */


package PACKAGE;

import it.unimi.dsi.fastutil.Hash;
import it.unimi.dsi.fastutil.HashCommon;
import static it.unimi.dsi.fastutil.HashCommon.arraySize;
import static it.unimi.dsi.fastutil.HashCommon.maxFill;

import java.util.Map;
import java.util.Arrays;
import java.util.NoSuchElementException;

import VALUE_PACKAGE.VALUE_COLLECTION;
import VALUE_PACKAGE.VALUE_ABSTRACT_COLLECTION;

#if #values(primitive) || #keys(primitive) && #valueclass(Object)
import VALUE_PACKAGE.VALUE_ITERATOR;
#endif

#ifdef Linked

import java.util.Comparator;

#if #key(reference)
import java.util.Collection;
import java.util.Iterator;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
#endif

#if #values(primitive)
import VALUE_PACKAGE.VALUE_LIST_ITERATOR;
#endif

#if #keys(primitive) && #valueclass(Reference)
import it.unimi.dsi.fastutil.objects.ObjectIterator;
#endif

import it.unimi.dsi.fastutil.objects.AbstractObjectSortedSet;
import it.unimi.dsi.fastutil.objects.ObjectListIterator;
import it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator;
import it.unimi.dsi.fastutil.objects.ObjectSortedSet;

#else

import it.unimi.dsi.fastutil.objects.AbstractObjectSet;

#if #keys(primitive) && ! #valueclass(Object)
import it.unimi.dsi.fastutil.objects.ObjectIterator;
#endif

#endif


#ifdef Linked
/**  A type-specific linked hash map with with a fast, small-footprint implementation.
 *
 * <P>Instances of this class use a hash table to represent a map. The table is
 * filled up to a specified <em>load factor</em>, and then doubled in size to
 * accommodate new entries. If the table is emptied below <em>one fourth</em>
 * of the load factor, it is halved in size. However, halving is
 * not performed when deleting entries from an iterator, as it would interfere
 * with the iteration process.
 *
 * <p>Note that {@link #clear()} does not modify the hash table size. 
 * Rather, a family of {@linkplain #trim() trimming
 * methods} lets you control the size of the table; this is particularly useful
 * if you reuse instances of this class.
 *
 * <P>Iterators generated by this map will enumerate pairs in the same order in which they
 * have been added to the map (addition of pairs whose key is already present 
 * in the set does not change the iteration order). Note that this order has nothing in common with the natural
 * order of the keys. The order is kept by means of a doubly linked list, represented
 * <i>via</i> an array of longs parallel to the table.
 *
 * <P>This class implements the interface of a sorted map, so to allow easy
 * access of the iteration order: for instance, you can get the first key
 * in iteration order with {@link #firstKey()} without having to create an
 * iterator; however, this class partially violates the {@link java.util.SortedMap}
 * contract because all submap methods throw an exception and {@link
 * #comparator()} returns always <code>null</code>.
 *
 * <p>Additional methods, such as <code>getAndMoveToFirst()</code>, make it easy
 * to use instances of this class as a cache (e.g., with LRU policy).
 *
 * <P>The iterators provided by the views of this class using are type-specific
 * {@linkplain java.util.ListIterator list iterators}, and can be started at any
 * element <em>which is a key of the map</em>, or
 * a {@link NoSuchElementException} exception will be thrown.
 * If, however, the provided element is not the first or last key in the
 * set, the first access to the list index will require linear time, as in the worst case
 * the entire key set must be scanned in iteration order to retrieve the positional
 * index of the starting key. If you use just the methods of a type-specific {@link it.unimi.dsi.fastutil.BidirectionalIterator},
 * however, all operations will be performed in constant time.
 *
 * @see Hash
 * @see HashCommon
 */

public class OPEN_HASH_MAP KEY_VALUE_GENERIC extends ABSTRACT_SORTED_MAP KEY_VALUE_GENERIC implements java.io.Serializable, Cloneable, Hash {

#else

#ifdef Custom

/** A type-specific hash map with a fast, small-footprint implementation whose {@linkplain it.unimi.dsi.fastutil.Hash.Strategy hashing strategy}
 * is specified at creation time.
 *
 * <P>Instances of this class use a hash table to represent a map. The table is
 * filled up to a specified <em>load factor</em>, and then doubled in size to
 * accommodate new entries. If the table is emptied below <em>one fourth</em>
 * of the load factor, it is halved in size. However, halving is
 * not performed when deleting entries from an iterator, as it would interfere
 * with the iteration process.
 *
 * <p>Note that {@link #clear()} does not modify the hash table size. 
 * Rather, a family of {@linkplain #trim() trimming
 * methods} lets you control the size of the table; this is particularly useful
 * if you reuse instances of this class.
 *
 * @see Hash
 * @see HashCommon
 */

public class OPEN_HASH_MAP KEY_VALUE_GENERIC extends ABSTRACT_MAP KEY_VALUE_GENERIC implements java.io.Serializable, Cloneable, Hash {

#else

/** A type-specific hash map with a fast, small-footprint implementation.
 *
 * <P>Instances of this class use a hash table to represent a map. The table is
 * filled up to a specified <em>load factor</em>, and then doubled in size to
 * accommodate new entries. If the table is emptied below <em>one fourth</em>
 * of the load factor, it is halved in size. However, halving is
 * not performed when deleting entries from an iterator, as it would interfere
 * with the iteration process.
 *
 * <p>Note that {@link #clear()} does not modify the hash table size. 
 * Rather, a family of {@linkplain #trim() trimming
 * methods} lets you control the size of the table; this is particularly useful
 * if you reuse instances of this class.
 *
 * @see Hash
 * @see HashCommon
 */

public class OPEN_HASH_MAP KEY_VALUE_GENERIC extends ABSTRACT_MAP KEY_VALUE_GENERIC implements java.io.Serializable, Cloneable, Hash {

#endif

#endif

    private static final long serialVersionUID = 0L;
	private static final boolean ASSERTS = ASSERTS_VALUE;

	/** The array of keys. */
	protected transient KEY_GENERIC_TYPE[] key;

	/** The array of values. */
	protected transient VALUE_GENERIC_TYPE[] value;
	 
	/** The mask for wrapping a position counter. */
	protected transient int mask;

	/** Whether this set contains the key zero. */
	protected transient boolean containsNullKey;

#ifdef Custom
	/** The hash strategy of this custom map. */
	protected STRATEGY KEY_GENERIC strategy;
#endif

#ifdef Linked
	/** The index of the first entry in iteration order. It is valid iff {@link #size} is nonzero; otherwise, it contains -1. */
	protected transient int first = -1;
	/** The index of the last entry in iteration order. It is valid iff {@link #size} is nonzero; otherwise, it contains -1. */
	protected transient int last = -1;
	/** For each entry, the next and the previous entry in iteration order,
     * stored as <code>((prev & 0xFFFFFFFFL) << 32) | (next & 0xFFFFFFFFL)</code>.
     * The first entry contains predecessor -1, and the last entry 
     * contains successor -1. */
     protected transient long[] link;
#endif

	/** The current table size. */
	protected transient int n;

	/** Threshold after which we rehash. It must be the table size times {@link #f}. */
	protected transient int maxFill;

	/** Number of entries in the set (including the key zero, if present). */
	protected int size;

	/** The acceptable load factor. */
	protected final float f;
	 
#ifdef Linked
	/** Cached set of entries. */
	protected transient volatile FastSortedEntrySet KEY_VALUE_GENERIC entries;

	/** Cached set of keys. */
	protected transient volatile SORTED_SET KEY_GENERIC keys;
#else
	/** Cached set of entries. */
	protected transient volatile FastEntrySet KEY_VALUE_GENERIC entries;

	/** Cached set of keys. */
	protected transient volatile SET KEY_GENERIC keys;
#endif

	/** Cached collection of values. */
	protected transient volatile VALUE_COLLECTION VALUE_GENERIC values;


#ifdef Custom
	/** Creates a new hash map.
	 *
	 * <p>The actual table size will be the least power of two greater than <code>expected</code>/<code>f</code>.
	 *
	 * @param expected the expected number of elements in the hash set. 
	 * @param f the load factor.
	 * @param strategy the strategy.
	 */
	SUPPRESS_WARNINGS_KEY_VALUE_UNCHECKED
	public OPEN_HASH_MAP( final int expected, final float f, final STRATEGY KEY_GENERIC strategy ) {
		this.strategy = strategy;
#else
	/** Creates a new hash map.
	 *
	 * <p>The actual table size will be the least power of two greater than <code>expected</code>/<code>f</code>.
	 *
	 * @param expected the expected number of elements in the hash set. 
	 * @param f the load factor.
	 */
	SUPPRESS_WARNINGS_KEY_VALUE_UNCHECKED
	public OPEN_HASH_MAP( final int expected, final float f ) {
#endif
		if ( f <= 0 || f > 1 ) throw new IllegalArgumentException( "Load factor must be greater than 0 and smaller than or equal to 1" );
		if ( expected < 0 ) throw new IllegalArgumentException( "The expected number of elements must be nonnegative" );

		this.f = f;

		n = arraySize( expected, f );
		mask = n - 1;
		maxFill = maxFill( n, f );
		key = KEY_GENERIC_ARRAY_CAST new KEY_TYPE[ n + 1 ];
		value = VALUE_GENERIC_ARRAY_CAST new VALUE_TYPE[ n + 1 ];
#ifdef Linked
		link = new long[ n + 1 ];
#endif
	}
	 
	 
#ifdef Custom
	/** Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
	 *
	 * @param expected the expected number of elements in the hash map.
	 * @param strategy the strategy.
	 */
	 
	public OPEN_HASH_MAP( final int expected, final STRATEGY KEY_GENERIC strategy ) {
		this( expected, DEFAULT_LOAD_FACTOR, strategy );
	}
#else
	/** Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
	 *
	 * @param expected the expected number of elements in the hash map.
	 */
	 
	public OPEN_HASH_MAP( final int expected ) {
		this( expected, DEFAULT_LOAD_FACTOR );
	}
#endif


#ifdef Custom
	/** Creates a new hash map with initial expected {@link Hash#DEFAULT_INITIAL_SIZE} entries
	 * and {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
	 * @param strategy the strategy.
	 */
	 
	public OPEN_HASH_MAP( final STRATEGY KEY_GENERIC strategy ) {
		this( DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR, strategy );
	}
#else
	/** Creates a new hash map with initial expected {@link Hash#DEFAULT_INITIAL_SIZE} entries
	 * and {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
	 */
	 
	public OPEN_HASH_MAP() {
		this( DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR );
	}
#endif


#ifdef Custom
	/** Creates a new hash map copying a given one.
	 *
	 * @param m a {@link Map} to be copied into the new hash map. 
	 * @param f the load factor.
	 * @param strategy the strategy.
	 */
	 
	public OPEN_HASH_MAP( final Map<? extends KEY_GENERIC_CLASS, ? extends VALUE_GENERIC_CLASS> m, final float f, final STRATEGY KEY_GENERIC strategy ) {
		this( m.size(), f, strategy );
		putAll( m );
	}
#else
	/** Creates a new hash map copying a given one.
	 *
	 * @param m a {@link Map} to be copied into the new hash map. 
	 * @param f the load factor.
	 */
	 
	public OPEN_HASH_MAP( final Map<? extends KEY_GENERIC_CLASS, ? extends VALUE_GENERIC_CLASS> m, final float f ) {
		this( m.size(), f );
		putAll( m );
	}
#endif

#ifdef Custom
	/** Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor copying a given one.
	 *
	 * @param m a {@link Map} to be copied into the new hash map. 
	 * @param strategy the strategy.
	 */
	 
	public OPEN_HASH_MAP( final Map<? extends KEY_GENERIC_CLASS, ? extends VALUE_GENERIC_CLASS> m, final STRATEGY KEY_GENERIC strategy ) {
		this( m, DEFAULT_LOAD_FACTOR, strategy );
	}
#else
	/** Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor copying a given one.
	 *
	 * @param m a {@link Map} to be copied into the new hash map. 
	 */
	 
	public OPEN_HASH_MAP( final Map<? extends KEY_GENERIC_CLASS, ? extends VALUE_GENERIC_CLASS> m ) {
		this( m, DEFAULT_LOAD_FACTOR );
	}
#endif

#ifdef Custom
	/** Creates a new hash map copying a given type-specific one.
	 *
	 * @param m a type-specific map to be copied into the new hash map. 
	 * @param f the load factor.
	 * @param strategy the strategy.
	 */
	 
	public OPEN_HASH_MAP( final MAP KEY_VALUE_GENERIC m, final float f, final STRATEGY KEY_GENERIC strategy ) {
		this( m.size(), f, strategy );
		putAll( m );
	}
#else
	/** Creates a new hash map copying a given type-specific one.
	 *
	 * @param m a type-specific map to be copied into the new hash map. 
	 * @param f the load factor.
	 */
	 
	public OPEN_HASH_MAP( final MAP KEY_VALUE_GENERIC m, final float f ) {
		this( m.size(), f );
		putAll( m );
	}
#endif

#ifdef Custom
	/** Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor copying a given type-specific one.
	 *
	 * @param m a type-specific map to be copied into the new hash map. 
	 * @param strategy the strategy.
	 */
	 
	public OPEN_HASH_MAP( final MAP KEY_VALUE_GENERIC m, final STRATEGY KEY_GENERIC strategy ) {
		this( m, DEFAULT_LOAD_FACTOR, strategy );
	}
#else
	/** Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor copying a given type-specific one.
	 *
	 * @param m a type-specific map to be copied into the new hash map. 
	 */
	 
	public OPEN_HASH_MAP( final MAP KEY_VALUE_GENERIC m ) {
		this( m, DEFAULT_LOAD_FACTOR );
	}
#endif


#ifdef Custom
	/** Creates a new hash map using the elements of two parallel arrays.
	 *
	 * @param k the array of keys of the new hash map.
	 * @param v the array of corresponding values in the new hash map.
	 * @param f the load factor.
	 * @param strategy the strategy.
	 * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have different lengths.
	 */
	 
	public OPEN_HASH_MAP( final KEY_GENERIC_TYPE[] k, final VALUE_GENERIC_TYPE[] v, final float f, final STRATEGY KEY_GENERIC strategy ) {
		this( k.length, f, strategy );
		if ( k.length != v.length ) throw new IllegalArgumentException( "The key array and the value array have different lengths (" + k.length + " and " + v.length + ")" );
		for( int i = 0; i < k.length; i++ ) this.put( k[ i ], v[ i ] );
	}
#else
	/** Creates a new hash map using the elements of two parallel arrays.
	 *
	 * @param k the array of keys of the new hash map.
	 * @param v the array of corresponding values in the new hash map.
	 * @param f the load factor.
	 * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have different lengths.
	 */
	 
	public OPEN_HASH_MAP( final KEY_GENERIC_TYPE[] k, final VALUE_GENERIC_TYPE[] v, final float f ) {
		this( k.length, f );
		if ( k.length != v.length ) throw new IllegalArgumentException( "The key array and the value array have different lengths (" + k.length + " and " + v.length + ")" );
		for( int i = 0; i < k.length; i++ ) this.put( k[ i ], v[ i ] );
	}
#endif

#ifdef Custom
	/** Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor using the elements of two parallel arrays.
	 *
	 * @param k the array of keys of the new hash map.
	 * @param v the array of corresponding values in the new hash map.
	 * @param strategy the strategy.
	 * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have different lengths.
	 */
	 
	public OPEN_HASH_MAP( final KEY_GENERIC_TYPE[] k, final VALUE_GENERIC_TYPE[] v, final STRATEGY KEY_GENERIC strategy ) {
		this( k, v, DEFAULT_LOAD_FACTOR, strategy );
	}
#else
	/** Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor using the elements of two parallel arrays.
	 *
	 * @param k the array of keys of the new hash map.
	 * @param v the array of corresponding values in the new hash map.
	 * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have different lengths.
	 */
	 
	public OPEN_HASH_MAP( final KEY_GENERIC_TYPE[] k, final VALUE_GENERIC_TYPE[] v ) {
		this( k, v, DEFAULT_LOAD_FACTOR );
	}
#endif



#ifdef Custom
	/** Returns the hashing strategy.
	 *
	 * @return the hashing strategy of this custom hash map.
	 */

	public STRATEGY KEY_GENERIC strategy() {
		return strategy;
	}
#endif

	private int realSize() {
		return containsNullKey ? size - 1 : size;
	}

	private void ensureCapacity( final int capacity ) {
		final int needed = arraySize( capacity, f );
		if ( needed > n ) rehash( needed );
	}

	private void tryCapacity( final long capacity ) {
		final int needed = (int)Math.min( 1 << 30, Math.max( 2, HashCommon.nextPowerOfTwo( (long)Math.ceil( capacity / f ) ) ) );
		if ( needed > n ) rehash( needed );
	}

	private VALUE_GENERIC_TYPE removeEntry( final int pos ) {
		final VALUE_GENERIC_TYPE oldValue = value[ pos ];
#if #values(reference)
		value[ pos ] = null;
#endif
		size--;
#ifdef Linked
		fixPointers( pos );
#endif

		shiftKeys( pos );
		if ( size < maxFill / 4 && n > DEFAULT_INITIAL_SIZE ) rehash( n / 2 );
		return oldValue;
	}

	private VALUE_GENERIC_TYPE removeNullEntry() {
		containsNullKey = false;
#if #keys(reference)
		key[ n ] = null;
#endif
		final VALUE_GENERIC_TYPE oldValue = value[ n ];
#if #values(reference)
		value[ n ] = null;
#endif
		size--;
#ifdef Linked
		fixPointers( n );
#endif
		if ( size < maxFill / 4 && n > DEFAULT_INITIAL_SIZE ) rehash( n / 2 );
		return oldValue;
	}


	/** {@inheritDoc} */
	public void putAll(Map<? extends KEY_GENERIC_CLASS,? extends VALUE_GENERIC_CLASS> m) {
		if ( f <= .5 ) ensureCapacity( m.size() ); // The resulting map will be sized for m.size() elements
		else tryCapacity( size() + m.size() ); // The resulting map will be tentatively sized for size() + m.size() elements
		super.putAll( m );
	}

	private int insert(final KEY_GENERIC_TYPE k, final VALUE_GENERIC_TYPE v) {
		int pos;

		if ( KEY_EQUALS_NULL( k ) ) {
			if ( containsNullKey ) return n;
			containsNullKey = true;
			pos = n;
		}			
		else {
			KEY_GENERIC_TYPE curr;
			final KEY_GENERIC_TYPE[] key = this.key;

			// The starting point.
			if ( ! KEY_IS_NULL( curr = key[ pos = KEY2INTHASH( k ) & mask ] ) ) {
				if ( KEY_EQUALS_NOT_NULL( curr, k ) ) return pos;
				while( ! KEY_IS_NULL( curr = key[ pos = ( pos + 1 ) & mask ] ) ) 
					if ( KEY_EQUALS_NOT_NULL( curr, k ) ) return pos;
			}
		}

		key[ pos ] = k;
		value[ pos ] = v;
#ifdef Linked
		if ( size == 0 ) {
			first = last = pos;
			// Special case of SET_UPPER_LOWER( link[ pos ], -1, -1 );
			link[ pos ] = -1L;
		}
		else {
			SET_NEXT( link[ last ], pos );
			SET_UPPER_LOWER(  link[ pos ], last, -1  );
			last = pos;
		}
#endif

		if ( size++ >= maxFill ) rehash( arraySize( size + 1, f ) );
		if ( ASSERTS ) checkTable();
		return -1;
	}

	public VALUE_GENERIC_TYPE put(final KEY_GENERIC_TYPE k, final VALUE_GENERIC_TYPE v) {
		final int pos = insert( k, v );
		if ( pos < 0 ) return defRetValue;
		final VALUE_GENERIC_TYPE oldValue = value[ pos ];
		value[ pos ] = v;
		return oldValue;
	}



#if #values(primitive) || #keys(primitive)
	/** {@inheritDoc}
	 * @deprecated Please use the corresponding type-specific method instead. */
	@Deprecated
	@Override
	public VALUE_GENERIC_CLASS put( final KEY_GENERIC_CLASS ok, final VALUE_GENERIC_CLASS ov ) {
		final VALUE_GENERIC_TYPE v = VALUE_CLASS2TYPE( ov );

		final int pos = insert( KEY_CLASS2TYPE( ok ), v );
		if ( pos < 0 ) return OBJECT_DEFAULT_RETURN_VALUE;
		final VALUE_GENERIC_TYPE oldValue = value[ pos ];
		value[ pos ] = v;
		return VALUE2OBJ( oldValue );
	}
#endif


#if #valueclass(Byte) || #valueclass(Short) || #valueclass(Char) || #valueclass(Integer) || #valueclass(Long) || #valueclass(Float) || #valueclass(Double)

	private VALUE_GENERIC_TYPE addToValue( final int pos, final VALUE_GENERIC_TYPE incr ) {
		final VALUE_GENERIC_TYPE oldValue = value[ pos ];
#if #valueclass(Byte) || #valueclass(Short) || #valueclass(Char)		
		value[ pos ] = (VALUE_TYPE)(oldValue + incr);
#else
		value[ pos ] = oldValue + incr;
#endif
		return oldValue;
	}

	/** Adds an increment to value currently associated with a key.
	 *
	 * <P>Note that this method respects the {@linkplain #defaultReturnValue() default return value} semantics: when
	 * called with a key that does not currently appears in the map, the key
	 * will be associated with the default return value plus
	 * the given increment.
	 *
	 * @param k the key.
	 * @param incr the increment.
	 * @return the old value, or the {@linkplain #defaultReturnValue() default return value} if no value was present for the given key.
	 */
	public VALUE_GENERIC_TYPE addTo(final KEY_GENERIC_TYPE k, final VALUE_GENERIC_TYPE incr) {
		int pos;
	
		if ( KEY_EQUALS_NULL( k ) ) {
			if ( containsNullKey ) return addToValue( n, incr );
			pos = n;
			containsNullKey = true;
		}
		else {
			KEY_GENERIC_TYPE curr;
			final KEY_GENERIC_TYPE[] key = this.key;

			// The starting point.
			if ( ! KEY_IS_NULL( curr = key[ pos = KEY2INTHASH( k ) & mask ] ) ) {
				if ( KEY_EQUALS_NOT_NULL( curr, k ) ) return addToValue( pos, incr );
				while( ! KEY_IS_NULL( curr = key[ pos = ( pos + 1 ) & mask ] ) ) 
					if ( KEY_EQUALS_NOT_NULL( curr, k ) ) return addToValue( pos, incr );
			}
		}

		key[ pos ] = k;

#if #valueclass(Byte) || #valueclass(Short) || #valueclass(Char)		
		value[ pos ] = (VALUE_TYPE)(defRetValue + incr);
#else
		value[ pos ] = defRetValue + incr;
#endif
		
#ifdef Linked
		if ( size == 0 ) {
			first = last = pos;
			// Special case of SET_UPPER_LOWER( link[ pos ], -1, -1 );
			link[ pos ] = -1L;
		}
		else {
			SET_NEXT( link[ last ], pos );
			SET_UPPER_LOWER( link[ pos ], last, -1 );
			last = pos;
		}
#endif

		if ( size++ >= maxFill ) rehash( arraySize( size + 1, f ) );
		if ( ASSERTS ) checkTable();
		return defRetValue;
	}

#endif

	/** Shifts left entries with the specified hash code, starting at the specified position,
	 * and empties the resulting free entry.
	 *
	 * @param pos a starting position.
	 */
	protected final void shiftKeys( int pos ) {
		// Shift entries with the same hash.
		int last, slot;
		KEY_GENERIC_TYPE curr;
		final KEY_GENERIC_TYPE[] key = this.key;

		for(;;) {
			pos = ( ( last = pos ) + 1 ) & mask;
			
			for(;;) {
				if ( KEY_IS_NULL( curr = key[ pos ] ) ) {
					key[ last ] = KEY_NULL;
#if #values(reference)
					value[ last ] = null;
#endif
					return;
				}
				slot = KEY2INTHASH( curr ) & mask;
				if ( last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos ) break;
				pos = ( pos + 1 ) & mask;
			}

			key[ last ] = curr;			
			value[ last ] = value[ pos ];			
#ifdef Linked
			fixPointers( pos, last );
#endif
		}
	}


	SUPPRESS_WARNINGS_KEY_UNCHECKED
	public VALUE_GENERIC_TYPE REMOVE_VALUE( final KEY_TYPE k ) {
		if ( KEY_EQUALS_NULL( KEY_GENERIC_CAST k ) ) {
			if ( containsNullKey ) return removeNullEntry();
			return defRetValue;
		}
       
		KEY_GENERIC_TYPE curr;
		final KEY_GENERIC_TYPE[] key = this.key;
		int pos;

		// The starting point.
		if ( KEY_IS_NULL( curr = key[ pos = KEY2INTHASH_CAST( k ) & mask ] ) ) return defRetValue;
		if ( KEY_EQUALS_NOT_NULL_CAST( k, curr ) ) return removeEntry( pos );
		while( true ) {
			if ( KEY_IS_NULL( curr = key[ pos = ( pos + 1 ) & mask ] ) ) return defRetValue;
			if ( KEY_EQUALS_NOT_NULL_CAST( k, curr ) ) return removeEntry( pos );
		}
	}


#if #keys(primitive) || #values(primitive)
	/** {@inheritDoc}
	 * @deprecated Please use the corresponding type-specific method instead. */
	@Deprecated
	@Override
	SUPPRESS_WARNINGS_KEY_UNCHECKED
	public VALUE_GENERIC_CLASS remove( final Object ok ) {
		final KEY_GENERIC_TYPE k = KEY_GENERIC_CAST KEY_OBJ2TYPE( ok );
		if ( KEY_EQUALS_NULL( k ) ) {
			if ( containsNullKey ) return VALUE2OBJ( removeNullEntry() );
			return OBJECT_DEFAULT_RETURN_VALUE;
		}

		KEY_GENERIC_TYPE curr;
		final KEY_GENERIC_TYPE[] key = this.key;
		int pos;

		// The starting point.
		if ( KEY_IS_NULL( curr = key[ pos = KEY2INTHASH( k ) & mask ] ) ) return OBJECT_DEFAULT_RETURN_VALUE;
		if ( KEY_EQUALS_NOT_NULL( curr, k ) ) return VALUE2OBJ( removeEntry( pos ) );
		while( true ) {
			if ( KEY_IS_NULL( curr = key[ pos = ( pos + 1 ) & mask ] ) ) return OBJECT_DEFAULT_RETURN_VALUE;
			if ( KEY_EQUALS_NOT_NULL( curr, k ) ) return VALUE2OBJ( removeEntry( pos ) );
		}
	}
#endif


#ifdef Linked
	
	private VALUE_GENERIC_TYPE setValue( final int pos, final VALUE_GENERIC_TYPE v ) {
		final VALUE_GENERIC_TYPE oldValue = value[ pos ];
		value[ pos ] = v;
		return oldValue;
	}

	/** Removes the mapping associated with the first key in iteration order.
	 * @return the value previously associated with the first key in iteration order.
	 * @throws NoSuchElementException is this map is empty.
	 */
	public VALUE_GENERIC_TYPE REMOVE_FIRST_VALUE() {
		if ( size == 0 ) throw new NoSuchElementException();
		final int pos = first;
		// Abbreviated version of fixPointers(pos)
		first = GET_NEXT(link[ pos ]);
		if ( 0 <= first ) {
			// Special case of SET_PREV( link[ first ], -1 )
			link[ first ] |= (-1 & 0xFFFFFFFFL) << 32;
		}
		size--;
		final VALUE_GENERIC_TYPE v = value[ pos ];
		if ( pos == n ) {
			containsNullKey = false;
#if #keys(reference)
			key[ n ] = null;
#endif
#if #values(reference)
			value[ n ] = null;
#endif
		}
		else shiftKeys( pos );
		if ( size < maxFill / 4 && n > DEFAULT_INITIAL_SIZE ) rehash( n / 2 );
		return v;
	}

	/** Removes the mapping associated with the last key in iteration order.
	 * @return the value previously associated with the last key in iteration order.
	 * @throws NoSuchElementException is this map is empty.
	 */
	public VALUE_GENERIC_TYPE REMOVE_LAST_VALUE() {
		if ( size == 0 ) throw new NoSuchElementException();
		final int pos = last;
		// Abbreviated version of fixPointers(pos)
		last = GET_PREV(link[ pos ]);
		if ( 0 <= last ) {
			// Special case of SET_NEXT( link[ last ], -1 )
			link[ last ] |= -1 & 0xFFFFFFFFL;
		}
		size--;
		final VALUE_GENERIC_TYPE v = value[ pos ];
		if ( pos == n ) {
			containsNullKey = false;
#if #keys(reference)
			key[ n ] = null;
#endif
#if #values(reference)
			value[ n ] = null;
#endif
		}
		else shiftKeys( pos );
		if ( size < maxFill / 4 && n > DEFAULT_INITIAL_SIZE ) rehash( n / 2 );
		return v;
	}

	private void moveIndexToFirst( final int i ) {
		if ( size == 1 || first == i ) return;
		if ( last == i ) {
			last = GET_PREV(link[ i ]);
			// Special case of SET_NEXT( link[ last ], -1 );
			link[ last ] |= -1 & 0xFFFFFFFFL;
		}
		else {
			final long linki = link[ i ];
			final int prev = GET_PREV(linki);
			final int next = GET_NEXT(linki);
			COPY_NEXT(link[ prev ], linki);
			COPY_PREV(link[ next ], linki);
		}
		SET_PREV( link[ first ], i );
		SET_UPPER_LOWER( link[ i ], -1, first );
		first = i;
	}

	private void moveIndexToLast( final int i ) {
		if ( size == 1 ||  last == i ) return;
		if ( first == i ) {
			first = GET_NEXT(link[ i ]);
			// Special case of SET_PREV( link[ first ], -1 );
			link[ first ] |= (-1 & 0xFFFFFFFFL) << 32;
		}
		else {
			final long linki = link[ i ];
			final int prev = GET_PREV(linki);
			final int next = GET_NEXT(linki);
			COPY_NEXT(link[ prev ], linki);
			COPY_PREV(link[ next ], linki);
		}
		SET_NEXT( link[ last ], i );
		SET_UPPER_LOWER( link[ i ], last, -1 );
		last = i;
	}

	/** Returns the value to which the given key is mapped; if the key is present, it is moved to the first position of the iteration order.
	 *
	 * @param k the key.
	 * @return the corresponding value, or the {@linkplain #defaultReturnValue() default return value} if no value was present for the given key.
	 */
	public VALUE_GENERIC_TYPE getAndMoveToFirst( final KEY_GENERIC_TYPE k ) {
		if ( KEY_EQUALS_NULL( k ) ) {
			if ( containsNullKey ) {
				moveIndexToFirst( n );
				return value[ n ];
			}
			
			return defRetValue;
		}
	
		KEY_GENERIC_TYPE curr;
		final KEY_GENERIC_TYPE[] key = this.key;
		int pos;

		// The starting point.
		if ( KEY_IS_NULL( curr = key[ pos = KEY2INTHASH( k ) & mask ] ) ) return defRetValue;
		if ( KEY_EQUALS_NOT_NULL( k, curr ) ) {
			moveIndexToFirst( pos );
			return value[ pos ];
		}

		// There's always an unused entry.
		while( true ) {
			if ( KEY_IS_NULL( curr = key[ pos = ( pos + 1 ) & mask ] ) ) return defRetValue;
			if ( KEY_EQUALS_NOT_NULL( k, curr ) )  {
				moveIndexToFirst( pos );
				return value[ pos ];
			}
		}
	}
	
	/** Returns the value to which the given key is mapped; if the key is present, it is moved to the last position of the iteration order.
	 *
	 * @param k the key.
	 * @return the corresponding value, or the {@linkplain #defaultReturnValue() default return value} if no value was present for the given key.
	 */
	public VALUE_GENERIC_TYPE getAndMoveToLast( final KEY_GENERIC_TYPE k ) {
		if ( KEY_EQUALS_NULL( k ) ) {
			if ( containsNullKey ) {
				moveIndexToLast( n );
				return value[ n ];
			}
			
			return defRetValue;
		}
	
		KEY_GENERIC_TYPE curr;
		final KEY_GENERIC_TYPE[] key = this.key;
		int pos;

		// The starting point.
		if ( KEY_IS_NULL( curr = key[ pos = KEY2INTHASH( k ) & mask ] ) ) return defRetValue;
		if ( KEY_EQUALS_NOT_NULL( k, curr ) ) {
			moveIndexToLast( pos );
			return value[ pos ];
		}

		// There's always an unused entry.
		while( true ) {
			if ( KEY_IS_NULL( curr = key[ pos = ( pos + 1 ) & mask ] ) ) return defRetValue;
			if ( KEY_EQUALS_NOT_NULL( k, curr ) )  {
				moveIndexToLast( pos );
				return value[ pos ];
			}
		}
	}
	
	/** Adds a pair to the map; if the key is already present, it is moved to the first position of the iteration order.
	 *
	 * @param k the key.
	 * @param v the value.
	 * @return the old value, or the {@linkplain #defaultReturnValue() default return value} if no value was present for the given key.
	 */
	public VALUE_GENERIC_TYPE putAndMoveToFirst( final KEY_GENERIC_TYPE k, final VALUE_GENERIC_TYPE v ) {
		int pos;

		if ( KEY_EQUALS_NULL( k ) ) {
			if ( containsNullKey ) {
				moveIndexToFirst( n );
				return setValue( n, v );
			}
			containsNullKey = true;
			pos = n;
		}
		else {
			KEY_GENERIC_TYPE curr;
			final KEY_GENERIC_TYPE[] key = this.key;

			// The starting point.
			if ( ! KEY_IS_NULL( curr = key[ pos = KEY2INTHASH( k ) & mask ] ) ) {
				if ( KEY_EQUALS_NOT_NULL( curr, k ) ) {
					moveIndexToFirst( pos );
					return setValue( pos, v );
				}
				while( ! KEY_IS_NULL( curr = key[ pos = ( pos + 1 ) & mask ] ) ) 
					if ( KEY_EQUALS_NOT_NULL( curr, k ) ) {
						moveIndexToFirst( pos );
						return setValue( pos, v );
					}
			}
		}
		  
		key[ pos ] = k;
		value[ pos ] = v;
		
		if ( size == 0 ) {
			first = last = pos;
			// Special case of SET_UPPER_LOWER( link[ pos ], -1, -1 );
			link[ pos ] = -1L;
		}
		else {
			SET_PREV( link[ first ], pos );
			SET_UPPER_LOWER( link[ pos ], -1, first );
			first = pos;
		}

		if ( size++ >= maxFill ) rehash( arraySize( size, f ) );
		if ( ASSERTS ) checkTable();
		return defRetValue;
	}

	/** Adds a pair to the map; if the key is already present, it is moved to the last position of the iteration order.
	 *
	 * @param k the key.
	 * @param v the value.
	 * @return the old value, or the {@linkplain #defaultReturnValue() default return value} if no value was present for the given key.
	 */
	public VALUE_GENERIC_TYPE putAndMoveToLast( final KEY_GENERIC_TYPE k, final VALUE_GENERIC_TYPE v ) {
		int pos;

		if ( KEY_EQUALS_NULL( k ) ) {
			if ( containsNullKey ) {
				moveIndexToLast( n );
				return setValue( n, v );
			}
			containsNullKey = true;
			pos = n;
		}
		else {
			KEY_GENERIC_TYPE curr;
			final KEY_GENERIC_TYPE[] key = this.key;

			// The starting point.
			if ( ! KEY_IS_NULL( curr = key[ pos = KEY2INTHASH( k ) & mask ] ) ) {
				if ( KEY_EQUALS_NOT_NULL( curr, k ) ) {
					moveIndexToLast( pos );
					return setValue( pos, v );
				}
				while( ! KEY_IS_NULL( curr = key[ pos = ( pos + 1 ) & mask ] ) ) 
					if ( KEY_EQUALS_NOT_NULL( curr, k ) ) {
						moveIndexToLast( pos );
						return setValue( pos, v );
					}
			}
		}
		  
		key[ pos ] = k;
		value[ pos ] = v;
				
		if ( size == 0 ) {
			first = last = pos;
			// Special case of SET_UPPER_LOWER( link[ pos ], -1, -1 );
			link[ pos ] = -1L;
		}
		else {
			SET_NEXT( link[ last ], pos );
			SET_UPPER_LOWER( link[ pos ], last, -1 );
			last = pos;
		}

		if ( size++ >= maxFill ) rehash( arraySize( size, f ) );
		if ( ASSERTS ) checkTable();
		return defRetValue;
	}

#endif

#if #keys(primitive)

	public VALUE_GENERIC_CLASS get( final KEY_CLASS ok ) {
		final KEY_GENERIC_TYPE k = KEY_CLASS2TYPE( ok );
		if ( KEY_EQUALS_NULL( k ) ) return containsNullKey ? VALUE2OBJ( value[ n ] ) : OBJECT_DEFAULT_RETURN_VALUE;

		KEY_GENERIC_TYPE curr;
		final KEY_GENERIC_TYPE[] key = this.key;
		int pos;

		// The starting point.
		if ( KEY_IS_NULL( curr = key[ pos = KEY2INTHASH( k ) & mask ] ) ) return OBJECT_DEFAULT_RETURN_VALUE;
		if ( KEY_EQUALS_NOT_NULL( k, curr ) ) return VALUE2OBJ( value[ pos ] );

		// There's always an unused entry.
		while( true ) {
			if ( KEY_IS_NULL( curr = key[ pos = ( pos + 1 ) & mask ] ) ) return OBJECT_DEFAULT_RETURN_VALUE;
			if ( KEY_EQUALS_NOT_NULL( k, curr ) ) return VALUE2OBJ( value[ pos ] );
		}
	}

#endif

	SUPPRESS_WARNINGS_KEY_UNCHECKED
	public VALUE_GENERIC_TYPE GET_VALUE( final KEY_TYPE k ) {
		if ( KEY_EQUALS_NULL( KEY_GENERIC_CAST k ) ) return containsNullKey ? value[ n ] : defRetValue;

		KEY_GENERIC_TYPE curr;
		final KEY_GENERIC_TYPE[] key = this.key;
		int pos;

		// The starting point.
		if ( KEY_IS_NULL( curr = key[ pos = KEY2INTHASH_CAST( k ) & mask ] ) ) return defRetValue;
		if ( KEY_EQUALS_NOT_NULL_CAST( k, curr ) ) return value[ pos ];
		// There's always an unused entry.
		while( true ) {
			if ( KEY_IS_NULL( curr = key[ pos = ( pos + 1 ) & mask ] ) ) return defRetValue;
			if ( KEY_EQUALS_NOT_NULL_CAST( k, curr ) ) return value[ pos ];
		}
	}

	SUPPRESS_WARNINGS_KEY_UNCHECKED
	public boolean containsKey( final KEY_TYPE k ) {
		if ( KEY_EQUALS_NULL( KEY_GENERIC_CAST k ) ) return containsNullKey;

		KEY_GENERIC_TYPE curr;
		final KEY_GENERIC_TYPE[] key = this.key;
		int pos;

		// The starting point.
		if ( KEY_IS_NULL( curr = key[ pos = KEY2INTHASH_CAST( k ) & mask ] ) ) return false;
		if ( KEY_EQUALS_NOT_NULL_CAST( k, curr ) ) return true;
		// There's always an unused entry.
		while( true ) {
			if ( KEY_IS_NULL( curr = key[ pos = ( pos + 1 ) & mask ] ) ) return false;
			if ( KEY_EQUALS_NOT_NULL_CAST( k, curr ) ) return true;
		}
	}


	public boolean containsValue( final VALUE_TYPE v ) {
		final VALUE_GENERIC_TYPE value[] = this.value;
		final KEY_GENERIC_TYPE key[] = this.key;
		if ( containsNullKey && VALUE_EQUALS( value[ n ], v ) ) return true;
		for( int i = n; i-- != 0; ) if ( ! KEY_IS_NULL( key[ i ] ) && VALUE_EQUALS( value[ i ], v ) ) return true;
		return false;
	}

	/* Removes all elements from this map.
	 *
	 * <P>To increase object reuse, this method does not change the table size.
	 * If you want to reduce the table size, you must use {@link #trim()}.
	 *
	 */
	public void clear() {
		if ( size == 0 ) return;
		size = 0;
		containsNullKey = false;

		Arrays.fill( key, KEY_NULL );
#if #values(reference)
		Arrays.fill( value, null );
#endif

#ifdef Linked
		first = last = -1;
#endif
	}

	public int size() {
		return size;
	}

	public boolean isEmpty() {
		return size == 0;
	}


	/** A no-op for backward compatibility.
	 * 
	 * @param growthFactor unused.
	 * @deprecated Since <code>fastutil</code> 6.1.0, hash tables are doubled when they are too full.
	 */
	@Deprecated
	public void growthFactor( int growthFactor ) {}


	/** Gets the growth factor (2).
	 *
	 * @return the growth factor of this set, which is fixed (2).
	 * @see #growthFactor(int)
	 * @deprecated Since <code>fastutil</code> 6.1.0, hash tables are doubled when they are too full.
	 */
	@Deprecated
	public int growthFactor() {
		return 16;
	}


	/** The entry class for a hash map does not record key and value, but
	 * rather the position in the hash table of the corresponding entry. This
	 * is necessary so that calls to {@link java.util.Map.Entry#setValue(Object)} are reflected in
	 * the map */

	final class MapEntry implements MAP.Entry KEY_VALUE_GENERIC, Map.Entry<KEY_GENERIC_CLASS, VALUE_GENERIC_CLASS> {
		// The table index this entry refers to, or -1 if this entry has been deleted.
		int index;
		
		MapEntry( final int index ) {
			this.index = index;
		}
		
		MapEntry() {}
		
#if #keys(primitive)
		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
#endif
		public KEY_GENERIC_CLASS getKey() {
			return KEY2OBJ( key[ index ] );
		}
		  
#if #keys(primitive)
		public KEY_TYPE ENTRY_GET_KEY() {
	   		return key[ index ];
		}
#endif

#if #values(primitive)
		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
#endif
		public VALUE_GENERIC_CLASS getValue() {
			return VALUE2OBJ( value[ index ] );
		}
		  
#if #values(primitive)
		public VALUE_GENERIC_TYPE ENTRY_GET_VALUE() {
			return value[ index ];
		}
#endif

		public VALUE_GENERIC_TYPE setValue( final VALUE_GENERIC_TYPE v ) {
			final VALUE_GENERIC_TYPE oldValue = value[ index ];
			value[ index ] = v;
			return oldValue;
		}
		  
#if #values(primitive)
		  
		public VALUE_GENERIC_CLASS setValue( final VALUE_GENERIC_CLASS v ) {
			return VALUE2OBJ( setValue( VALUE_CLASS2TYPE( v ) ) );
		}

#endif

		@SuppressWarnings("unchecked")
		public boolean equals( final Object o ) {
			if (!(o instanceof Map.Entry)) return false;
			Map.Entry<KEY_GENERIC_CLASS, VALUE_GENERIC_CLASS> e = (Map.Entry<KEY_GENERIC_CLASS, VALUE_GENERIC_CLASS>)o;
   				
			return KEY_EQUALS( key[ index ], KEY_CLASS2TYPE( e.getKey() ) ) && VALUE_EQUALS( value[ index ], VALUE_CLASS2TYPE( e.getValue() ) );
		}
		  
		public int hashCode() {
			return KEY2JAVAHASH( key[ index ] ) ^ VALUE2JAVAHASH( value[ index ] );
		}
		 
			  
		public String toString() {
			return key[ index ] + "=>" + value[ index ];
		}
	}


#ifdef Linked

	/** Modifies the {@link #link} vector so that the given entry is removed.
	 * This method will complete in constant time.
	 *
	 * @param i the index of an entry. 
	 */
	protected void fixPointers( final int i ) {
		if ( size == 0 ) {
			first = last = -1;
			return;
		}
		if ( first == i ) {
			first = GET_NEXT(link[ i ]);
			if (0 <= first) {
				// Special case of SET_PREV( link[ first ], -1 )
				link[ first ] |= (-1 & 0xFFFFFFFFL) << 32;
			}
			return;
		}
		if ( last == i ) {
			last = GET_PREV(link[ i ]);
			if (0 <= last) {
				// Special case of SET_NEXT( link[ last ], -1 )
				link[ last ] |= -1 & 0xFFFFFFFFL;
			}
			return;
		}
		final long linki = link[ i ];
		final int prev = GET_PREV(linki);
		final int next = GET_NEXT(linki);
		COPY_NEXT(link[ prev ], linki);
		COPY_PREV(link[ next ], linki);
	}


	/** Modifies the {@link #link} vector for a shift from s to d.
	 * <P>This method will complete in constant time.
	 *
	 * @param s the source position.
	 * @param d the destination position.
	 */
	protected void fixPointers( int s, int d ) {
		if ( size == 1 ) {
			first = last = d;
			// Special case of SET_UPPER_LOWER( link[ d ], -1, -1 )
			link[ d ] = -1L;
			return;
		}
		if ( first == s ) {
			first = d;
			SET_PREV( link[ GET_NEXT(link[ s ]) ], d );
			link[ d ] = link[ s ];
			return;
		}
		if ( last == s ) {
			last = d;
			SET_NEXT( link[ GET_PREV(link[ s ])], d );
			link[ d ] = link[ s ];
			return;
		}
		final long links = link[ s ];
		final int prev = GET_PREV(links);
		final int next = GET_NEXT(links);
		SET_NEXT( link[ prev ], d );
		SET_PREV( link[ next ], d );
		link[ d ] = links;
	}


	/** Returns the first key of this map in iteration order.
	 *
	 * @return the first key in iteration order.
	 */
	public KEY_GENERIC_TYPE FIRST_KEY() {
		if ( size == 0 ) throw new NoSuchElementException();
		return key[ first ];
	}


	/** Returns the last key of this map in iteration order.
	 *
	 * @return the last key in iteration order.
	 */
	public KEY_GENERIC_TYPE LAST_KEY() {
		if ( size == 0 ) throw new NoSuchElementException();
		return key[ last ];
	}

	public KEY_COMPARATOR KEY_SUPER_GENERIC comparator() { return null; }

	public SORTED_MAP KEY_VALUE_GENERIC tailMap( KEY_GENERIC_TYPE from ) { throw new UnsupportedOperationException(); }
	public SORTED_MAP KEY_VALUE_GENERIC headMap( KEY_GENERIC_TYPE to ) { throw new UnsupportedOperationException(); }
	public SORTED_MAP KEY_VALUE_GENERIC subMap( KEY_GENERIC_TYPE from, KEY_GENERIC_TYPE to ) { throw new UnsupportedOperationException(); }


	/** A list iterator over a linked map.
	 *
	 * <P>This class provides a list iterator over a linked hash map. The constructor runs in constant time.
	 */
	private class MapIterator {
		/** The entry that will be returned by the next call to {@link java.util.ListIterator#previous()} (or <code>null</code> if no previous entry exists). */
		int prev = -1;
		/** The entry that will be returned by the next call to {@link java.util.ListIterator#next()} (or <code>null</code> if no next entry exists). */
		int next = -1;
		/** The last entry that was returned (or -1 if we did not iterate or used {@link java.util.Iterator#remove()}). */
		int curr = -1;
		/** The current index (in the sense of a {@link java.util.ListIterator}). Note that this value is not meaningful when this iterator has been created using the nonempty constructor.*/
		int index = -1;

		private MapIterator() {
			next = first;
			index = 0;
		}

		private MapIterator( final KEY_GENERIC_TYPE from ) {
			if ( KEY_EQUALS_NULL( from ) ) {
				if ( OPEN_HASH_MAP.this.containsNullKey ) {
					next = GET_NEXT( link[ n ] );
					prev = n;
					return;
				}
				else throw new NoSuchElementException( "The key " + from + " does not belong to this map." );
			}

			if ( KEY_EQUALS( key[ last ], from ) ) {
				prev = last;
				index = size;
				return;
			}

			// The starting point.
			int pos = KEY2INTHASH( from ) & mask;

			// There's always an unused entry.
			while( ! KEY_IS_NULL( key[ pos ] ) ) {
				if ( KEY_EQUALS_NOT_NULL( key[ pos ], from ) ) {
					// Note: no valid index known.
					next = GET_NEXT( link[ pos ] );
					prev = pos;
					return;
				}
				pos = ( pos + 1 ) & mask;
			}
			throw new NoSuchElementException( "The key " + from + " does not belong to this map." );
		}
					 
		public boolean hasNext() { return next != -1; }
		public boolean hasPrevious() { return prev != -1; }

		private final void ensureIndexKnown() {
			if ( index >= 0 ) return;
			if ( prev == -1 ) {
				index = 0;
				return;
			}
			if ( next == -1 ) {
				index = size;
				return;
			}
			int pos = first;
			index = 1;
			while( pos != prev ) {
				pos = GET_NEXT( link[ pos ] );
				index++;
			}
		}

		public int nextIndex() {
			ensureIndexKnown();
			return index;
		}

		public int previousIndex() {
			ensureIndexKnown();
			return index - 1;
		}

					 
		public int nextEntry() {
			if ( ! hasNext() ) throw new NoSuchElementException();

			curr = next;
			next = GET_NEXT(link[ curr ]);
			prev = curr;

			if ( index >= 0 ) index++;

			return curr;
		}

		public int previousEntry() {
			if ( ! hasPrevious() ) throw new NoSuchElementException();

			curr = prev;
			prev = GET_PREV(link[ curr ]);
			next = curr;

			if ( index >= 0 ) index--;

			return curr;
		}
		
		public void remove() {
			ensureIndexKnown();
			if ( curr == -1 ) throw new IllegalStateException();

			if ( curr == prev ) {
				/* If the last operation was a next(), we are removing an entry that preceeds
				   the current index, and thus we must decrement it. */
				index--;
				prev = GET_PREV(link[ curr ]);
			}
			else 
				next = GET_NEXT(link[ curr ]);

			size--;
			/* Now we manually fix the pointers. Because of our knowledge of next
			   and prev, this is going to be faster than calling fixPointers(). */
			if ( prev == -1 ) first = next;
			else 
				SET_NEXT( link[ prev ], next );
			if ( next == -1 ) last = prev;
			else
				SET_PREV( link[ next ], prev );

			int last, slot, pos = curr;
			curr = -1;

			if ( pos == n ) {
				OPEN_HASH_MAP.this.containsNullKey = false;
#if #keys(reference)
				key[ n ] = null;
#endif
#if #values(reference)
				value[ n ] = null;
#endif
			}
			else {
				KEY_GENERIC_TYPE curr;
				final KEY_GENERIC_TYPE[] key = OPEN_HASH_MAP.this.key;
				// We have to horribly duplicate the shiftKeys() code because we need to update next/prev.			
				for(;;) {
					pos = ( ( last = pos ) + 1 ) & mask;
					for(;;) {
						if ( KEY_IS_NULL( curr = key[ pos ] ) ) {
							key[ last ] = KEY_NULL;
#if #values(reference)
							value[ last ] = null;
#endif
							return;
						}
						slot = KEY2INTHASH( curr ) & mask;
						if ( last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos ) break;
						pos = ( pos + 1 ) & mask;
					}
	
					key[ last ] = curr;			
					value[ last ] = value[ pos ];			
					if ( next == pos ) next = last;
					if ( prev == pos ) prev = last;
					fixPointers( pos, last );
				}
			}
		}

		public int skip( final int n ) { 
			int i = n;
			while( i-- != 0 && hasNext() ) nextEntry(); 
			return n - i - 1;
		}

		public int back( final int n ) { 
			int i = n;
			while( i-- != 0 && hasPrevious() ) previousEntry(); 
			return n - i - 1;
		}
	}

	private class EntryIterator extends MapIterator implements ObjectListIterator<MAP.Entry KEY_VALUE_GENERIC> {
		private MapEntry entry;
	
		public EntryIterator() {}

		public EntryIterator( KEY_GENERIC_TYPE from ) {
			super( from );
		}

		public MapEntry next() {
			return entry = new MapEntry( nextEntry() );
		}

		public MapEntry previous() {
			return entry = new MapEntry( previousEntry() );
		}
		
		@Override
		public void remove() {
			super.remove();
			entry.index = -1; // You cannot use a deleted entry.
		}

		public void set( MAP.Entry KEY_VALUE_GENERIC ok ) { throw new UnsupportedOperationException(); }
		public void add( MAP.Entry KEY_VALUE_GENERIC ok ) { throw new UnsupportedOperationException(); }
	}

	private class FastEntryIterator extends MapIterator implements ObjectListIterator<MAP.Entry KEY_VALUE_GENERIC> {
		final MapEntry entry = new MapEntry();
	
		public FastEntryIterator() {}

		public FastEntryIterator( KEY_GENERIC_TYPE from ) {
			super( from );
		}

		public MapEntry next() {
			entry.index = nextEntry();
			return entry;
		}

		public MapEntry previous() {
			entry.index = previousEntry();
			return entry;
		}

		public void set( MAP.Entry KEY_VALUE_GENERIC ok ) { throw new UnsupportedOperationException(); }
		public void add( MAP.Entry KEY_VALUE_GENERIC ok ) { throw new UnsupportedOperationException(); }
	}

#else	 

	/** An iterator over a hash map. */

	private class MapIterator {
		/** The index of the last entry returned, if positive or zero; initially, {@link #n}. If negative, the last
			entry returned was that of the key of index {@code - pos - 1} from the {@link #wrapped} list. */
		int pos = n;
		/** The index of the last entry that has been returned (more precisely, the value of {@link #pos} if {@link #pos} is positive,
			or {@link Integer#MIN_VALUE} if {@link #pos} is negative). It is -1 if either
			we did not return an entry yet, or the last returned entry has been removed. */
		int last = -1;
		/** A downward counter measuring how many entries must still be returned. */
		int c = size;
		/** A boolean telling us whether we should return the entry with the null key. */
		boolean mustReturnNullKey = OPEN_HASH_MAP.this.containsNullKey;
		/** A lazily allocated list containing keys of entries that have wrapped around the table because of removals. */
		ARRAY_LIST KEY_GENERIC wrapped;
		
		public boolean hasNext() {
			return c != 0;
		}

		public int nextEntry() {
			if ( ! hasNext() ) throw new NoSuchElementException();

			c--;
			if ( mustReturnNullKey ) {
				mustReturnNullKey = false;
				return last = n;
			}
                       
			final KEY_GENERIC_TYPE key[] = OPEN_HASH_MAP.this.key;

			for(;;) {
				if ( --pos < 0 ) {
					// We are just enumerating elements from the wrapped list.
					last = Integer.MIN_VALUE;
					final KEY_GENERIC_TYPE k = wrapped.GET_KEY( - pos - 1 );
					int p = KEY2INTHASH( k ) & mask;
					while ( ! KEY_EQUALS_NOT_NULL( k, key[ p ] ) ) p = ( p + 1 ) & mask;
					return p;
				}
				if ( ! KEY_IS_NULL( key[ pos ] ) ) return last = pos;
			}
		}

		/** Shifts left entries with the specified hash code, starting at the specified position,
		 * and empties the resulting free entry.
		 *
		 * @param pos a starting position.
		 */
		private final void shiftKeys( int pos ) {
			// Shift entries with the same hash.
			int last, slot;
			KEY_GENERIC_TYPE curr;
			final KEY_GENERIC_TYPE[] key = OPEN_HASH_MAP.this.key;
	
			for(;;) {
				pos = ( ( last = pos ) + 1 ) & mask;
				
				for(;;) {
					if ( KEY_IS_NULL( curr = key[ pos ] ) ) {
						key[ last ] = KEY_NULL;
#if #values(reference)
						value[ last ] = null;
#endif
						return;
					}
					slot = KEY2INTHASH( curr ) & mask;
					if ( last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos ) break;
					pos = ( pos + 1 ) & mask;
				}
	
				if ( pos < last ) { // Wrapped entry.
					if ( wrapped == null ) wrapped = new ARRAY_LIST KEY_GENERIC( 2 );
					wrapped.add( key[ pos ] );
				}

				key[ last ] = curr;
				value[ last ] = value[ pos ];	
			}
		}
	
		public void remove() {
			if ( last == -1 ) throw new IllegalStateException();
			if ( last == n ) {
				containsNullKey = false;
#if #keys(reference)
				key[ n ] = null;
#endif
#if #values(reference)
				value[ n ] = null;
#endif
			}
			else if ( pos >= 0 ) shiftKeys( last );
			else {
				// We're removing wrapped entries.
#if #keys(reference)
				OPEN_HASH_MAP.this.remove( wrapped.set( - pos - 1, null ) );
#else
				OPEN_HASH_MAP.this.remove( wrapped.GET_KEY( - pos - 1 ) );
#endif
				last = -1; // Note that we must not decrement size
				return;
			}

			size--;
			last = -1; // You can no longer remove this entry.
			if ( ASSERTS ) checkTable();
		}

		public int skip( final int n ) { 
			int i = n;
			while( i-- != 0 && hasNext() ) nextEntry(); 
			return n - i - 1;
		}
	}


	private class EntryIterator extends MapIterator implements ObjectIterator<MAP.Entry KEY_VALUE_GENERIC> {
		private MapEntry entry;
	
		public MAP.Entry KEY_VALUE_GENERIC next() {
			return entry = new MapEntry( nextEntry() );
		}

		@Override
		public void remove() {
			super.remove();
			entry.index = -1; // You cannot use a deleted entry.
		}
	}

	private class FastEntryIterator extends MapIterator implements ObjectIterator<MAP.Entry KEY_VALUE_GENERIC> {
		private final MapEntry entry = new MapEntry();
		public MapEntry next() {
			entry.index = nextEntry();
			return entry;
		}
	}

#endif





#ifdef Linked
	private final class MapEntrySet extends AbstractObjectSortedSet<MAP.Entry KEY_VALUE_GENERIC> implements FastSortedEntrySet KEY_VALUE_GENERIC {

		public ObjectBidirectionalIterator<MAP.Entry KEY_VALUE_GENERIC> iterator() {
			return new EntryIterator();
		}

		public Comparator<? super MAP.Entry KEY_VALUE_GENERIC> comparator() { return null; }
		public ObjectSortedSet<MAP.Entry KEY_VALUE_GENERIC> subSet( MAP.Entry KEY_VALUE_GENERIC fromElement, MAP.Entry KEY_VALUE_GENERIC toElement) { throw new UnsupportedOperationException(); }
		public ObjectSortedSet<MAP.Entry KEY_VALUE_GENERIC> headSet( MAP.Entry KEY_VALUE_GENERIC toElement ) { throw new UnsupportedOperationException(); }
		public ObjectSortedSet<MAP.Entry KEY_VALUE_GENERIC> tailSet( MAP.Entry KEY_VALUE_GENERIC fromElement ) { throw new UnsupportedOperationException(); }

		public MAP.Entry KEY_VALUE_GENERIC first() { 
			if ( size == 0 ) throw new NoSuchElementException();
			return new MapEntry( OPEN_HASH_MAP.this.first ); 
		}

		public MAP.Entry KEY_VALUE_GENERIC last() { 
			if ( size == 0 ) throw new NoSuchElementException();
			return new MapEntry( OPEN_HASH_MAP.this.last ); 
		}
		
#else
	private final class MapEntrySet extends AbstractObjectSet<MAP.Entry KEY_VALUE_GENERIC> implements FastEntrySet KEY_VALUE_GENERIC {

		public ObjectIterator<MAP.Entry KEY_VALUE_GENERIC> iterator() {
			return new EntryIterator();
		}

		public ObjectIterator<MAP.Entry KEY_VALUE_GENERIC> fastIterator() {
			return new FastEntryIterator();
		}
#endif					 
					 
		@SuppressWarnings("unchecked")
		public boolean contains( final Object o ) {
			if ( !( o instanceof Map.Entry ) ) return false;
			final Map.Entry<KEY_GENERIC_CLASS, VALUE_GENERIC_CLASS> e = (Map.Entry<KEY_GENERIC_CLASS, VALUE_GENERIC_CLASS>)o;

			final KEY_GENERIC_TYPE k = KEY_CLASS2TYPE( e.getKey() );
			
			if ( KEY_EQUALS_NULL( k ) ) return ( OPEN_HASH_MAP.this.containsNullKey && VALUE_EQUALS( value[ n ], VALUE_CLASS2TYPE( e.getValue() ) ) );

			KEY_GENERIC_TYPE curr;
			final KEY_GENERIC_TYPE[] key = OPEN_HASH_MAP.this.key;
			int pos;

			// The starting point.
			if ( KEY_IS_NULL( curr = key[ pos = KEY2INTHASH( k ) & mask ] ) ) return false;
			if ( KEY_EQUALS_NOT_NULL( k, curr ) ) return VALUE_EQUALS( value[ pos ], VALUE_CLASS2TYPE( e.getValue() ) );
			// There's always an unused entry.
			while( true ) {
				if ( KEY_IS_NULL( curr = key[ pos = ( pos + 1 ) & mask ] ) ) return false;
				if ( KEY_EQUALS_NOT_NULL( k, curr ) ) return VALUE_EQUALS( value[ pos ], VALUE_CLASS2TYPE( e.getValue() ) );
			}
		}
			 
		@SuppressWarnings("unchecked")
		public boolean remove( final Object o ) {
			if ( !( o instanceof Map.Entry ) ) return false;
			final Map.Entry<KEY_GENERIC_CLASS, VALUE_GENERIC_CLASS> e = (Map.Entry<KEY_GENERIC_CLASS, VALUE_GENERIC_CLASS>)o;

			final KEY_GENERIC_TYPE k = KEY_CLASS2TYPE( e.getKey() );
			final VALUE_GENERIC_TYPE v = VALUE_CLASS2TYPE( e.getValue() );

			if ( KEY_EQUALS_NULL( k ) ) {
				if ( containsNullKey && VALUE_EQUALS( value[ n ], v ) ) {
					removeNullEntry();
					return true;
				}
				return false;
			}
       
			KEY_GENERIC_TYPE curr;
			final KEY_GENERIC_TYPE[] key = OPEN_HASH_MAP.this.key;
			int pos;

			// The starting point.
			if ( KEY_IS_NULL( curr = key[ pos = KEY2INTHASH( k ) & mask ] ) ) return false;
			if ( KEY_EQUALS_NOT_NULL( curr, k ) ) {
				if ( VALUE_EQUALS( value[ pos ], v ) ) {
					removeEntry( pos );
					return true;
				}
				return false;
			}
				
			while( true ) {
				if ( KEY_IS_NULL( curr = key[ pos = ( pos + 1 ) & mask ] ) ) return false;
				if ( KEY_EQUALS_NOT_NULL( curr, k ) )  {
					if ( VALUE_EQUALS( value[ pos ], v ) ) {
						removeEntry( pos );
						return true;
					}
				}
			}
		}

		public MAP.Entry KEY_VALUE_GENERIC pop() {
			if ( containsNullKey ) {
				VALUE_GENERIC_TYPE v = removeNullEntry();
				return new BasicEntry KEY_VALUE_GENERIC ( KEY_NULL, v );
			}
			int pos = n;
			final KEY_GENERIC_TYPE key[] = OPEN_HASH_MAP.this.key;
			for(;;) {
				if ( --pos < 0 ) {
					throw new NoSuchElementException();
				}
				KEY_GENERIC_TYPE k = key[ pos ];
				if ( ! KEY_IS_NULL( k ) ) {
					VALUE_GENERIC_TYPE v = value[ pos ];
					removeEntry( pos );
					return new BasicEntry KEY_VALUE_GENERIC ( k, v );
				}
			}
		}

		public int size() {
			return size;
		}
			 
		public void clear() {
			OPEN_HASH_MAP.this.clear();
		}

#ifdef Linked
		public ObjectBidirectionalIterator<MAP.Entry KEY_VALUE_GENERIC> iterator( final MAP.Entry KEY_VALUE_GENERIC from ) {
#if #keys(primitive)
			return new EntryIterator( from.ENTRY_GET_KEY() );
#else
			return new EntryIterator( KEY_CLASS2TYPE( from.getKey() ) );
#endif
		}

		public ObjectBidirectionalIterator<MAP.Entry KEY_VALUE_GENERIC> fastIterator() {
			return new FastEntryIterator();
		}
				
		public ObjectBidirectionalIterator<MAP.Entry KEY_VALUE_GENERIC> fastIterator( final MAP.Entry KEY_VALUE_GENERIC from ) {
#if #keys(primitive)
			return new FastEntryIterator( from.ENTRY_GET_KEY() );
#else
			return new FastEntryIterator( KEY_CLASS2TYPE( from.getKey() ) );
#endif
		}
				
#endif
	}


#ifdef Linked
	public FastSortedEntrySet KEY_VALUE_GENERIC ENTRYSET() {
		if ( entries == null ) entries = new MapEntrySet();
#else
	public FastEntrySet KEY_VALUE_GENERIC ENTRYSET() {
		if ( entries == null ) entries = new MapEntrySet();
#endif
		return entries;
	}


	/** An iterator on keys.
	 *
	 * <P>We simply override the {@link java.util.ListIterator#next()}/{@link java.util.ListIterator#previous()} methods
	 * (and possibly their type-specific counterparts) so that they return keys
	 * instead of entries.
	 */

#ifdef Linked
	private final class KeyIterator extends MapIterator implements KEY_LIST_ITERATOR KEY_GENERIC {
		public KeyIterator( final KEY_GENERIC_TYPE k ) { super( k ); }
		public KEY_GENERIC_TYPE PREV_KEY() { return key[ previousEntry() ]; }
		public void set( KEY_GENERIC_TYPE k ) { throw new UnsupportedOperationException(); }
		public void add( KEY_GENERIC_TYPE k ) { throw new UnsupportedOperationException(); }
#if ! #keys(reference)
		public KEY_GENERIC_CLASS previous() { return KEY2OBJ( key[ previousEntry() ] ); }
		public void set( KEY_CLASS ok ) { throw new UnsupportedOperationException(); }
		public void add( KEY_CLASS ok ) { throw new UnsupportedOperationException(); }
#endif

#else
	private final class KeyIterator extends MapIterator implements KEY_ITERATOR KEY_GENERIC {
#endif

		public KeyIterator() { super(); }
		public KEY_GENERIC_TYPE NEXT_KEY() { return key[ nextEntry() ]; }
#if ! #keys(reference)
		public KEY_GENERIC_CLASS next() { return KEY2OBJ( key[ nextEntry() ] ); }
#endif
	}



#ifdef Linked
	private final class KeySet extends ABSTRACT_SORTED_SET KEY_GENERIC {

		public KEY_LIST_ITERATOR KEY_GENERIC iterator( final KEY_GENERIC_TYPE from ) {
			return new KeyIterator( from );
		}

		public KEY_LIST_ITERATOR KEY_GENERIC iterator() {
			return new KeyIterator();
		}
#else
	private final class KeySet extends ABSTRACT_SET KEY_GENERIC {

		public KEY_ITERATOR KEY_GENERIC iterator() {
			return new KeyIterator();
		}
#endif

		public int size() {
			return size;
		}

		public boolean contains( KEY_TYPE k ) {
			return containsKey( k );
		}
					 
		public boolean remove( KEY_TYPE k ) {
			final int oldSize = size;
			OPEN_HASH_MAP.this.remove( k );
			return size != oldSize;
		}
					 
		public void clear() {
			OPEN_HASH_MAP.this.clear();
		}

		public KEY_GENERIC_TYPE POP() {
			if ( containsNullKey ) {
				removeNullEntry();
				return KEY_NULL;
			}
			int pos = n;
			final KEY_GENERIC_TYPE key[] = OPEN_HASH_MAP.this.key;
			for(;;) {
				if ( --pos < 0 ) {
					throw new NoSuchElementException();
				}
				KEY_GENERIC_TYPE k = key[ pos ];
				if ( ! KEY_IS_NULL( k ) ) {
					removeEntry( pos );
					return k;
				}
			}
		}

#ifdef Linked
		public KEY_GENERIC_TYPE FIRST() {
			if ( size == 0 ) throw new NoSuchElementException();
			return key[ first ];
		}

		public KEY_GENERIC_TYPE LAST() {
			if ( size == 0 ) throw new NoSuchElementException();
			return key[ last ];
		}

		public KEY_COMPARATOR KEY_SUPER_GENERIC comparator() { return null; }

		final public SORTED_SET KEY_GENERIC tailSet( KEY_GENERIC_TYPE from ) { throw new UnsupportedOperationException(); }
		final public SORTED_SET KEY_GENERIC headSet( KEY_GENERIC_TYPE to ) { throw new UnsupportedOperationException(); }
		final public SORTED_SET KEY_GENERIC subSet( KEY_GENERIC_TYPE from, KEY_GENERIC_TYPE to ) { throw new UnsupportedOperationException(); }
#endif
	}


#ifdef Linked
	public SORTED_SET KEY_GENERIC keySet() {
#else
	public SET KEY_GENERIC keySet() {
#endif
		if ( keys == null ) keys = new KeySet();
		return keys;
	}


	/** An iterator on values.
	 *
	 * <P>We simply override the {@link java.util.ListIterator#next()}/{@link java.util.ListIterator#previous()} methods
	 * (and possibly their type-specific counterparts) so that they return values
	 * instead of entries.
	 */

#ifdef Linked
	private final class ValueIterator extends MapIterator implements VALUE_LIST_ITERATOR VALUE_GENERIC {
		public VALUE_GENERIC_TYPE PREV_VALUE() { return value[ previousEntry() ]; }

#if ! #values(reference)
		public VALUE_GENERIC_CLASS previous() { return VALUE2OBJ( value[ previousEntry() ] ); }
		public void set( VALUE_CLASS ok ) { throw new UnsupportedOperationException(); }
		public void add( VALUE_CLASS ok ) { throw new UnsupportedOperationException(); }
#endif									
		public void set( VALUE_GENERIC_TYPE v ) { throw new UnsupportedOperationException(); }
		public void add( VALUE_GENERIC_TYPE v ) { throw new UnsupportedOperationException(); }
#else
	private final class ValueIterator extends MapIterator implements VALUE_ITERATOR VALUE_GENERIC {
#endif

		public ValueIterator() { super(); }
		public VALUE_GENERIC_TYPE NEXT_VALUE() { return value[ nextEntry() ]; }
#if ! #values(reference)
		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public VALUE_GENERIC_CLASS next() { return VALUE2OBJ( value[ nextEntry() ] ); }
#endif
	}

	public VALUE_COLLECTION VALUE_GENERIC values() {
		if ( values == null ) values = new VALUE_ABSTRACT_COLLECTION VALUE_GENERIC() {

				public VALUE_ITERATOR VALUE_GENERIC iterator() {
					return new ValueIterator();
				}

				public int size() {
					return size;
				}

				public boolean contains( VALUE_TYPE v ) {
					return containsValue( v );
				}

				public void clear() {
					OPEN_HASH_MAP.this.clear();
				}
			};

		return values;
	}


	/** A no-op for backward compatibility. The kind of tables implemented by
	 * this class never need rehashing.
	 *
	 * <P>If you need to reduce the table size to fit exactly
	 * this set, use {@link #trim()}.
	 *
	 * @return true.
	 * @see #trim()
	 * @deprecated A no-op.
	 */

	@Deprecated
	public boolean rehash() {
		return true;
	}


	/** Rehashes the map, making the table as small as possible.
	 * 
	 * <P>This method rehashes the table to the smallest size satisfying the
	 * load factor. It can be used when the set will not be changed anymore, so
	 * to optimize access speed and size.
	 *
	 * <P>If the table size is already the minimum possible, this method
	 * does nothing. 
	 *
	 * @return true if there was enough memory to trim the map.
	 * @see #trim(int)
	 */

	public boolean trim() {
		final int l = arraySize( size, f );
		if ( l >= n || size > maxFill( l, f ) ) return true;
		try {
			rehash( l );
		}
		catch(OutOfMemoryError cantDoIt) { return false; }
		return true;
	}


	/** Rehashes this map if the table is too large.
	 * 
	 * <P>Let <var>N</var> be the smallest table size that can hold
	 * <code>max(n,{@link #size()})</code> entries, still satisfying the load factor. If the current
	 * table size is smaller than or equal to <var>N</var>, this method does
	 * nothing. Otherwise, it rehashes this map in a table of size
	 * <var>N</var>.
	 *
	 * <P>This method is useful when reusing maps.  {@linkplain #clear() Clearing a
	 * map} leaves the table size untouched. If you are reusing a map
	 * many times, you can call this method with a typical
	 * size to avoid keeping around a very large table just
	 * because of a few large transient maps.
	 *
	 * @param n the threshold for the trimming.
	 * @return true if there was enough memory to trim the map.
	 * @see #trim()
	 */

	public boolean trim( final int n ) {
		final int l = HashCommon.nextPowerOfTwo( (int)Math.ceil( n / f ) );
		if ( this.n <= l ) return true;
		try {
			rehash( l );
		}
		catch( OutOfMemoryError cantDoIt ) { return false; }
		return true;
	}

	/** Rehashes the map.
	 *
	 * <P>This method implements the basic rehashing strategy, and may be
	 * overriden by subclasses implementing different rehashing strategies (e.g.,
	 * disk-based rehashing). However, you should not override this method
	 * unless you understand the internal workings of this class.
	 *
	 * @param newN the new size
	 */

	SUPPRESS_WARNINGS_KEY_VALUE_UNCHECKED
	protected void rehash( final int newN ) {
		final KEY_GENERIC_TYPE key[] = this.key;
		final VALUE_GENERIC_TYPE value[] = this.value;

		final int mask = newN - 1; // Note that this is used by the hashing macro
		final KEY_GENERIC_TYPE newKey[] = KEY_GENERIC_ARRAY_CAST new KEY_TYPE[ newN + 1 ];
		final VALUE_GENERIC_TYPE newValue[] = VALUE_GENERIC_ARRAY_CAST new VALUE_TYPE[ newN + 1 ];

#ifdef Linked
		int i = first, prev = -1, newPrev = -1, t, pos;
		final long link[] = this.link;
		final long newLink[] = new long[ newN + 1 ];
		first = -1;

		for( int j = size; j-- != 0; ) {
			if ( KEY_EQUALS_NULL( key[ i ] ) ) pos = newN;
			else {
				pos = KEY2INTHASH( key[ i ] ) & mask;
				while ( ! KEY_IS_NULL( newKey[ pos ] ) ) pos = ( pos + 1 ) & mask;
			}

			newKey[ pos ] = key[ i ];
			newValue[ pos ] = value[ i ];

			if ( prev != -1 ) {
				SET_NEXT( newLink[ newPrev ], pos );
				SET_PREV( newLink[ pos ], newPrev );
				newPrev = pos;
			}
			else {
				newPrev = first = pos;
				// Special case of SET(newLink[ pos ], -1, -1);
				newLink[ pos ] = -1L;
			}

			t = i;
			i = GET_NEXT(link[ i ]);
			prev = t;
		}

		this.link = newLink;
		this.last = newPrev;
		if ( newPrev != -1 )
			// Special case of SET_NEXT( newLink[ newPrev ], -1 );
			newLink[ newPrev ] |= -1 & 0xFFFFFFFFL;
#else 
		int i = n, pos;

		for( int j = realSize(); j-- != 0; ) {
			while( KEY_IS_NULL( key[ --i ] ) );
		
			if ( ! KEY_IS_NULL( newKey[ pos = KEY2INTHASH( key[ i ] ) & mask ] ) ) 
				while ( ! KEY_IS_NULL( newKey[ pos = ( pos + 1 ) & mask ] ) );
				
			newKey[ pos ] = key[ i ];
			newValue[ pos ] = value[ i ];
		}
		
		newValue[ newN ] = value[ n ];

#endif

		n = newN;
		this.mask = mask;
		maxFill = maxFill( n, f );
		this.key = newKey;
		this.value = newValue;
	}
	 

	/** Returns a deep copy of this map. 
	 *
	 * <P>This method performs a deep copy of this hash map; the data stored in the
	 * map, however, is not cloned. Note that this makes a difference only for object keys.
	 *
	 *  @return a deep copy of this map.
	 */

	SUPPRESS_WARNINGS_KEY_VALUE_UNCHECKED
	public OPEN_HASH_MAP KEY_VALUE_GENERIC clone() {
		OPEN_HASH_MAP KEY_VALUE_GENERIC c;
		try {
			c = (OPEN_HASH_MAP KEY_VALUE_GENERIC)super.clone();
		}
		catch(CloneNotSupportedException cantHappen) {
			throw new InternalError();
		}

		c.keys = null;
		c.values = null;
		c.entries = null;
		c.containsNullKey = containsNullKey;

		c.key = key.clone();
		c.value = value.clone();
#ifdef Linked
		c.link = link.clone();
#endif
#ifdef Custom
		c.strategy = strategy;
#endif
		return c;
	}


	/** Returns a hash code for this map.
	 *
	 * This method overrides the generic method provided by the superclass. 
	 * Since <code>equals()</code> is not overriden, it is important
	 * that the value returned by this method is the same value as
	 * the one returned by the overriden method.
	 *
	 * @return a hash code for this map.
	 */

	public int hashCode() {
		int h = 0;
		for( int j = realSize(), i = 0, t = 0; j-- != 0; ) {
			while( KEY_IS_NULL( key[ i ] ) ) i++;
#if #keys(reference)
			if ( this != key[ i ] )
#endif
				t = KEY2JAVAHASH_NOT_NULL( key[ i ] );
#if #values(reference)
			if ( this != value[ i ] )
#endif
				t ^=  VALUE2JAVAHASH( value[ i ] );
			h += t;
			i++;
		}
		// Zero / null keys have hash zero.		
		if ( containsNullKey ) h += VALUE2JAVAHASH( value[ n ] );
		return h;
	}



	private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {
		final KEY_GENERIC_TYPE key[] = this.key;
		final VALUE_GENERIC_TYPE value[] = this.value;
		final MapIterator i = new MapIterator();

		s.defaultWriteObject();

		for( int j = size, e; j-- != 0; ) {
			e = i.nextEntry();
			s.WRITE_KEY( key[ e ] );
			s.WRITE_VALUE( value[ e ] );
		}
	}



	SUPPRESS_WARNINGS_KEY_VALUE_UNCHECKED
	private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {
		s.defaultReadObject();

		n = arraySize( size, f );
		maxFill = maxFill( n, f );
		mask = n - 1;
		
		final KEY_GENERIC_TYPE key[] = this.key = KEY_GENERIC_ARRAY_CAST new KEY_TYPE[ n + 1 ];
		final VALUE_GENERIC_TYPE value[] = this.value = VALUE_GENERIC_ARRAY_CAST new VALUE_TYPE[ n + 1 ];
#ifdef Linked
		final long link[] = this.link = new long[ n + 1 ];
		int prev = -1;
		first = last = -1;
#endif

		KEY_GENERIC_TYPE k;
		VALUE_GENERIC_TYPE v;

		for( int i = size, pos; i-- != 0; ) {

			k = KEY_GENERIC_CAST s.READ_KEY();
			v = VALUE_GENERIC_CAST s.READ_VALUE();

			if ( KEY_EQUALS_NULL( k ) ) {
				pos = n;
				containsNullKey = true;
			}
			else {
				pos = KEY2INTHASH( k ) & mask;
				while ( ! KEY_IS_NULL( key[ pos ] ) ) pos = ( pos + 1 ) & mask;
			}

			key[ pos ] = k;
			value[ pos ] = v;
			
#ifdef Linked
			if ( first != -1 ) {
				SET_NEXT( link[ prev ], pos );
				SET_PREV( link[ pos ], prev );
				prev = pos;
			}
			else {
				prev = first = pos;
				// Special case of SET_PREV( newLink[ pos ], -1 );
				link[ pos ] |= (-1L & 0xFFFFFFFFL) << 32;
			}
#endif
		}

#ifdef Linked
		last = prev;
		if ( prev != -1 ) 
			// Special case of SET_NEXT( link[ prev ], -1 );
			link[ prev ] |= -1 & 0xFFFFFFFFL; 
#endif

		if ( ASSERTS ) checkTable();
	}



#ifdef ASSERTS_CODE
	private void checkTable() {
		assert ( n & -n ) == n : "Table length is not a power of two: " + n;
		assert n == key.length - 1;
		int n = key.length - 1;
		while( n-- != 0 ) 
			if ( ! KEY_IS_NULL( key[ n ] ) && ! containsKey( key[ n ] ) ) 
				throw new AssertionError( "Hash table has key " + key[ n ] + " marked as occupied, but the key does not belong to the table" );

#if #keys(primitive)
		java.util.HashSet<KEY_GENERIC_CLASS> s = new java.util.HashSet<KEY_GENERIC_CLASS> ();
#else
		java.util.HashSet<Object> s = new java.util.HashSet<Object>();
#endif
		
		for( int i = key.length; i-- != 0; )
			if ( ! KEY_IS_NULL( key[ i ] ) && ! s.add( key[ i ] ) ) throw new AssertionError( "Key " + key[ i ] + " appears twice at position " + i );

#ifdef Linked
		KEY_BIDI_ITERATOR KEY_GENERIC i = keySet().iterator();
		KEY_GENERIC_TYPE k;
		n = size();
		while( n-- != 0 ) 
			if ( ! containsKey( k = i.NEXT_KEY() ) ) 
				throw new AssertionError( "Linked hash table forward enumerates key " + k + ", but the key does not belong to the table" );

		if ( i.hasNext() ) throw new AssertionError( "Forward iterator not exhausted" );

		n = size();
		if ( n > 0 ) {
			i = keySet().iterator( LAST_KEY() );
			while( n-- != 0 ) 
				if ( ! containsKey( k = i.PREV_KEY() ) ) 
					throw new AssertionError( "Linked hash table backward enumerates key " + k + ", but the key does not belong to the table" );
			
			if ( i.hasPrevious() ) throw new AssertionError( "Previous iterator not exhausted" );
		}
#endif
	}
#else
	private void checkTable() {}
#endif


#ifdef TEST

	private static long seed = System.currentTimeMillis(); 
	private static java.util.Random r = new java.util.Random( seed );

	private static KEY_TYPE genKey() {
#if #keyclass(Byte) || #keyclass(Short) || #keyclass(Character)
		return (KEY_TYPE)(r.nextInt());
#elif #keys(primitive)
		return r.NEXT_KEY(); 
#elif !#keyclass(Reference)
#ifdef Custom
		int i = r.nextInt( 3 );
		byte a[] = new byte[ i ];
		while( i-- != 0 ) a[ i ] = (byte)r.nextInt();
		return a;
#else
		return Integer.toBinaryString( r.nextInt() );
#endif
#else
		return new java.io.Serializable() {};
#endif
	}

	private static VALUE_TYPE genValue() {
#if #valueclass(Byte) || #valueclass(Short) || #valueclass(Character)
		return (VALUE_TYPE)(r.nextInt());
#elif #values(primitive)
		return r.NEXT_VALUE();
#elif !#valueclass(Reference)
		return Integer.toBinaryString( r.nextInt() );
#else
		return new java.io.Serializable() {};
#endif
	}

	private static final class ArrayComparator implements java.util.Comparator {
		public int compare( Object a, Object b ) {
			byte[] aa = (byte[])a;
			byte[] bb = (byte[])b;
			int length = Math.min( aa.length, bb.length );
			for( int i = 0; i < length; i++ ) {
				if ( aa[ i ] < bb[ i ] ) return -1;
				if ( aa[ i ] > bb[ i ] ) return 1;
			}
			return aa.length == bb.length ? 0 : ( aa.length < bb.length ? -1 : 1 );
		}
	}

	private static final class MockMap extends java.util.TreeMap {
		private java.util.List list = new java.util.ArrayList();

		public MockMap( java.util.Comparator c ) { super( c ); }

		public Object put( Object k, Object v ) {
			if ( ! containsKey( k ) ) list.add( k );
			return super.put( k, v );
		}

		public void putAll( Map m ) {
			java.util.Iterator i = m.entrySet().iterator();
			while( i.hasNext() ) {
				Map.Entry e = (Map.Entry)i.next();
				put( e.getKey(), e.getValue() );
			}
		}

		public Object remove( Object k ) {
			if ( containsKey( k ) ) {
				int i = list.size();
				while( i-- != 0 ) if ( comparator().compare( list.get( i ), k ) == 0 ) {
					list.remove( i );
					break;
				}
			}
			return super.remove( k );
		}

		private void justRemove( Object k ) { super.remove( k ); }
		private java.util.Set justEntrySet() { return super.entrySet(); }
		private java.util.Set justKeySet() { return super.keySet(); }

		public java.util.Set keySet() {
			return new java.util.AbstractSet() {
					final java.util.Set keySet = justKeySet();
					
					public boolean contains( Object k ) { return keySet.contains( k ); }
					public int size() { return keySet.size(); }
					public java.util.Iterator iterator() {
						return new java.util.Iterator() {
								final java.util.Iterator iterator = list.iterator();
								Object curr;
								public Object next() { return curr = iterator.next(); }
								public boolean hasNext() { return iterator.hasNext(); }
								public void remove() { 
									justRemove( curr );
									iterator.remove(); 
								}
							};

					}
				};

		}

		public java.util.Set entrySet() {
			return new java.util.AbstractSet() {
					final java.util.Set entrySet = justEntrySet();
					
					public boolean contains( Object k ) { return entrySet.contains( k ); }
					public int size() { return entrySet.size(); }
					public java.util.Iterator iterator() {
						return new java.util.Iterator() {
								final java.util.Iterator iterator = list.iterator();
								Object curr;
								public Object next() { 
									curr = iterator.next();
#if #valueclass(Reference)
#if #keyclass(Reference)
									return new ABSTRACT_MAP.BasicEntry( (Object)curr, (Object)get(curr) ) {
#else
									return new ABSTRACT_MAP.BasicEntry( (KEY_CLASS)curr, (Object)get(curr) ) {
#endif
#else
#if #keyclass(Reference)
									return new ABSTRACT_MAP.BasicEntry( (Object)curr, (VALUE_CLASS)get(curr) ) {
#else
									return new ABSTRACT_MAP.BasicEntry( (KEY_CLASS)curr, (VALUE_CLASS)get(curr) ) {
#endif
#endif
											public VALUE_TYPE setValue( VALUE_TYPE v ) {
												return VALUE_OBJ2TYPE(put( getKey(), VALUE2OBJ(v) ));
											}
										}; 
								}
								public boolean hasNext() { return iterator.hasNext(); }
								public void remove() { 
									justRemove( ((Map.Entry)curr).getKey() );
									iterator.remove(); 
								}
							};

					}
				};

		}

	}

	private static java.text.NumberFormat format = new java.text.DecimalFormat( "#,###.00" );
	private static java.text.FieldPosition fp = new java.text.FieldPosition( 0 );

	private static String format( double d ) {
		StringBuffer s = new StringBuffer();
		return format.format( d, s, fp ).toString();
	}


	private static void speedTest( int n, float f, boolean comp ) {
#ifndef Custom
		int i, j;
		OPEN_HASH_MAP m;
#ifdef Linked
		java.util.LinkedHashMap t;
#else
		java.util.HashMap t;
#endif
		KEY_TYPE k[] = new KEY_TYPE[n];
		KEY_TYPE nk[] = new KEY_TYPE[n];
		VALUE_TYPE v[] = new VALUE_TYPE[n];
		long ns;

		for( i = 0; i < n; i++ ) {
			k[i] = genKey();
			nk[i] = genKey();
			v[i] = genValue();
		}

		double totPut = 0, totYes = 0, totNo = 0, totIter = 0, totRemYes = 0, totRemNo = 0, d;

		if ( comp ) { for( j = 0; j < 20; j++ ) {

#ifdef Linked
			t = new java.util.LinkedHashMap( 16 );
#else
			t = new java.util.HashMap( 16 );
#endif

			/* We put pairs to t. */
			ns = System.nanoTime();
			for( i = 0; i < n;  i++ ) t.put( KEY2OBJ( k[i] ), VALUE2OBJ( v[i] ) );
			d = ( System.nanoTime() - ns ) / (double)n;
			if ( j > 2 ) totPut += d; 				
			System.out.print("Put: " + format( d ) + "ns " );

			/* We check for pairs in t. */
			ns = System.nanoTime();
			for( i = 0; i < n;  i++ ) t.containsKey( KEY2OBJ( k[i] ) );
			d = ( System.nanoTime() - ns ) / (double)n;
			if ( j > 2 ) totYes += d; 				
			System.out.print("Yes: " + format( d ) + "ns " );

			/* We check for pairs not in t. */
			ns = System.nanoTime();
			for( i = 0; i < n;  i++ ) t.containsKey( KEY2OBJ( nk[i] ) );
			d = ( System.nanoTime() - ns ) / (double)n;
			if ( j > 2 ) totNo += d; 				
			System.out.print("No: " + format( d ) + "ns " );

			/* We iterate on t. */
			ns = System.nanoTime();
			for( java.util.Iterator it = t.entrySet().iterator(); it.hasNext(); it.next() );
			d = ( System.nanoTime() - ns ) / (double)n;
			if ( j > 2 ) totIter += d; 				
			System.out.print("Iter: " + format( d ) + "ns " );
				
			/* We delete pairs not in t. */
			ns = System.nanoTime();
			for( i = 0; i < n;  i++ ) t.remove( KEY2OBJ( nk[i] ) );
			d = ( System.nanoTime() - ns ) / (double)n;
			if ( j > 2 ) totRemNo += d; 				
			System.out.print("RemNo: " + format( d ) + "ns " );
				
			/* We delete pairs in t. */
			ns = System.nanoTime();
			for( i = 0; i < n;  i++ ) t.remove( KEY2OBJ( k[i] ) );
			d = ( System.nanoTime() - ns ) / (double)n;
			if ( j > 2 ) totRemYes += d; 				
			System.out.print("RemYes: " + format( d ) + "ns " );
				
			System.out.println();
		}

		System.out.println();
		System.out.println( "java.util Put: " + format( totPut/(j-3) ) + "ns Yes: " + format( totYes/(j-3) ) + "ns No: " + format( totNo/(j-3) ) + "ns Iter: " + format( totIter/(j-3) ) + "ns RemNo: " + format( totRemNo/(j-3) ) + "ns RemYes: " + format( totRemYes/(j-3) ) + "K/s" );

		System.out.println();

		totPut = totYes = totNo = totIter = totRemYes = totRemNo = 0;

		}

		for( j = 0; j < 20; j++ ) {

			m = new OPEN_HASH_MAP( 16, f );

			/* We put pairs to m. */
			ns = System.nanoTime();
			for( i = 0; i < n;  i++ ) m.put( k[i], v[i] );
			d = ( System.nanoTime() - ns ) / (double)n;
			if ( j > 2 ) totPut += d; 				
			System.out.print("Put: " + format( d ) + "ns " );

			/* We check for pairs in m. */
			ns = System.nanoTime();
			for( i = 0; i < n;  i++ ) m.containsKey( k[i] );
			d = ( System.nanoTime() - ns ) / (double)n;
			if ( j > 2 ) totYes += d; 				
			System.out.print("Yes: " + format( d ) + "ns " );

			/* We check for pairs not in m. */
			ns = System.nanoTime();
			for( i = 0; i < n;  i++ ) m.containsKey( nk[i] );
			d = ( System.nanoTime() - ns ) / (double)n;
			if ( j > 2 ) totNo += d; 				
			System.out.print("No: " + format( d ) + "ns " );

			/* We iterate on m. */
			ns = System.nanoTime();
			for( java.util.Iterator it = m.entrySet().iterator(); it.hasNext(); it.next() );
			d = ( System.nanoTime() - ns ) / (double)n;
			if ( j > 2 ) totIter += d; 	 
			System.out.print("Iter: " + format( d ) + "ns " );

			/* We delete pairs not in m. */
			ns = System.nanoTime();
			for( i = 0; i < n;  i++ ) m.remove( nk[i] );
			d = ( System.nanoTime() - ns ) / (double)n;
			if ( j > 2 ) totRemNo += d; 	
			System.out.print("RemNo: " + format( d ) + "ns " );

			/* We delete pairs in m. */
			ns = System.nanoTime();
			for( i = 0; i < n;  i++ ) m.remove( k[i] );
			d = ( System.nanoTime() - ns ) / (double)n;
			if ( j > 2 ) totRemYes += d; 				
			System.out.print("RemYes: " + format( d ) + "ns " );	 

			System.out.println();
		}


		System.out.println();
		System.out.println( "fastutil  Put: " + format( totPut/(j-3) ) + "ns Yes: " + format( totYes/(j-3) ) + "ns No: " + format( totNo/(j-3) ) + "ns Iter: " + format( totIter/(j-3) ) + "ns RemNo: " + format( totRemNo/(j-3) ) + "ns RemYes: " + format( totRemYes/(j-3) ) + "ns" );

		System.out.println();
#endif
	}

	private static boolean valEquals(Object o1, Object o2) {
		return o1 == null ? o2 == null : o1.equals(o2);
	}

	private static void fatal( String msg ) {
		System.out.println( msg );
		System.exit( 1 );
	}

	private static void ensure( boolean cond, String msg ) {
		if ( cond ) return;
		fatal( msg );
	}

	protected static void test( int n, float f ) {
#if !defined(Custom) || #keys(reference)

#ifdef Custom
		OPEN_HASH_MAP m = new OPEN_HASH_MAP(Hash.DEFAULT_INITIAL_SIZE, f, it.unimi.dsi.fastutil.bytes.ByteArrays.HASH_STRATEGY);
#else
		OPEN_HASH_MAP m = new OPEN_HASH_MAP(Hash.DEFAULT_INITIAL_SIZE, f);
#endif

#ifdef Linked
#ifdef Custom
		Map t = new MockMap( new ArrayComparator() );
#else
		Map t = new java.util.LinkedHashMap();
#endif
#else
#ifdef Custom
		Map t = new java.util.TreeMap(new ArrayComparator());
#else
		Map t = new java.util.HashMap();
#endif
#endif

		/* First of all, we fill t with random data. */

		for(int i=0; i<n;  i++ ) t.put( KEY2OBJ(genKey()), VALUE2OBJ(genValue()) );
		  
		/* Now we add to m the same data */
		  
		m.putAll(t);

		if (!m.equals(t)) System.out.println("Error (" + seed + "): !m.equals(t) after insertion");
		if (!t.equals(m)) System.out.println("Error (" + seed + "): !t.equals(m) after insertion");

		/* Now we check that m actually holds that data. */
		  
		for(java.util.Iterator i=t.entrySet().iterator(); i.hasNext();  ) {
			java.util.Map.Entry e = (java.util.Map.Entry)i.next();
			if (!valEquals(e.getValue(), m.get(e.getKey()))) 
				System.out.println("Error (" + seed + "): m and t differ on an entry ("+e+") after insertion (iterating on t)");
		}

		/* Now we check that m actually holds that data, but iterating on m. */
		  
		for(java.util.Iterator i=m.entrySet().iterator(); i.hasNext();  ) {
			java.util.Map.Entry e = (java.util.Map.Entry)i.next();
			if (!valEquals(e.getValue(), t.get(e.getKey()))) 
				System.out.println("Error (" + seed + "): m and t differ on an entry ("+e+") after insertion (iterating on m)");
		}

		/* Now we check that m actually holds the same keys. */
		  
		for(java.util.Iterator i=t.keySet().iterator(); i.hasNext();  ) {
			Object o = i.next();
			if (!m.containsKey(o)) {
				System.out.println("Error (" + seed + "): m and t differ on a key ("+o+") after insertion (iterating on t)");
				System.exit( 1 );
			}
			if (!m.keySet().contains(o)) {
				System.out.println("Error (" + seed + "): m and t differ on a key ("+o+", in keySet()) after insertion (iterating on t)");
				System.exit( 1 );
			}
		}

		/* Now we check that m actually holds the same keys, but iterating on m. */
		  
		for(java.util.Iterator i=m.keySet().iterator(); i.hasNext();  ) {
			Object o = i.next();
			if (!t.containsKey(o)) {
				System.out.println("Error (" + seed + "): m and t differ on a key after insertion (iterating on m)");
				System.exit( 1 );
			}
			if (!t.keySet().contains(o)) {
				System.out.println("Error (" + seed + "): m and t differ on a key (in keySet()) after insertion (iterating on m)");
				System.exit( 1 );
			}
		}


		/* Now we check that m actually hold the same values. */
		  
		for(java.util.Iterator i=t.values().iterator(); i.hasNext();  ) {
			Object o = i.next();
			if (!m.containsValue(o)) {
				System.out.println("Error (" + seed + "): m and t differ on a value after insertion (iterating on t)");
				System.exit( 1 );
			}
			if (!m.values().contains(o)) {
				System.out.println("Error (" + seed + "): m and t differ on a value (in values()) after insertion (iterating on t)");
				System.exit( 1 );
			}
		}

		/* Now we check that m actually hold the same values, but iterating on m. */
		  
		for(java.util.Iterator i=m.values().iterator(); i.hasNext();  ) {
			Object o = i.next();
			if (!t.containsValue(o)) {
				System.out.println("Error (" + seed + "): m and t differ on a value after insertion (iterating on m)");
				System.exit( 1 );
			}
			if (!t.values().contains(o)) {
				System.out.println("Error (" + seed + "): m and t differ on a value (in values()) after insertion (iterating on m)");
				System.exit( 1 );
			}
		}

		/* Now we check that inquiries about random data give the same answer in m and t. For
		   m we use the polymorphic method. */

		for(int i=0; i<n;  i++ ) {
			KEY_TYPE T = genKey();
			if (m.containsKey(KEY2OBJ(T)) != t.containsKey(KEY2OBJ(T))) {
				System.out.println("Error (" + seed + "): divergence in keys between t and m (polymorphic method)");
				System.exit( 1 );
			}

#if ( #keys(reference) ) && ! ( #values(reference) )
			if ((m.GET_VALUE(T) != VALUE_NULL) != ((t.get(KEY2OBJ(T)) == null ? VALUE_NULL : VALUE_OBJ2TYPE(t.get(KEY2OBJ(T)))) != VALUE_NULL) || 
				t.get(KEY2OBJ(T)) != null && 
				! VALUE2OBJ(m.GET_VALUE(T)).equals(t.get(KEY2OBJ(T)))) 
#else
				if ((m.get(T) != VALUE_NULL) != ((t.get(KEY2OBJ(T)) == null ? VALUE_NULL : VALUE_OBJ2TYPE(t.get(KEY2OBJ(T)))) != VALUE_NULL) || 
					t.get(KEY2OBJ(T)) != null && 
					! m.get(KEY2OBJ(T)).equals(t.get(KEY2OBJ(T)))) 
#endif
					{
						System.out.println("Error (" + seed + "): divergence between t and m (polymorphic method)");
						System.exit( 1 );
					}
		}

		/* Again, we check that inquiries about random data give the same answer in m and t, but
		   for m we use the standard method. */

		for(int i=0; i<n;  i++ ) {
			KEY_TYPE T = genKey();
			if (!valEquals(m.get(KEY2OBJ(T)), t.get(KEY2OBJ(T)))) {
				System.out.println("Error (" + seed + "): divergence between t and m (standard method)");
				System.exit( 1 );
			}
		}

		/* Now we put and remove random data in m and t, checking that the result is the same. */

		for(int i=0; i<20*n;  i++ ) {
			KEY_TYPE T = genKey();
			VALUE_TYPE U = genValue();
			if (!valEquals(m.put(KEY2OBJ(T), VALUE2OBJ(U)), t.put(KEY2OBJ(T), VALUE2OBJ(U)))) {
				System.out.println("Error (" + seed + "): divergence in put() between t and m");
				System.exit( 1 );
			}
			T = genKey();
			if (!valEquals(m.remove(KEY2OBJ(T)), t.remove(KEY2OBJ(T)))) {
				System.out.println("Error (" + seed + "): divergence in remove() between t and m");
				System.exit( 1 );
			}
		}

		if (!m.equals(t)) System.out.println("Error (" + seed + "): !m.equals(t) after removal");
		if (!t.equals(m)) System.out.println("Error (" + seed + "): !t.equals(m) after removal");


		/* Now we check that m actually holds the same data. */
		  
		for(java.util.Iterator i=t.entrySet().iterator(); i.hasNext();  ) {
			java.util.Map.Entry e = (java.util.Map.Entry)i.next();
			if (!valEquals(e.getValue(), m.get(e.getKey()))) {
				System.out.println("Error (" + seed + "): m and t differ on an entry ("+e+") after removal (iterating on t)");
				System.exit( 1 );
			}
		}

		/* Now we check that m actually holds that data, but iterating on m. */
		  
		for(java.util.Iterator i=m.entrySet().iterator(); i.hasNext();  ) {
			java.util.Map.Entry e = (java.util.Map.Entry)i.next();
			if (!valEquals(e.getValue(), t.get(e.getKey()))) {
				System.out.println("Error (" + seed + "): m and t differ on an entry ("+e+") after removal (iterating on m)");
				System.exit( 1 );
			}
		}

		/* Now we check that m actually holds the same keys. */
		  
		for(java.util.Iterator i=t.keySet().iterator(); i.hasNext();  ) {
			Object o = i.next();
			if (!m.containsKey(o)) {
				System.out.println("Error (" + seed + "): m and t differ on a key ("+o+") after removal (iterating on t)");
				System.exit( 1 );
			}
			if (!m.keySet().contains(o)) {
				System.out.println("Error (" + seed + "): m and t differ on a key ("+o+", in keySet()) after removal (iterating on t)");
				System.exit( 1 );
			}
		}

		/* Now we check that m actually holds the same keys, but iterating on m. */
		  
		for(java.util.Iterator i=m.keySet().iterator(); i.hasNext();  ) {
			Object o = i.next();
			if (!t.containsKey(o)) {
				System.out.println("Error (" + seed + "): m and t differ on a key after removal (iterating on m)");
				System.exit( 1 );
			}
			if (!t.keySet().contains(o)) {
				System.out.println("Error (" + seed + "): m and t differ on a key (in keySet()) after removal (iterating on m)");
				System.exit( 1 );
			}
		}


		/* Now we check that m actually hold the same values. */
		  
		for(java.util.Iterator i=t.values().iterator(); i.hasNext();  ) {
			Object o = i.next();
			if (!m.containsValue(o)) {
				System.out.println("Error (" + seed + "): m and t differ on a value after removal (iterating on t)");
				System.exit( 1 );
			}
			if (!m.values().contains(o)) {
				System.out.println("Error (" + seed + "): m and t differ on a value (in values()) after removal (iterating on t)");
				System.exit( 1 );
			}
		}

		/* Now we check that m actually hold the same values, but iterating on m. */
		  
		for(java.util.Iterator i=m.values().iterator(); i.hasNext();  ) {
			Object o = i.next();
			if (!t.containsValue(o)) {
				System.out.println("Error (" + seed + "): m and t differ on a value after removal (iterating on m)");
				System.exit( 1 );
			}
			if (!t.values().contains(o)) {
				System.out.println("Error (" + seed + "): m and t differ on a value (in values()) after removal (iterating on m)");
				System.exit( 1 );
			}
		}


		int h = m.hashCode();


		/* Now we save and read m. */

		try {
			java.io.File ff = new java.io.File("it.unimi.dsi.fastutil.test");
			java.io.OutputStream os = new java.io.FileOutputStream(ff);
			java.io.ObjectOutputStream oos = new java.io.ObjectOutputStream(os);
				
			oos.writeObject(m);
			oos.close();
				
			java.io.InputStream is = new java.io.FileInputStream(ff);
			java.io.ObjectInputStream ois = new java.io.ObjectInputStream(is);
				
			m = (OPEN_HASH_MAP)ois.readObject();
			ois.close();
			ff.delete();
		}
		catch(Exception e) {
			e.printStackTrace();
			System.exit( 1 );
		}


#if !#keyclass(Reference) && !#valueclass(Reference)
		if (m.hashCode() != h) System.out.println("Error (" + seed + "): hashCode() changed after save/read");

		/* Now we check that m actually holds that data. */
		  
		for(java.util.Iterator i=t.keySet().iterator(); i.hasNext();  ) {
			Object o = i.next();
			if (!valEquals(m.get(o),t.get(o))) {
				System.out.println("Error (" + seed + "): m and t differ on an entry after save/read");
				System.exit( 1 );
			}
		}
#else
		m.clear();
		m.putAll( t );
#endif

		/* Now we put and remove random data in m and t, checking that the result is the same. */

		for(int i=0; i<20*n;  i++ ) {
			KEY_TYPE T = genKey();
			VALUE_TYPE U = genValue();
			if (!valEquals(m.put(KEY2OBJ(T), VALUE2OBJ(U)), t.put(KEY2OBJ(T), VALUE2OBJ(U)))) {
				System.out.println("Error (" + seed + "): divergence in put() between t and m after save/read");
				System.exit( 1 );
			}
			T = genKey();
			if (!valEquals(m.remove(KEY2OBJ(T)), t.remove(KEY2OBJ(T)))) {
				System.out.println("Error (" + seed + "): divergence in remove() between t and m after save/read");
				System.exit( 1 );
			}
		}

		if (!m.equals(t)) System.out.println("Error (" + seed + "): !m.equals(t) after post-save/read removal");
		if (!t.equals(m)) System.out.println("Error (" + seed + "): !t.equals(m) after post-save/read removal");



#ifdef Linked


		/* Now we play with iterators. */

		{
			java.util.ListIterator i, j;
			Object J;
			Map.Entry E, F;
			i = (java.util.ListIterator)m.entrySet().iterator(); 
			j = new java.util.LinkedList( t.entrySet() ).listIterator(); 

			for( int k = 0; k < 2*n; k++ ) {
				ensure( i.hasNext() == j.hasNext(), "Error (" + seed + "): divergence in hasNext()" );
				ensure( i.hasPrevious() == j.hasPrevious(), "Error (" + seed + "): divergence in hasPrevious()" );

				if ( r.nextFloat() < .8 && i.hasNext() ) {
#ifdef Custom
					ensure( m.strategy().equals( (E=(java.util.Map.Entry)i.next()).getKey(),  J = (F=(Map.Entry)j.next()).getKey() ), "Error (" + seed + "): divergence in next()" );
#else
					ensure( (E=(java.util.Map.Entry)i.next()).getKey().equals( J = (F=(Map.Entry)j.next()).getKey() ), "Error (" + seed + "): divergence in next()" );
#endif

					if ( r.nextFloat() < 0.3 ) {
						i.remove();
						j.remove();
						t.remove( J );
					}
					else if ( r.nextFloat() < 0.3 ) {
						Object U = VALUE2OBJ(genValue());
						E.setValue( U );
						t.put( F.getKey(), U );
					}
				}
				else if ( r.nextFloat() < .2 && i.hasPrevious() ) {
#ifdef Custom
					ensure( m.strategy().equals( (E=(java.util.Map.Entry)i.previous()).getKey(), J = (F=(Map.Entry)j.previous()).getKey() ), "Error (" + seed + "): divergence in previous()" );
#else
					ensure( (E=(java.util.Map.Entry)i.previous()).getKey().equals( J = (F=(Map.Entry)j.previous()).getKey() ), "Error (" + seed + "): divergence in previous()" );
#endif

					if ( r.nextFloat() < 0.3 ) {
						i.remove();
						j.remove();
						t.remove( J );
					}
					else if ( r.nextFloat() < 0.3 ) {
						Object U = VALUE2OBJ(genValue());
						E.setValue( U );
						t.put( F.getKey(), U );
					}
				}

				ensure( i.nextIndex() == j.nextIndex(), "Error (" + seed + "): divergence in nextIndex()" );
				ensure( i.previousIndex() == j.previousIndex(), "Error (" + seed + "): divergence in previousIndex()" );

			}

		}
		  
		if ( t.size() > 0 ) {
			java.util.ListIterator i, j;
			Object J;
			j = new java.util.LinkedList( t.keySet() ).listIterator();
			int e = r.nextInt( t.size() );
			Object from;
			do from = j.next(); while( e-- != 0 );

			i = (java.util.ListIterator)((SORTED_SET)m.keySet()).iterator( KEY_OBJ2TYPE( from ) ); 

			for( int k = 0; k < 2*n; k++ ) {
				ensure( i.hasNext() == j.hasNext(), "Error (" + seed + "): divergence in hasNext() (iterator with starting point " + from + ")" );
				ensure( i.hasPrevious() == j.hasPrevious(), "Error (" + seed + "): divergence in hasPrevious() (iterator with starting point " + from + ")" );

				if ( r.nextFloat() < .8 && i.hasNext() ) {
#ifdef Custom
					ensure( m.strategy().equals( i.next(), J = j.next() ), "Error (" + seed + "): divergence in next() (iterator with starting point " + from + ")" );
#else
					ensure( i.next().equals( J = j.next() ), "Error (" + seed + "): divergence in next() (iterator with starting point " + from + ")" );
#endif

					if ( r.nextFloat() < 0.5 ) {
						i.remove();
						j.remove();
						t.remove( J );
					}
				}
				else if ( r.nextFloat() < .2 && i.hasPrevious() ) {
#ifdef Custom
					ensure( m.strategy().equals( i.previous(), J = j.previous() ), "Error (" + seed + "): divergence in previous() (iterator with starting point " + from + ")" );
#else
					ensure( i.previous().equals( J = j.previous() ), "Error (" + seed + "): divergence in previous() (iterator with starting point " + from + ")" );
#endif

					if ( r.nextFloat() < 0.5 ) {
						i.remove();
						j.remove();
						t.remove( J );
					}
				}

				ensure( i.nextIndex() == j.nextIndex(), "Error (" + seed + "): divergence in nextIndex() (iterator with starting point " + from + ")" );
				ensure( i.previousIndex() == j.previousIndex(), "Error (" + seed + "): divergence in previousIndex() (iterator with starting point " + from + ")" );

			}

		}
		  


		/* Now we check that m actually holds that data. */
		  
		ensure( m.equals(t), "Error (" + seed + "): ! m.equals( t ) after iteration" );
		ensure( t.equals(m), "Error (" + seed + "): ! t.equals( m ) after iteration" );

#endif


		/* Now we take out of m everything, and check that it is empty. */

		for(java.util.Iterator i=t.keySet().iterator(); i.hasNext(); ) m.remove(i.next()); 

		if (!m.isEmpty())  {
			System.out.println("Error (" + seed + "): m is not empty (as it should be)");
			System.exit( 1 );
		}
		
#ifdef NumericEnhancements
#if #valueclass(Byte) || #valueclass(Character) || #valueclass(Short) || #valueclass(Integer) || #valueclass(Long)
		/* Now we check that increment works properly, using random data */
		
		{
			t.clear();
			m.clear();
			
			for( int k = 0; k < 2*n; k++ ) {
				KEY_TYPE T = genKey();
				VALUE_TYPE U = genValue();
				
				VALUE_TYPE rU = m.increment(T, U);
				VALUE_GENERIC_CLASS tU = (VALUE_GENERIC_CLASS) t.get(KEY2OBJ(T));
				if (null == tU) {
					ensure(m.defaultReturnValue() == rU, "Error (" + seed + "): map increment does not return proper starting value." );
					t.put( KEY2OBJ(T), VALUE2OBJ((VALUE_TYPE) (m.defaultReturnValue() + U)) );
				}
				else {
					t.put( KEY2OBJ(T), VALUE2OBJ((VALUE_TYPE) (((VALUE_TYPE) tU) + U)) );
				}
			}
			
			// Maps should contain identical values
			ensure( new java.util.HashMap(m).equals(new java.util.HashMap(t)),
				"Error(" + seed + "): incremented maps are not equal." );
		}
#endif
#endif
		

#if (#keyclass(Integer) || #keyclass(Long)) && (#valueclass(Integer) || #valueclass(Long))
		m = new OPEN_HASH_MAP(n, f);
		t.clear();
		int x;

		/* Now we torture-test the hash table. This part is implemented only for integers and longs. */

		int p = m.key.length;

		for(int i=0; i<p; i++) {
			for (int j=0; j<20; j++) {
				m.put(i+(r.nextInt() % 10)*p, 1);
				m.remove(i+(r.nextInt() % 10)*p);
			}

			for (int j=-10; j<10; j++) m.remove(i+j*p);
		}
		  
		t.putAll(m);

		/* Now all table entries are REMOVED. */

		for(int i=0; i<(p*f)/10; i++) {
			for (int j=0; j<10; j++) {
				if (!valEquals(m.put(KEY2OBJ(x = i+(r.nextInt() % 10)*p), VALUE2OBJ(1)), t.put(KEY2OBJ(x), VALUE2OBJ(1))))
					System.out.println("Error (" + seed + "): m and t differ on an entry during torture-test insertion.");
			}
		}

		if (!m.equals(t)) System.out.println("Error (" + seed + "): !m.equals(t) after torture-test insertion");
		if (!t.equals(m)) System.out.println("Error (" + seed + "): !t.equals(m) after torture-test insertion");

		for(int i=0; i<p/10; i++) {
			for (int j=0; j<10; j++) {
				if (!valEquals(m.remove(KEY2OBJ(x = i+(r.nextInt() % 10)*p)), t.remove(KEY2OBJ(x))))
					System.out.println("Error (" + seed + "): m and t differ on an entry during torture-test removal.");
			}
		}

		if (!m.equals(t)) System.out.println("Error (" + seed + "): !m.equals(t) after torture-test removal");
		if (!t.equals(m)) System.out.println("Error (" + seed + "): !t.equals(m) after torture-test removal");

		if (!m.equals(m.clone())) System.out.println("Error (" + seed + "): !m.equals(m.clone()) after torture-test removal");
		if (!((OPEN_HASH_MAP)m.clone()).equals(m)) System.out.println("Error (" + seed + "): !m.clone().equals(m) after torture-test removal");

		m.rehash();

		if (!m.equals(t)) System.out.println("Error (" + seed + "): !m.equals(t) after rehash()");
		if (!t.equals(m)) System.out.println("Error (" + seed + "): !t.equals(m) after rehash()");

		m.trim();

		if (!m.equals(t)) System.out.println("Error (" + seed + "): !m.equals(t) after trim()");
		if (!t.equals(m)) System.out.println("Error (" + seed + "): !t.equals(m) after trim()");
#endif

		System.out.println("Test OK");
		return;

#endif
	}


	public static void main( String args[] ) {
		float f = Hash.DEFAULT_LOAD_FACTOR;
		int n  = Integer.parseInt(args[1]);
		if (args.length>2) f = Float.parseFloat(args[2]);
		if ( args.length > 3 ) r = new java.util.Random( seed = Long.parseLong( args[ 3 ] ) );
		  
		try {
			if ("speedTest".equals(args[0]) || "speedComp".equals(args[0])) speedTest( n, f, "speedComp".equals(args[0]) );
			else if ( "test".equals( args[0] ) ) test(n, f);
		} catch( Throwable e ) {
			e.printStackTrace( System.err );
			System.err.println( "seed: " + seed );
		}
			
	}

#endif

}
