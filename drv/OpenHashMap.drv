/*
 * Copyright (C) 2002-2024 Sebastiano Vigna
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package PACKAGE;

import it.unimi.dsi.fastutil.Hash;
import it.unimi.dsi.fastutil.HashCommon;
import static it.unimi.dsi.fastutil.HashCommon.arraySize;
import static it.unimi.dsi.fastutil.HashCommon.maxFill;

import java.util.Map;
import java.util.Arrays;
import java.util.NoSuchElementException;
import java.util.function.Consumer;

#if KEY_INDEX != VALUE_INDEX && VALUES_BYTE_CHAR_SHORT_FLOAT
import VALUE_PACKAGE.VALUE_CONSUMER;
#endif

#if KEY_INDEX != VALUE_INDEX && !(KEYS_REFERENCE && VALUES_REFERENCE)
import VALUE_PACKAGE.VALUE_COLLECTION;
import VALUE_PACKAGE.VALUE_ABSTRACT_COLLECTION;

#if VALUES_PRIMITIVE
import VALUE_PACKAGE.VALUE_ITERATOR;
import VALUE_PACKAGE.VALUE_SPLITERATOR;
import VALUE_PACKAGE.VALUE_SPLITERATORS;
#endif

#if VALUE_CLASS_Boolean
import it.unimi.dsi.fastutil.booleans.BooleanConsumer;
#endif
#endif

#ifdef Linked

import java.util.Comparator;

#if KEY_INDEX != VALUE_INDEX && !(KEYS_REFERENCE && VALUES_REFERENCE)
#if VALUES_PRIMITIVE
import VALUE_PACKAGE.VALUE_LIST_ITERATOR;
#else
import it.unimi.dsi.fastutil.objects.ObjectIterator;
#endif
#endif

#if ! KEYS_REFERENCE
import it.unimi.dsi.fastutil.objects.AbstractObjectSortedSet;
import it.unimi.dsi.fastutil.objects.ObjectListIterator;
import it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator;
import it.unimi.dsi.fastutil.objects.ObjectSpliterator;
import it.unimi.dsi.fastutil.objects.ObjectSpliterators;
import it.unimi.dsi.fastutil.objects.ObjectSortedSet;
#endif

/**  A type-specific linked hash map with with a fast, small-footprint implementation.
 *
 * <p>Instances of this class use a hash table to represent a map. The table is
 * filled up to a specified <em>load factor</em>, and then doubled in size to
 * accommodate new entries. If the table is emptied below <em>one fourth</em>
 * of the load factor, it is halved in size; however, the table is never reduced to a
 * size smaller than that at creation time: this approach makes it
 * possible to create maps with a large capacity in which insertions and
 * deletions do not cause immediately rehashing. Moreover, halving is
 * not performed when deleting entries from an iterator, as it would interfere
 * with the iteration process.
 *
 * <p>Note that {@link #clear()} does not modify the hash table size.
 * Rather, a family of {@linkplain #trim() trimming
 * methods} lets you control the size of the table; this is particularly useful
 * if you reuse instances of this class.
 *
 * <p>Entries returned by the type-specific {@link #entrySet()} method implement
 * the suitable type-specific {@link it.unimi.dsi.fastutil.Pair Pair} interface;
 * only values are mutable.
 *
 * <p>Iterators generated by this map will enumerate pairs in the same order in which they
 * have been added to the map (addition of pairs whose key is already present
 * in the map does not change the iteration order). Note that this order has nothing in common with the natural
 * order of the keys. The order is kept by means of a doubly linked list, represented
 * <i>via</i> an array of longs parallel to the table.
 *
 * <p>This class implements the interface of a sorted map, so to allow easy
 * access of the iteration order: for instance, you can get the first key
 * in iteration order with {@code firstKey()} without having to create an
 * iterator; however, this class partially violates the {@link java.util.SortedMap}
 * contract because all submap methods throw an exception and {@link
 * #comparator()} returns always {@code null}.
 *
 * <p>Additional methods, such as {@code getAndMoveToFirst()}, make it easy
 * to use instances of this class as a cache (e.g., with LRU policy).
 *
 * <p>The iterators provided by the views of this class using are type-specific
 * {@linkplain java.util.ListIterator list iterators}, and can be started at any
 * element <em>which is a key of the map</em>, or
 * a {@link NoSuchElementException} exception will be thrown.
 * If, however, the provided element is not the first or last key in the
 * map, the first access to the list index will require linear time, as in the worst case
 * the entire key set must be scanned in iteration order to retrieve the positional
 * index of the starting key. If you use just the methods of a type-specific {@link it.unimi.dsi.fastutil.BidirectionalIterator},
 * however, all operations will be performed in constant time.
 *
 * @see Hash
 * @see HashCommon
 */

public class OPEN_HASH_MAP KEY_VALUE_GENERIC extends ABSTRACT_SORTED_MAP KEY_VALUE_GENERIC implements java.io.Serializable, Cloneable, Hash {

#else

#if ! KEYS_REFERENCE
import it.unimi.dsi.fastutil.objects.AbstractObjectSet;
import it.unimi.dsi.fastutil.objects.ObjectIterator;
import it.unimi.dsi.fastutil.objects.ObjectSpliterator;
import it.unimi.dsi.fastutil.objects.ObjectSpliterators;
#endif

#ifdef Custom

/** A type-specific hash map with a fast, small-footprint implementation whose {@linkplain it.unimi.dsi.fastutil.Hash.Strategy hashing strategy}
 * is specified at creation time.
 *
 * <p>Instances of this class use a hash table to represent a map. The table is
 * filled up to a specified <em>load factor</em>, and then doubled in size to
 * accommodate new entries. If the table is emptied below <em>one fourth</em>
 * of the load factor, it is halved in size; however, the table is never reduced to a
 * size smaller than that at creation time: this approach makes it
 * possible to create maps with a large capacity in which insertions and
 * deletions do not cause immediately rehashing. Moreover, halving is
 * not performed when deleting entries from an iterator, as it would interfere
 * with the iteration process.
 *
 * <p>Note that {@link #clear()} does not modify the hash table size.
 * Rather, a family of {@linkplain #trim() trimming
 * methods} lets you control the size of the table; this is particularly useful
 * if you reuse instances of this class.
 *
 * <p>Entries returned by the type-specific {@link #entrySet()} method implement
 * the suitable type-specific {@link it.unimi.dsi.fastutil.Pair Pair} interface;
 * only values are mutable.
 *
 * @see Hash
 * @see HashCommon
 */

public class OPEN_HASH_MAP KEY_VALUE_GENERIC extends ABSTRACT_MAP KEY_VALUE_GENERIC implements java.io.Serializable, Cloneable, Hash {

#else

/** A type-specific hash map with a fast, small-footprint implementation.
 *
 * <p>Instances of this class use a hash table to represent a map. The table is
 * filled up to a specified <em>load factor</em>, and then doubled in size to
 * accommodate new entries. If the table is emptied below <em>one fourth</em>
 * of the load factor, it is halved in size; however, the table is never reduced to a
 * size smaller than that at creation time: this approach makes it
 * possible to create maps with a large capacity in which insertions and
 * deletions do not cause immediately rehashing. Moreover, halving is
 * not performed when deleting entries from an iterator, as it would interfere
 * with the iteration process.
 *
 * <p>Note that {@link #clear()} does not modify the hash table size.
 * Rather, a family of {@linkplain #trim() trimming
 * methods} lets you control the size of the table; this is particularly useful
 * if you reuse instances of this class.
 *
 * <p>Entries returned by the type-specific {@link #entrySet()} method implement
 * the suitable type-specific {@link it.unimi.dsi.fastutil.Pair Pair} interface;
 * only values are mutable.
 *
 * @see Hash
 * @see HashCommon
 */

public class OPEN_HASH_MAP KEY_VALUE_GENERIC extends ABSTRACT_MAP KEY_VALUE_GENERIC implements java.io.Serializable, Cloneable, Hash {

#endif

#endif

	private static final long serialVersionUID = 0L;
	private static final boolean ASSERTS = ASSERTS_VALUE;

	/** The array of keys. */
	protected transient KEY_GENERIC_TYPE[] key;

	/** The array of values. */
	protected transient VALUE_GENERIC_TYPE[] value;

	/** The mask for wrapping a position counter. */
	protected transient int mask;

	/** Whether this map contains the key zero. */
	protected transient boolean containsNullKey;

#ifdef Custom
	/** The hash strategy of this custom map. */
	protected STRATEGY KEY_SUPER_GENERIC strategy;
#endif

#ifdef Linked
	/** The index of the first entry in iteration order. It is valid iff {@link #size} is nonzero; otherwise, it contains -1. */
	protected transient int first = -1;
	/** The index of the last entry in iteration order. It is valid iff {@link #size} is nonzero; otherwise, it contains -1. */
	protected transient int last = -1;
	/** For each entry, the next and the previous entry in iteration order,
	 * stored as {@code ((prev & 0xFFFFFFFFL) << 32) | (next & 0xFFFFFFFFL)}.
	 * The first entry contains predecessor -1, and the last entry
	 * contains successor -1. */
	 protected transient long[] link;
#endif

	/** The current table size. */
	protected transient int n;

	/** Threshold after which we rehash. It must be the table size times {@link #f}. */
	protected transient int maxFill;

	/** We never resize below this threshold, which is the construction-time {#n}. */
	protected final transient int minN;

	/** Number of entries in the set (including the key zero, if present). */
	protected int size;

	/** The acceptable load factor. */
	protected final float f;

#ifdef Linked
	/** Cached set of entries. */
	protected transient FastSortedEntrySet KEY_VALUE_GENERIC entries;

	/** Cached set of keys. */
	protected transient SORTED_SET KEY_GENERIC keys;
#else
	/** Cached set of entries. */
	protected transient FastEntrySet KEY_VALUE_GENERIC entries;

	/** Cached set of keys. */
	protected transient SET KEY_GENERIC keys;
#endif

	/** Cached collection of values. */
	protected transient VALUE_COLLECTION VALUE_GENERIC values;


#ifdef Custom
	/** Creates a new hash map.
	 *
	 * <p>The actual table size will be the least power of two greater than {@code expected}/{@code f}.
	 *
	 * @param expected the expected number of elements in the hash map.
	 * @param f the load factor.
	 * @param strategy the strategy.
	 */
	SUPPRESS_WARNINGS_KEY_VALUE_UNCHECKED
	public OPEN_HASH_MAP(final int expected, final float f, final STRATEGY KEY_SUPER_GENERIC strategy) {
		this.strategy = strategy;
#else
	/** Creates a new hash map.
	 *
	 * <p>The actual table size will be the least power of two greater than {@code expected}/{@code f}.
	 *
	 * @param expected the expected number of elements in the hash map.
	 * @param f the load factor.
	 */
	SUPPRESS_WARNINGS_KEY_VALUE_UNCHECKED
	public OPEN_HASH_MAP(final int expected, final float f) {
#endif
		if (f <= 0 || f >= 1) throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than 1");
		if (expected < 0) throw new IllegalArgumentException("The expected number of elements must be nonnegative");

		this.f = f;

		minN = n = arraySize(expected, f);
		mask = n - 1;
		maxFill = maxFill(n, f);
		key = KEY_GENERIC_ARRAY_CAST new KEY_TYPE[n + 1];
		value = VALUE_GENERIC_ARRAY_CAST new VALUE_TYPE[n + 1];
#ifdef Linked
		link = new long[n + 1];
#endif
	}


#ifdef Custom
	/** Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
	 *
	 * @param expected the expected number of elements in the hash map.
	 * @param strategy the strategy.
	 */

	public OPEN_HASH_MAP(final int expected, final STRATEGY KEY_SUPER_GENERIC strategy) {
		this(expected, DEFAULT_LOAD_FACTOR, strategy);
	}
#else
	/** Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
	 *
	 * @param expected the expected number of elements in the hash map.
	 */

	public OPEN_HASH_MAP(final int expected) {
		this(expected, DEFAULT_LOAD_FACTOR);
	}
#endif


#ifdef Custom
	/** Creates a new hash map with initial expected {@link Hash#DEFAULT_INITIAL_SIZE} entries
	 * and {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
	 * @param strategy the strategy.
	 */

	public OPEN_HASH_MAP(final STRATEGY KEY_SUPER_GENERIC strategy) {
		this(DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR, strategy);
	}
#else
	/** Creates a new hash map with initial expected {@link Hash#DEFAULT_INITIAL_SIZE} entries
	 * and {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
	 */

	public OPEN_HASH_MAP() {
		this(DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR);
	}
#endif


#ifdef Custom
	/** Creates a new hash map copying a given one.
	 *
	 * @param m a {@link Map} to be copied into the new hash map.
	 * @param f the load factor.
	 * @param strategy the strategy.
	 */

	public OPEN_HASH_MAP(final Map<? extends KEY_GENERIC_CLASS, ? extends VALUE_GENERIC_CLASS> m, final float f, final STRATEGY KEY_SUPER_GENERIC strategy) {
		this(m.size(), f, strategy);
		putAll(m);
	}
#else
	/** Creates a new hash map copying a given one.
	 *
	 * @param m a {@link Map} to be copied into the new hash map.
	 * @param f the load factor.
	 */

	public OPEN_HASH_MAP(final Map<? extends KEY_GENERIC_CLASS, ? extends VALUE_GENERIC_CLASS> m, final float f) {
		this(m.size(), f);
		putAll(m);
	}
#endif

#ifdef Custom
	/** Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor copying a given one.
	 *
	 * @param m a {@link Map} to be copied into the new hash map.
	 * @param strategy the strategy.
	 */

	public OPEN_HASH_MAP(final Map<? extends KEY_GENERIC_CLASS, ? extends VALUE_GENERIC_CLASS> m, final STRATEGY KEY_SUPER_GENERIC strategy) {
		this(m, DEFAULT_LOAD_FACTOR, strategy);
	}
#else
	/** Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor copying a given one.
	 *
	 * @param m a {@link Map} to be copied into the new hash map.
	 */

	public OPEN_HASH_MAP(final Map<? extends KEY_GENERIC_CLASS, ? extends VALUE_GENERIC_CLASS> m) {
		this(m, DEFAULT_LOAD_FACTOR);
	}
#endif

#ifdef Custom
	/** Creates a new hash map copying a given type-specific one.
	 *
	 * @param m a type-specific map to be copied into the new hash map.
	 * @param f the load factor.
	 * @param strategy the strategy.
	 */

	public OPEN_HASH_MAP(final MAP KEY_VALUE_GENERIC m, final float f, final STRATEGY KEY_SUPER_GENERIC strategy) {
		this(m.size(), f, strategy);
		putAll(m);
	}
#else
	/** Creates a new hash map copying a given type-specific one.
	 *
	 * @param m a type-specific map to be copied into the new hash map.
	 * @param f the load factor.
	 */

	public OPEN_HASH_MAP(final MAP KEY_VALUE_GENERIC m, final float f) {
		this(m.size(), f);
		putAll(m);
	}
#endif

#ifdef Custom
	/** Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor copying a given type-specific one.
	 *
	 * @param m a type-specific map to be copied into the new hash map.
	 * @param strategy the strategy.
	 */

	public OPEN_HASH_MAP(final MAP KEY_VALUE_GENERIC m, final STRATEGY KEY_SUPER_GENERIC strategy) {
		this(m, DEFAULT_LOAD_FACTOR, strategy);
	}
#else
	/** Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor copying a given type-specific one.
	 *
	 * @param m a type-specific map to be copied into the new hash map.
	 */

	public OPEN_HASH_MAP(final MAP KEY_VALUE_GENERIC m) {
		this(m, DEFAULT_LOAD_FACTOR);
	}
#endif


#ifdef Custom
	/** Creates a new hash map using the elements of two parallel arrays.
	 *
	 * @param k the array of keys of the new hash map.
	 * @param v the array of corresponding values in the new hash map.
	 * @param f the load factor.
	 * @param strategy the strategy.
	 * @throws IllegalArgumentException if {@code k} and {@code v} have different lengths.
	 */

	public OPEN_HASH_MAP(final KEY_GENERIC_TYPE[] k, final VALUE_GENERIC_TYPE[] v, final float f, final STRATEGY KEY_SUPER_GENERIC strategy) {
		this(k.length, f, strategy);
		if (k.length != v.length) throw new IllegalArgumentException("The key array and the value array have different lengths (" + k.length + " and " + v.length + ")");
		for(int i = 0; i < k.length; i++) this.put(k[i], v[i]);
	}
#else
	/** Creates a new hash map using the elements of two parallel arrays.
	 *
	 * @param k the array of keys of the new hash map.
	 * @param v the array of corresponding values in the new hash map.
	 * @param f the load factor.
	 * @throws IllegalArgumentException if {@code k} and {@code v} have different lengths.
	 */

	public OPEN_HASH_MAP(final KEY_GENERIC_TYPE[] k, final VALUE_GENERIC_TYPE[] v, final float f) {
		this(k.length, f);
		if (k.length != v.length) throw new IllegalArgumentException("The key array and the value array have different lengths (" + k.length + " and " + v.length + ")");
		for(int i = 0; i < k.length; i++) this.put(k[i], v[i]);
	}
#endif

#ifdef Custom
	/** Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor using the elements of two parallel arrays.
	 *
	 * @param k the array of keys of the new hash map.
	 * @param v the array of corresponding values in the new hash map.
	 * @param strategy the strategy.
	 * @throws IllegalArgumentException if {@code k} and {@code v} have different lengths.
	 */

	public OPEN_HASH_MAP(final KEY_GENERIC_TYPE[] k, final VALUE_GENERIC_TYPE[] v, final STRATEGY KEY_SUPER_GENERIC strategy) {
		this(k, v, DEFAULT_LOAD_FACTOR, strategy);
	}
#else
	/** Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor using the elements of two parallel arrays.
	 *
	 * @param k the array of keys of the new hash map.
	 * @param v the array of corresponding values in the new hash map.
	 * @throws IllegalArgumentException if {@code k} and {@code v} have different lengths.
	 */

	public OPEN_HASH_MAP(final KEY_GENERIC_TYPE[] k, final VALUE_GENERIC_TYPE[] v) {
		this(k, v, DEFAULT_LOAD_FACTOR);
	}
#endif



#ifdef Custom
	/** Returns the hashing strategy.
	 *
	 * @return the hashing strategy of this custom hash map.
	 */

	public STRATEGY KEY_SUPER_GENERIC strategy() {
		return strategy;
	}
#endif

	private int realSize() {
		return containsNullKey ? size - 1 : size;
	}

	/** Ensures that this map can hold a certain number of keys without rehashing.
	 *
	 * @param capacity a number of keys; there will be no rehashing unless
	 * the map {@linkplain #size() size} exceeds this number.
	 */
	public void ensureCapacity(final int capacity) {
		final int needed = arraySize(capacity, f);
		if (needed > n) rehash(needed);
	}

	private void tryCapacity(final long capacity) {
		final int needed = (int)Math.min(1 << 30, Math.max(2, HashCommon.nextPowerOfTwo((long)Math.ceil(capacity / f))));
		if (needed > n) rehash(needed);
	}

	private VALUE_GENERIC_TYPE removeEntry(final int pos) {
		final VALUE_GENERIC_TYPE oldValue = value[pos];
#if VALUES_REFERENCE
		value[pos] = null;
#endif
		size--;
#ifdef Linked
		fixPointers(pos);
#endif

		shiftKeys(pos);
		if (n > minN && size < maxFill / 4 && n > DEFAULT_INITIAL_SIZE) rehash(n / 2);
		return oldValue;
	}

	private VALUE_GENERIC_TYPE removeNullEntry() {
		containsNullKey = false;
#if KEYS_REFERENCE
		key[n] = null;
#endif
		final VALUE_GENERIC_TYPE oldValue = value[n];
#if VALUES_REFERENCE
		value[n] = null;
#endif
		size--;
#ifdef Linked
		fixPointers(n);
#endif
		if (n > minN && size < maxFill / 4 && n > DEFAULT_INITIAL_SIZE) rehash(n / 2);
		return oldValue;
	}


	@Override
	public void putAll(Map<? extends KEY_GENERIC_CLASS,? extends VALUE_GENERIC_CLASS> m) {
		if (f <= .5) ensureCapacity(m.size()); // The resulting map will be sized for m.size() elements
		else tryCapacity(size() + m.size()); // The resulting map will be tentatively sized for size() + m.size() elements
		super.putAll(m);
	}

	SUPPRESS_WARNINGS_KEY_UNCHECKED
	private int find(final KEY_GENERIC_TYPE k) {
		if (KEY_EQUALS_NULL(k)) return containsNullKey ? n : -(n + 1);

		KEY_GENERIC_TYPE curr;
		final KEY_GENERIC_TYPE[] key = this.key;
		int pos;

		// The starting point.
		if (KEY_IS_NULL(curr = key[pos = KEY2INTHASH(k) & mask])) return -(pos + 1);
		if (KEY_EQUALS_NOT_NULL(k, curr)) return pos;
		// There's always an unused entry.
		while(true) {
			if (KEY_IS_NULL(curr = key[pos = (pos + 1) & mask])) return -(pos + 1);
			if (KEY_EQUALS_NOT_NULL(k, curr)) return pos;
		}
	}


	private void insert(final int pos, final KEY_GENERIC_TYPE k, final VALUE_GENERIC_TYPE v) {
		if (pos == n) containsNullKey = true;
		key[pos] = k;
		value[pos] = v;
#ifdef Linked
		if (size == 0) {
			first = last = pos;
			// Special case of SET_UPPER_LOWER(link[pos], -1, -1);
			link[pos] = -1L;
		}
		else {
			SET_NEXT(link[last], pos);
			SET_UPPER_LOWER(link[pos], last, -1);
			last = pos;
		}
#endif

		if (size++ >= maxFill) rehash(arraySize(size + 1, f));
		if (ASSERTS) checkTable();
	}


	@Override
	public VALUE_GENERIC_TYPE put(final KEY_GENERIC_TYPE k, final VALUE_GENERIC_TYPE v) {
		final int pos = find(k);
		if (pos < 0) {
			insert(-pos - 1, k, v);
			return defRetValue;
		}
		final VALUE_GENERIC_TYPE oldValue = value[pos];
		value[pos] = v;
		return oldValue;
	}

#if VALUE_CLASS_Byte || VALUE_CLASS_Short || VALUE_CLASS_Character || VALUE_CLASS_Integer || VALUE_CLASS_Long || VALUE_CLASS_Float || VALUE_CLASS_Double

	private VALUE_GENERIC_TYPE addToValue(final int pos, final VALUE_GENERIC_TYPE incr) {
		final VALUE_GENERIC_TYPE oldValue = value[pos];
#if VALUE_CLASS_Byte || VALUE_CLASS_Short || VALUE_CLASS_Character
		value[pos] = (VALUE_TYPE)(oldValue + incr);
#else
		value[pos] = oldValue + incr;
#endif
		return oldValue;
	}

	/** Adds an increment to value currently associated with a key.
	 *
	 * <p>Note that this method respects the {@linkplain #defaultReturnValue() default return value} semantics: when
	 * called with a key that does not currently appears in the map, the key
	 * will be associated with the default return value plus
	 * the given increment.
	 *
	 * @param k the key.
	 * @param incr the increment.
	 * @return the old value, or the {@linkplain #defaultReturnValue() default return value} if no value was present for the given key.
	 */
	public VALUE_GENERIC_TYPE addTo(final KEY_GENERIC_TYPE k, final VALUE_GENERIC_TYPE incr) {
		int pos;

		if (KEY_EQUALS_NULL(k)) {
			if (containsNullKey) return addToValue(n, incr);
			pos = n;
			containsNullKey = true;
		}
		else {
			KEY_GENERIC_TYPE curr;
			final KEY_GENERIC_TYPE[] key = this.key;

			// The starting point.
			if (! KEY_IS_NULL(curr = key[pos = KEY2INTHASH(k) & mask])) {
				if (KEY_EQUALS_NOT_NULL(curr, k)) return addToValue(pos, incr);
				while(! KEY_IS_NULL(curr = key[pos = (pos + 1) & mask]))
					if (KEY_EQUALS_NOT_NULL(curr, k)) return addToValue(pos, incr);
			}
		}

		key[pos] = k;

#if VALUE_CLASS_Byte || VALUE_CLASS_Short || VALUE_CLASS_Character
		value[pos] = (VALUE_TYPE)(defRetValue + incr);
#else
		value[pos] = defRetValue + incr;
#endif

#ifdef Linked
		if (size == 0) {
			first = last = pos;
			// Special case of SET_UPPER_LOWER(link[pos], -1, -1);
			link[pos] = -1L;
		}
		else {
			SET_NEXT(link[last], pos);
			SET_UPPER_LOWER(link[pos], last, -1);
			last = pos;
		}
#endif

		if (size++ >= maxFill) rehash(arraySize(size + 1, f));
		if (ASSERTS) checkTable();
		return defRetValue;
	}

#endif

	/** Shifts left entries with the specified hash code, starting at the specified position,
	 * and empties the resulting free entry.
	 *
	 * @param pos a starting position.
	 */
	protected final void shiftKeys(int pos) {
		// Shift entries with the same hash.
		int last, slot;
		KEY_GENERIC_TYPE curr;
		final KEY_GENERIC_TYPE[] key = this.key;

		for(;;) {
			pos = ((last = pos) + 1) & mask;

			for(;;) {
				if (KEY_IS_NULL(curr = key[pos])) {
					key[last] = KEY_NULL;
#if VALUES_REFERENCE
					value[last] = null;
#endif
					return;
				}
				slot = KEY2INTHASH(curr) & mask;
				if (last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos) break;
				pos = (pos + 1) & mask;
			}

			key[last] = curr;
			value[last] = value[pos];
#ifdef Linked
			fixPointers(pos, last);
#endif
		}
	}

	@Override
	SUPPRESS_WARNINGS_KEY_UNCHECKED
	public VALUE_GENERIC_TYPE REMOVE_VALUE(final KEY_TYPE k) {
		if (KEY_EQUALS_NULL(KEY_GENERIC_CAST k)) {
			if (containsNullKey) return removeNullEntry();
			return defRetValue;
		}

		KEY_GENERIC_TYPE curr;
		final KEY_GENERIC_TYPE[] key = this.key;
		int pos;

		// The starting point.
		if (KEY_IS_NULL(curr = key[pos = KEY2INTHASH_CAST(k) & mask])) return defRetValue;
		if (KEY_EQUALS_NOT_NULL_CAST(k, curr)) return removeEntry(pos);
		while(true) {
			if (KEY_IS_NULL(curr = key[pos = (pos + 1) & mask])) return defRetValue;
			if (KEY_EQUALS_NOT_NULL_CAST(k, curr)) return removeEntry(pos);
		}
	}


#ifdef Linked

	private VALUE_GENERIC_TYPE setValue(final int pos, final VALUE_GENERIC_TYPE v) {
		final VALUE_GENERIC_TYPE oldValue = value[pos];
		value[pos] = v;
		return oldValue;
	}

	/** Removes the mapping associated with the first key in iteration order.
	 * @return the value previously associated with the first key in iteration order.
	 * @throws NoSuchElementException is this map is empty.
	 */
	public VALUE_GENERIC_TYPE REMOVE_FIRST_VALUE() {
		if (size == 0) throw new NoSuchElementException();
		final int pos = first;

		// Abbreviated version of fixPointers(pos)
		if (size == 1) first = last = -1;
		else {
			first = GET_NEXT(link[pos]);
			if (0 <= first) {
				// Special case of SET_PREV(link[first], -1)
				link[first] |= (-1 & 0xFFFFFFFFL) << 32;
			}
		}

		size--;
		final VALUE_GENERIC_TYPE v = value[pos];
		if (pos == n) {
			containsNullKey = false;
#if KEYS_REFERENCE
			key[n] = null;
#endif
#if VALUES_REFERENCE
			value[n] = null;
#endif
		}
		else shiftKeys(pos);
		if (n > minN && size < maxFill / 4 && n > DEFAULT_INITIAL_SIZE) rehash(n / 2);
		return v;
	}

	/** Removes the mapping associated with the last key in iteration order.
	 * @return the value previously associated with the last key in iteration order.
	 * @throws NoSuchElementException is this map is empty.
	 */
	public VALUE_GENERIC_TYPE REMOVE_LAST_VALUE() {
		if (size == 0) throw new NoSuchElementException();
		final int pos = last;

		// Abbreviated version of fixPointers(pos)
		if (size == 1) first = last = -1;
		else {
			last = GET_PREV(link[pos]);
			if (0 <= last) {
				// Special case of SET_NEXT(link[last], -1)
				link[last] |= -1 & 0xFFFFFFFFL;
			}
		}

		size--;
		final VALUE_GENERIC_TYPE v = value[pos];
		if (pos == n) {
			containsNullKey = false;
#if KEYS_REFERENCE
			key[n] = null;
#endif
#if VALUES_REFERENCE
			value[n] = null;
#endif
		}
		else shiftKeys(pos);
		if (n > minN && size < maxFill / 4 && n > DEFAULT_INITIAL_SIZE) rehash(n / 2);
		return v;
	}

	private void moveIndexToFirst(final int i) {
		if (size == 1 || first == i) return;
		if (last == i) {
			last = GET_PREV(link[i]);
			// Special case of SET_NEXT(link[last], -1);
			link[last] |= -1 & 0xFFFFFFFFL;
		}
		else {
			final long linki = link[i];
			final int prev = GET_PREV(linki);
			final int next = GET_NEXT(linki);
			COPY_NEXT(link[prev], linki);
			COPY_PREV(link[next], linki);
		}
		SET_PREV(link[first], i);
		SET_UPPER_LOWER(link[i], -1, first);
		first = i;
	}

	private void moveIndexToLast(final int i) {
		if (size == 1 ||  last == i) return;
		if (first == i) {
			first = GET_NEXT(link[i]);
			// Special case of SET_PREV(link[first], -1);
			link[first] |= (-1 & 0xFFFFFFFFL) << 32;
		}
		else {
			final long linki = link[i];
			final int prev = GET_PREV(linki);
			final int next = GET_NEXT(linki);
			COPY_NEXT(link[prev], linki);
			COPY_PREV(link[next], linki);
		}
		SET_NEXT(link[last], i);
		SET_UPPER_LOWER(link[i], last, -1);
		last = i;
	}

	/** Returns the value to which the given key is mapped; if the key is present, it is moved to the first position of the iteration order.
	 *
	 * @param k the key.
	 * @return the corresponding value, or the {@linkplain #defaultReturnValue() default return value} if no value was present for the given key.
	 */
	public VALUE_GENERIC_TYPE getAndMoveToFirst(final KEY_GENERIC_TYPE k) {
		if (KEY_EQUALS_NULL(k)) {
			if (containsNullKey) {
				moveIndexToFirst(n);
				return value[n];
			}

			return defRetValue;
		}

		KEY_GENERIC_TYPE curr;
		final KEY_GENERIC_TYPE[] key = this.key;
		int pos;

		// The starting point.
		if (KEY_IS_NULL(curr = key[pos = KEY2INTHASH(k) & mask])) return defRetValue;
		if (KEY_EQUALS_NOT_NULL(k, curr)) {
			moveIndexToFirst(pos);
			return value[pos];
		}

		// There's always an unused entry.
		while(true) {
			if (KEY_IS_NULL(curr = key[pos = (pos + 1) & mask])) return defRetValue;
			if (KEY_EQUALS_NOT_NULL(k, curr))  {
				moveIndexToFirst(pos);
				return value[pos];
			}
		}
	}

	/** Returns the value to which the given key is mapped; if the key is present, it is moved to the last position of the iteration order.
	 *
	 * @param k the key.
	 * @return the corresponding value, or the {@linkplain #defaultReturnValue() default return value} if no value was present for the given key.
	 */
	public VALUE_GENERIC_TYPE getAndMoveToLast(final KEY_GENERIC_TYPE k) {
		if (KEY_EQUALS_NULL(k)) {
			if (containsNullKey) {
				moveIndexToLast(n);
				return value[n];
			}

			return defRetValue;
		}

		KEY_GENERIC_TYPE curr;
		final KEY_GENERIC_TYPE[] key = this.key;
		int pos;

		// The starting point.
		if (KEY_IS_NULL(curr = key[pos = KEY2INTHASH(k) & mask])) return defRetValue;
		if (KEY_EQUALS_NOT_NULL(k, curr)) {
			moveIndexToLast(pos);
			return value[pos];
		}

		// There's always an unused entry.
		while(true) {
			if (KEY_IS_NULL(curr = key[pos = (pos + 1) & mask])) return defRetValue;
			if (KEY_EQUALS_NOT_NULL(k, curr))  {
				moveIndexToLast(pos);
				return value[pos];
			}
		}
	}

	/** Adds a pair to the map; if the key is already present, it is moved to the first position of the iteration order.
	 *
	 * @param k the key.
	 * @param v the value.
	 * @return the old value, or the {@linkplain #defaultReturnValue() default return value} if no value was present for the given key.
	 */
	public VALUE_GENERIC_TYPE putAndMoveToFirst(final KEY_GENERIC_TYPE k, final VALUE_GENERIC_TYPE v) {
		int pos;

		if (KEY_EQUALS_NULL(k)) {
			if (containsNullKey) {
				moveIndexToFirst(n);
				return setValue(n, v);
			}
			containsNullKey = true;
			pos = n;
		}
		else {
			KEY_GENERIC_TYPE curr;
			final KEY_GENERIC_TYPE[] key = this.key;

			// The starting point.
			if (! KEY_IS_NULL(curr = key[pos = KEY2INTHASH(k) & mask])) {
				if (KEY_EQUALS_NOT_NULL(curr, k)) {
					moveIndexToFirst(pos);
					return setValue(pos, v);
				}
				while(! KEY_IS_NULL(curr = key[pos = (pos + 1) & mask]))
					if (KEY_EQUALS_NOT_NULL(curr, k)) {
						moveIndexToFirst(pos);
						return setValue(pos, v);
					}
			}
		}

		key[pos] = k;
		value[pos] = v;

		if (size == 0) {
			first = last = pos;
			// Special case of SET_UPPER_LOWER(link[pos], -1, -1);
			link[pos] = -1L;
		}
		else {
			SET_PREV(link[first], pos);
			SET_UPPER_LOWER(link[pos], -1, first);
			first = pos;
		}

		if (size++ >= maxFill) rehash(arraySize(size, f));
		if (ASSERTS) checkTable();
		return defRetValue;
	}

	/** Adds a pair to the map; if the key is already present, it is moved to the last position of the iteration order.
	 *
	 * @param k the key.
	 * @param v the value.
	 * @return the old value, or the {@linkplain #defaultReturnValue() default return value} if no value was present for the given key.
	 */
	public VALUE_GENERIC_TYPE putAndMoveToLast(final KEY_GENERIC_TYPE k, final VALUE_GENERIC_TYPE v) {
		int pos;

		if (KEY_EQUALS_NULL(k)) {
			if (containsNullKey) {
				moveIndexToLast(n);
				return setValue(n, v);
			}
			containsNullKey = true;
			pos = n;
		}
		else {
			KEY_GENERIC_TYPE curr;
			final KEY_GENERIC_TYPE[] key = this.key;

			// The starting point.
			if (! KEY_IS_NULL(curr = key[pos = KEY2INTHASH(k) & mask])) {
				if (KEY_EQUALS_NOT_NULL(curr, k)) {
					moveIndexToLast(pos);
					return setValue(pos, v);
				}
				while(! KEY_IS_NULL(curr = key[pos = (pos + 1) & mask]))
					if (KEY_EQUALS_NOT_NULL(curr, k)) {
						moveIndexToLast(pos);
						return setValue(pos, v);
					}
			}
		}

		key[pos] = k;
		value[pos] = v;

		if (size == 0) {
			first = last = pos;
			// Special case of SET_UPPER_LOWER(link[pos], -1, -1);
			link[pos] = -1L;
		}
		else {
			SET_NEXT(link[last], pos);
			SET_UPPER_LOWER(link[pos], last, -1);
			last = pos;
		}

		if (size++ >= maxFill) rehash(arraySize(size, f));
		if (ASSERTS) checkTable();
		return defRetValue;
	}

#endif

	@Override
	SUPPRESS_WARNINGS_KEY_UNCHECKED
	public VALUE_GENERIC_TYPE GET_VALUE(final KEY_TYPE k) {
		if (KEY_EQUALS_NULL(KEY_GENERIC_CAST k)) return containsNullKey ? value[n] : defRetValue;

		KEY_GENERIC_TYPE curr;
		final KEY_GENERIC_TYPE[] key = this.key;
		int pos;

		// The starting point.
		if (KEY_IS_NULL(curr = key[pos = KEY2INTHASH_CAST(k) & mask])) return defRetValue;
		if (KEY_EQUALS_NOT_NULL_CAST(k, curr)) return value[pos];
		// There's always an unused entry.
		while(true) {
			if (KEY_IS_NULL(curr = key[pos = (pos + 1) & mask])) return defRetValue;
			if (KEY_EQUALS_NOT_NULL_CAST(k, curr)) return value[pos];
		}
	}

	@Override
	SUPPRESS_WARNINGS_KEY_UNCHECKED
	public boolean containsKey(final KEY_TYPE k) {
		if (KEY_EQUALS_NULL(KEY_GENERIC_CAST k)) return containsNullKey;

		KEY_GENERIC_TYPE curr;
		final KEY_GENERIC_TYPE[] key = this.key;
		int pos;

		// The starting point.
		if (KEY_IS_NULL(curr = key[pos = KEY2INTHASH_CAST(k) & mask])) return false;
		if (KEY_EQUALS_NOT_NULL_CAST(k, curr)) return true;
		// There's always an unused entry.
		while(true) {
			if (KEY_IS_NULL(curr = key[pos = (pos + 1) & mask])) return false;
			if (KEY_EQUALS_NOT_NULL_CAST(k, curr)) return true;
		}
	}


	@Override
	public boolean containsValue(final VALUE_TYPE v) {
		final VALUE_GENERIC_TYPE value[] = this.value;
		final KEY_GENERIC_TYPE key[] = this.key;
		if (containsNullKey && VALUE_EQUALS(value[n], v)) return true;
		for(int i = n; i-- != 0;) if (! KEY_IS_NULL(key[i]) && VALUE_EQUALS(value[i], v)) return true;
		return false;
	}


	/** {@inheritDoc} */
	@Override
	SUPPRESS_WARNINGS_KEY_UNCHECKED
	public VALUE_GENERIC_TYPE getOrDefault(final KEY_TYPE k, final VALUE_GENERIC_TYPE defaultValue) {
		if (KEY_EQUALS_NULL(KEY_GENERIC_CAST k)) return containsNullKey ? value[n] : defaultValue;

		KEY_GENERIC_TYPE curr;
		final KEY_GENERIC_TYPE[] key = this.key;
		int pos;

		// The starting point.
		if (KEY_IS_NULL(curr = key[pos = KEY2INTHASH_CAST(k) & mask])) return defaultValue;
		if (KEY_EQUALS_NOT_NULL_CAST(k, curr)) return value[pos];
		// There's always an unused entry.
		while(true) {
			if (KEY_IS_NULL(curr = key[pos = (pos + 1) & mask])) return defaultValue;
			if (KEY_EQUALS_NOT_NULL_CAST(k, curr)) return value[pos];
		}
	}

	/** {@inheritDoc} */
	@Override
	public VALUE_GENERIC_TYPE putIfAbsent(final KEY_GENERIC_TYPE k, final VALUE_GENERIC_TYPE v) {
		final int pos = find(k);
		if (pos >= 0) return value[pos];
		insert(-pos - 1, k, v);
		return defRetValue;
	}

	/** {@inheritDoc} */
	@Override
	SUPPRESS_WARNINGS_KEY_UNCHECKED
	public boolean remove(final KEY_TYPE k, final VALUE_TYPE v) {
		if (KEY_EQUALS_NULL(KEY_GENERIC_CAST k)) {
			if (containsNullKey && VALUE_EQUALS(v, value[n])) {
				removeNullEntry();
				return true;
			}
			return false;
		}

		KEY_GENERIC_TYPE curr;
		final KEY_GENERIC_TYPE[] key = this.key;
		int pos;

		// The starting point.
		if (KEY_IS_NULL(curr = key[pos = KEY2INTHASH_CAST(k) & mask])) return false;
		if (KEY_EQUALS_NOT_NULL_CAST(k, curr) && VALUE_EQUALS(v, value[pos])) {
			removeEntry(pos);
			return true;
		}
		while(true) {
			if (KEY_IS_NULL(curr = key[pos = (pos + 1) & mask])) return false;
			if (KEY_EQUALS_NOT_NULL_CAST(k, curr) && VALUE_EQUALS(v, value[pos])) {
				removeEntry(pos);
				return true;
			}
		}
	}

	/** {@inheritDoc} */
	@Override
	public boolean replace(final KEY_GENERIC_TYPE k, final VALUE_GENERIC_TYPE oldValue, final VALUE_GENERIC_TYPE v) {
		final int pos = find(k);
		if (pos < 0 || ! VALUE_EQUALS(oldValue, value[pos])) return false;
		value[pos] = v;
		return true;
	}

	/** {@inheritDoc} */
	@Override
	public VALUE_GENERIC_TYPE replace(final KEY_GENERIC_TYPE k, final VALUE_GENERIC_TYPE v) {
		final int pos = find(k);
		if (pos < 0) return defRetValue;
		final VALUE_GENERIC_TYPE oldValue = value[pos];
		value[pos] = v;
		return oldValue;
	}


#ifdef JDK_PRIMITIVE_FUNCTION

	/** {@inheritDoc} */
	@Override
	public VALUE_GENERIC_TYPE computeIfAbsent(final KEY_GENERIC_TYPE k, final JDK_PRIMITIVE_FUNCTION KEY_SUPER_GENERIC_VALUE_EXTENDS_GENERIC mappingFunction) {
		java.util.Objects.requireNonNull(mappingFunction);
		final int pos = find(k);
		if (pos >= 0) return value[pos];
		final VALUE_GENERIC_TYPE newValue = VALUE_NARROWING(mappingFunction.JDK_PRIMITIVE_FUNCTION_APPLY(k));
		insert(-pos -1, k, newValue);
		return newValue;
	}

#endif

	/** {@inheritDoc} */
	@Override
	public VALUE_GENERIC_TYPE computeIfAbsent(final KEY_GENERIC_TYPE key, final FUNCTION KEY_SUPER_GENERIC_VALUE_EXTENDS_GENERIC mappingFunction) {
		java.util.Objects.requireNonNull(mappingFunction);
		final int pos = find(key);
		if (pos >= 0) return value[pos];

		if (!mappingFunction.containsKey(key)) return defRetValue;
		final VALUE_GENERIC_TYPE newValue = mappingFunction.GET_VALUE(key);
		insert(-pos -1, key, newValue);
		return newValue;
	}


#if KEYS_PRIMITIVE && VALUES_PRIMITIVE

	/** {@inheritDoc} */
	@Override
	public VALUE_GENERIC_TYPE computeIfAbsentNullable(final KEY_GENERIC_TYPE k, final JDK_KEY_TO_GENERIC_FUNCTION<? extends VALUE_GENERIC_CLASS> mappingFunction) {
		java.util.Objects.requireNonNull(mappingFunction);
		final int pos = find(k);
		if (pos >= 0) return value[pos];
		final VALUE_GENERIC_CLASS newValue = mappingFunction.apply(k);
		if (newValue == null) return defRetValue;
		final VALUE_GENERIC_TYPE v = VALUE_CLASS2TYPE(newValue);
		insert(-pos - 1, k, v);
		return v;
	}

#endif

	/** {@inheritDoc} */
	@Override
	public VALUE_GENERIC_TYPE COMPUTE_IF_PRESENT(final KEY_GENERIC_TYPE k, final java.util.function.BiFunction<? super KEY_GENERIC_CLASS, ? super VALUE_GENERIC_CLASS, ? extends VALUE_GENERIC_CLASS> remappingFunction) {
		java.util.Objects.requireNonNull(remappingFunction);
		final int pos = find(k);
		if (pos < 0) return defRetValue;
#if VALUES_REFERENCE
		if (value[pos] == null) return defRetValue;
#endif
		final VALUE_GENERIC_CLASS newValue = remappingFunction.apply(KEY2OBJ(k), VALUE2OBJ(value[pos]));
		if (newValue == null) {
			if (KEY_EQUALS_NULL(k)) removeNullEntry();
			else removeEntry(pos);
			return defRetValue;
		}
		return value[pos] = VALUE_CLASS2TYPE(newValue);
	}

	/** {@inheritDoc} */
	@Override
	public VALUE_GENERIC_TYPE COMPUTE(final KEY_GENERIC_TYPE k, final java.util.function.BiFunction<? super KEY_GENERIC_CLASS, ? super VALUE_GENERIC_CLASS, ? extends VALUE_GENERIC_CLASS> remappingFunction) {
		java.util.Objects.requireNonNull(remappingFunction);
		final int pos = find(k);
		final VALUE_GENERIC_CLASS newValue = remappingFunction.apply(KEY2OBJ(k), pos >= 0 ? VALUE2OBJ(value[pos]) : null);
		if (newValue == null) {
			if (pos >= 0) {
				if (KEY_EQUALS_NULL(k)) removeNullEntry();
				else removeEntry(pos);
			}
			return defRetValue;
		}

		VALUE_GENERIC_TYPE newVal = VALUE_CLASS2TYPE(newValue);
		if (pos < 0) {
			insert(-pos - 1, k, newVal);
			return newVal;
		}

		return value[pos] = newVal;
	}

	/** {@inheritDoc} */
	@Override
	public VALUE_GENERIC_TYPE merge(final KEY_GENERIC_TYPE k, final VALUE_GENERIC_TYPE v, final java.util.function.BiFunction<? super VALUE_GENERIC_CLASS, ? super VALUE_GENERIC_CLASS, ? extends VALUE_GENERIC_CLASS> remappingFunction) {
		java.util.Objects.requireNonNull(remappingFunction);
		REQUIRE_VALUE_NON_NULL(v)

		final int pos = find(k);
#if VALUES_PRIMITIVE
		if (pos < 0) {
#else
		if (pos < 0 || value[pos] == null) {
#endif
			if (pos < 0) insert(-pos - 1, k, v);
			else value[pos] = v;
			
			return v;
		}

		final VALUE_GENERIC_CLASS newValue = remappingFunction.apply(VALUE2OBJ(value[pos]), VALUE2OBJ(v));
		if (newValue == null) {
			if (KEY_EQUALS_NULL(k)) removeNullEntry();
			else removeEntry(pos);
			return defRetValue;
		}

		return value[pos] = VALUE_CLASS2TYPE(newValue);
	}


	/* Removes all elements from this map.
	 *
	 * <p>To increase object reuse, this method does not change the table size.
	 * If you want to reduce the table size, you must use {@link #trim()}.
	 *
	 */
	@Override
	public void clear() {
		if (size == 0) return;
		size = 0;
		containsNullKey = false;

		Arrays.fill(key, KEY_NULL);
#if VALUES_REFERENCE
		Arrays.fill(value, null);
#endif

#ifdef Linked
		first = last = -1;
#endif
	}

	@Override
	public int size() {
		return size;
	}

	@Override
	public boolean isEmpty() {
		return size == 0;
	}


	/** The entry class for a hash map does not record key and value, but
	 * rather the position in the hash table of the corresponding entry. This
	 * is necessary so that calls to {@link java.util.Map.Entry#setValue(Object)} are reflected in
	 * the map */

	final class MapEntry implements MAP.Entry KEY_VALUE_GENERIC, Map.Entry<KEY_GENERIC_CLASS, VALUE_GENERIC_CLASS>, PAIR KEY_VALUE_GENERIC {
		// The table index this entry refers to, or -1 if this entry has been deleted.
		int index;

		MapEntry(final int index) {
			this.index = index;
		}

		MapEntry() {}

		@Override
		public KEY_GENERIC_TYPE ENTRY_GET_KEY() {
	   		return key[index];
		}

		@Override
		public KEY_GENERIC_TYPE PAIR_LEFT() {
	   		return key[index];
		}

		@Override
		public VALUE_GENERIC_TYPE ENTRY_GET_VALUE() {
			return value[index];
		}

		@Override
		public VALUE_GENERIC_TYPE PAIR_RIGHT() {
			return value[index];
		}

		@Override
		public VALUE_GENERIC_TYPE setValue(final VALUE_GENERIC_TYPE v) {
			final VALUE_GENERIC_TYPE oldValue = value[index];
			value[index] = v;
			return oldValue;
		}

		@Override
		public PAIR KEY_VALUE_GENERIC right(final VALUE_GENERIC_TYPE v) {
			value[index] = v;
			return this;
		}

#if KEYS_PRIMITIVE
		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public KEY_GENERIC_CLASS getKey() {
			return KEY2OBJ(key[index]);
		}
#endif

#if VALUES_PRIMITIVE
		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public VALUE_GENERIC_CLASS getValue() {
			return VALUE2OBJ(value[index]);
		}

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public VALUE_GENERIC_CLASS setValue(final VALUE_GENERIC_CLASS v) {
			return VALUE2OBJ(setValue(VALUE_CLASS2TYPE(v)));
		}
#endif

		@SuppressWarnings("unchecked")
		@Override
		public boolean equals(final Object o) {
			if (!(o instanceof Map.Entry)) return false;
			Map.Entry<KEY_GENERIC_CLASS, VALUE_GENERIC_CLASS> e = (Map.Entry<KEY_GENERIC_CLASS, VALUE_GENERIC_CLASS>)o;

			return KEY_EQUALS(key[index], KEY_CLASS2TYPE(e.getKey())) && VALUE_EQUALS(value[index], VALUE_CLASS2TYPE(e.getValue()));
		}

		@Override
		public int hashCode() {
			return KEY2JAVAHASH(key[index]) ^ VALUE2JAVAHASH(value[index]);
		}

		@Override
		public String toString() {
			return key[index] + "=>" + value[index];
		}
	}


#ifdef Linked

	/** Modifies the {@link #link} vector so that the given entry is removed.
	 * This method will complete in constant time.
	 *
	 * @param i the index of an entry.
	 */
	protected void fixPointers(final int i) {
		if (size == 0) {
			first = last = -1;
			return;
		}
		if (first == i) {
			first = GET_NEXT(link[i]);
			if (0 <= first) {
				// Special case of SET_PREV(link[first], -1)
				link[first] |= (-1 & 0xFFFFFFFFL) << 32;
			}
			return;
		}
		if (last == i) {
			last = GET_PREV(link[i]);
			if (0 <= last) {
				// Special case of SET_NEXT(link[last], -1)
				link[last] |= -1 & 0xFFFFFFFFL;
			}
			return;
		}
		final long linki = link[i];
		final int prev = GET_PREV(linki);
		final int next = GET_NEXT(linki);
		COPY_NEXT(link[prev], linki);
		COPY_PREV(link[next], linki);
	}


	/** Modifies the {@link #link} vector for a shift from s to d.
	 * <p>This method will complete in constant time.
	 *
	 * @param s the source position.
	 * @param d the destination position.
	 */
	protected void fixPointers(int s, int d) {
		if (size == 1) {
			first = last = d;
			// Special case of SET_UPPER_LOWER(link[d], -1, -1)
			link[d] = -1L;
			return;
		}
		if (first == s) {
			first = d;
			SET_PREV(link[GET_NEXT(link[s])], d);
			link[d] = link[s];
			return;
		}
		if (last == s) {
			last = d;
			SET_NEXT(link[GET_PREV(link[s])], d);
			link[d] = link[s];
			return;
		}
		final long links = link[s];
		final int prev = GET_PREV(links);
		final int next = GET_NEXT(links);
		SET_NEXT(link[prev], d);
		SET_PREV(link[next], d);
		link[d] = links;
	}


	/** Returns the first key of this map in iteration order.
	 *
	 * @return the first key in iteration order.
	 */
	@Override
	public KEY_GENERIC_TYPE FIRST_KEY() {
		if (size == 0) throw new NoSuchElementException();
		return key[first];
	}


	/** Returns the last key of this map in iteration order.
	 *
	 * @return the last key in iteration order.
	 */
	@Override
	public KEY_GENERIC_TYPE LAST_KEY() {
		if (size == 0) throw new NoSuchElementException();
		return key[last];
	}

	/** {@inheritDoc}
	 * @implSpec This implementation just throws an {@link UnsupportedOperationException}.*/
	@Override
	public SORTED_MAP KEY_VALUE_GENERIC tailMap(KEY_GENERIC_TYPE from) { throw new UnsupportedOperationException(); }

	/** {@inheritDoc}
	 * @implSpec This implementation just throws an {@link UnsupportedOperationException}.*/
	@Override
	public SORTED_MAP KEY_VALUE_GENERIC headMap(KEY_GENERIC_TYPE to) { throw new UnsupportedOperationException(); }

	/** {@inheritDoc}
	 * @implSpec This implementation just throws an {@link UnsupportedOperationException}.*/
	@Override
	public SORTED_MAP KEY_VALUE_GENERIC subMap(KEY_GENERIC_TYPE from, KEY_GENERIC_TYPE to) { throw new UnsupportedOperationException(); }

	/** {@inheritDoc}
	 * @implSpec This implementation just returns {@code null}.*/
	@Override
	public KEY_COMPARATOR KEY_SUPER_GENERIC comparator() { return null; }

	/** A list iterator over a linked map.
	 *
	 * <p>This class provides a list iterator over a linked hash map. The constructor runs in constant time.
	 */
	private abstract class MapIterator<ConsumerType> {
		/** The entry that will be returned by the next call to {@link java.util.ListIterator#previous()} (or {@code null} if no previous entry exists). */
		int prev = -1;
		/** The entry that will be returned by the next call to {@link java.util.ListIterator#next()} (or {@code null} if no next entry exists). */
		int next = -1;
		/** The last entry that was returned (or -1 if we did not iterate or used {@link java.util.Iterator#remove()}). */
		int curr = -1;
		/** The current index (in the sense of a {@link java.util.ListIterator}). Note that this value is not meaningful when this iterator has been created using the nonempty constructor.*/
		int index = -1;

		@SuppressWarnings("unused")
		abstract void acceptOnIndex(final ConsumerType action, final int index);

		protected MapIterator() {
			next = first;
			index = 0;
		}

		private MapIterator(final KEY_GENERIC_TYPE from) {
			if (KEY_EQUALS_NULL(from)) {
				if (OPEN_HASH_MAP.this.containsNullKey) {
					next = GET_NEXT(link[n]);
					prev = n;
					return;
				}
				else throw new NoSuchElementException("The key " + from + " does not belong to this map.");
			}

			if (KEY_EQUALS(key[last], from)) {
				prev = last;
				index = size;
				return;
			}

			// The starting point.
			int pos = KEY2INTHASH(from) & mask;

			// There's always an unused entry.
			while(! KEY_IS_NULL(key[pos])) {
				if (KEY_EQUALS_NOT_NULL(key[pos], from)) {
					// Note: no valid index known.
					next = GET_NEXT(link[pos]);
					prev = pos;
					return;
				}
				pos = (pos + 1) & mask;
			}
			throw new NoSuchElementException("The key " + from + " does not belong to this map.");
		}

		public boolean hasNext() { return next != -1; }

		public boolean hasPrevious() { return prev != -1; }

		private final void ensureIndexKnown() {
			if (index >= 0) return;
			if (prev == -1) {
				index = 0;
				return;
			}
			if (next == -1) {
				index = size;
				return;
			}
			int pos = first;
			index = 1;
			while(pos != prev) {
				pos = GET_NEXT(link[pos]);
				index++;
			}
		}

		public int nextIndex() {
			ensureIndexKnown();
			return index;
		}

		public int previousIndex() {
			ensureIndexKnown();
			return index - 1;
		}

		public int nextEntry() {
			if (! hasNext()) throw new NoSuchElementException();

			curr = next;
			next = GET_NEXT(link[curr]);
			prev = curr;

			if (index >= 0) index++;

			return curr;
		}

		public int previousEntry() {
			if (! hasPrevious()) throw new NoSuchElementException();

			curr = prev;
			prev = GET_PREV(link[curr]);
			next = curr;

			if (index >= 0) index--;

			return curr;
		}

		public void forEachRemaining(final ConsumerType action) {
			while (hasNext()) {
				curr = next;
				next = GET_NEXT(link[curr]);
				prev = curr;

				if (index >= 0) index++;

				acceptOnIndex(action, curr);
			}
		}

		public void remove() {
			ensureIndexKnown();
			if (curr == -1) throw new IllegalStateException();

			if (curr == prev) {
				/* If the last operation was a next(), we are removing an entry that preceeds
				   the current index, and thus we must decrement it. */
				index--;
				prev = GET_PREV(link[curr]);
			}
			else
				next = GET_NEXT(link[curr]);

			size--;
			/* Now we manually fix the pointers. Because of our knowledge of next
			   and prev, this is going to be faster than calling fixPointers(). */
			if (prev == -1) first = next;
			else
				SET_NEXT(link[prev], next);
			if (next == -1) last = prev;
			else
				SET_PREV(link[next], prev);

			int last, slot, pos = curr;
			curr = -1;

			if (pos == n) {
				OPEN_HASH_MAP.this.containsNullKey = false;
#if KEYS_REFERENCE
				key[n] = null;
#endif
#if VALUES_REFERENCE
				value[n] = null;
#endif
			}
			else {
				KEY_GENERIC_TYPE curr;
				final KEY_GENERIC_TYPE[] key = OPEN_HASH_MAP.this.key;
				// We have to horribly duplicate the shiftKeys() code because we need to update next/prev.
				for(;;) {
					pos = ((last = pos) + 1) & mask;
					for(;;) {
						if (KEY_IS_NULL(curr = key[pos])) {
							key[last] = KEY_NULL;
#if VALUES_REFERENCE
							value[last] = null;
#endif
							return;
						}
						slot = KEY2INTHASH(curr) & mask;
						if (last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos) break;
						pos = (pos + 1) & mask;
					}

					key[last] = curr;
					value[last] = value[pos];
					if (next == pos) next = last;
					if (prev == pos) prev = last;
					fixPointers(pos, last);
				}
			}
		}

		public int skip(final int n) {
			int i = n;
			while(i-- != 0 && hasNext()) nextEntry();
			return n - i - 1;
		}

		public int back(final int n) {
			int i = n;
			while(i-- != 0 && hasPrevious()) previousEntry();
			return n - i - 1;
		}

		public void set(@SuppressWarnings("unused") MAP.Entry KEY_VALUE_GENERIC ok) {
			throw new UnsupportedOperationException();
		}

		public void add(@SuppressWarnings("unused") MAP.Entry KEY_VALUE_GENERIC ok) {
			throw new UnsupportedOperationException();
		}
	}

	private final class EntryIterator extends MapIterator<Consumer<? super MAP.Entry KEY_VALUE_GENERIC>> implements ObjectListIterator<MAP.Entry KEY_VALUE_GENERIC> {
		private MapEntry entry;

		public EntryIterator() {}

		public EntryIterator(KEY_GENERIC_TYPE from) {
			super(from);
		}

		// forEachRemaining inherited from MapIterator superclass.

		@Override
		final void acceptOnIndex(final Consumer<? super MAP.Entry KEY_VALUE_GENERIC> action, final int index) {
			action.accept(new MapEntry(index));
		}

		@Override
		public MapEntry next() {
			return entry = new MapEntry(nextEntry());
		}

		@Override
		public MapEntry previous() {
			return entry = new MapEntry(previousEntry());
		}

		@Override
		public void remove() {
			super.remove();
			entry.index = -1; // You cannot use a deleted entry.
		}
	}

	private final class FastEntryIterator extends MapIterator<Consumer<? super MAP.Entry KEY_VALUE_GENERIC>> implements ObjectListIterator<MAP.Entry KEY_VALUE_GENERIC> {
		final MapEntry entry = new MapEntry();

		public FastEntryIterator() {}

		public FastEntryIterator(KEY_GENERIC_TYPE from) {
			super(from);
		}
		
		// forEachRemaining inherited from MapIterator superclass.

		@Override
		final void acceptOnIndex(final Consumer<? super MAP.Entry KEY_VALUE_GENERIC> action, final int index) {
			entry.index = index;
			action.accept(entry);
		}

		@Override
		public MapEntry next() {
			entry.index = nextEntry();
			return entry;
		}

		@Override
		public MapEntry previous() {
			entry.index = previousEntry();
			return entry;
		}
	}

#else

	/** An iterator over a hash map. */

	private abstract class MapIterator<ConsumerType> {
		/** The index of the last entry returned, if positive or zero; initially, {@link #n}. If negative, the last
			entry returned was that of the key of index {@code - pos - 1} from the {@link #wrapped} list. */
		int pos = n;
		/** The index of the last entry that has been returned (more precisely, the value of {@link #pos} if {@link #pos} is positive,
			or {@link Integer#MIN_VALUE} if {@link #pos} is negative). It is -1 if either
			we did not return an entry yet, or the last returned entry has been removed. */
		int last = -1;
		/** A downward counter measuring how many entries must still be returned. */
		int c = size;
		/** A boolean telling us whether we should return the entry with the null key. */
		boolean mustReturnNullKey = OPEN_HASH_MAP.this.containsNullKey;
		/** A lazily allocated list containing keys of entries that have wrapped around the table because of removals. */
		ARRAY_LIST KEY_GENERIC wrapped;

		@SuppressWarnings("unused")
		abstract void acceptOnIndex(final ConsumerType action, final int index);

		public boolean hasNext() {
			return c != 0;
		}

		public int nextEntry() {
			if (! hasNext()) throw new NoSuchElementException();

			c--;
			if (mustReturnNullKey) {
				mustReturnNullKey = false;
				return last = n;
			}

			final KEY_GENERIC_TYPE key[] = OPEN_HASH_MAP.this.key;

			for(;;) {
				if (--pos < 0) {
					// We are just enumerating elements from the wrapped list.
					last = Integer.MIN_VALUE;
					final KEY_GENERIC_TYPE k = wrapped.GET_KEY(- pos - 1);
					int p = KEY2INTHASH(k) & mask;
					while (! KEY_EQUALS_NOT_NULL(k, key[p])) p = (p + 1) & mask;
					return p;
				}
				if (! KEY_IS_NULL(key[pos])) return last = pos;
			}
		}

		public void forEachRemaining(final ConsumerType action) {
			if (mustReturnNullKey) {
				mustReturnNullKey = false;
				acceptOnIndex(action, last = n);
				c--;
			}

			final KEY_GENERIC_TYPE key[] = OPEN_HASH_MAP.this.key;

			while (c != 0) {
				if (--pos < 0) {
					// We are just enumerating elements from the wrapped list.
					last = Integer.MIN_VALUE;
					final KEY_GENERIC_TYPE k = wrapped.GET_KEY(- pos - 1);
					int p = KEY2INTHASH(k) & mask;
					while (! KEY_EQUALS_NOT_NULL(k, key[p])) p = (p + 1) & mask;
					acceptOnIndex(action, p);
					c--;
				} else if (! KEY_IS_NULL(key[pos])) {
					acceptOnIndex(action, last = pos);
					c--;
				}
			}
		}

		/** Shifts left entries with the specified hash code, starting at the specified position,
		 * and empties the resulting free entry.
		 *
		 * @param pos a starting position.
		 */
		private void shiftKeys(int pos) {
			// Shift entries with the same hash.
			int last, slot;
			KEY_GENERIC_TYPE curr;
			final KEY_GENERIC_TYPE[] key = OPEN_HASH_MAP.this.key;

			for(;;) {
				pos = ((last = pos) + 1) & mask;

				for(;;) {
					if (KEY_IS_NULL(curr = key[pos])) {
						key[last] = KEY_NULL;
#if VALUES_REFERENCE
						value[last] = null;
#endif
						return;
					}
					slot = KEY2INTHASH(curr) & mask;
					if (last <= pos ? last >= slot || slot > pos : last >= slot && slot > pos) break;
					pos = (pos + 1) & mask;
				}

				if (pos < last) { // Wrapped entry.
					if (wrapped == null) wrapped = new ARRAY_LIST KEY_GENERIC_DIAMOND(2);
					wrapped.add(key[pos]);
				}

				key[last] = curr;
				value[last] = value[pos];
			}
		}

		public void remove() {
			if (last == -1) throw new IllegalStateException();
			if (last == n) {
				containsNullKey = false;
#if KEYS_REFERENCE
				key[n] = null;
#endif
#if VALUES_REFERENCE
				value[n] = null;
#endif
			}
			else if (pos >= 0) shiftKeys(last);
			else {
				// We're removing wrapped entries.
#if KEYS_REFERENCE
				OPEN_HASH_MAP.this.REMOVE_VALUE(wrapped.set(- pos - 1, null));
#else
				OPEN_HASH_MAP.this.REMOVE_VALUE(wrapped.GET_KEY(- pos - 1));
#endif
				last = -1; // Note that we must not decrement size
				return;
			}

			size--;
			last = -1; // You can no longer remove this entry.
			if (ASSERTS) checkTable();
		}

		public int skip(final int n) {
			int i = n;
			while(i-- != 0 && hasNext()) nextEntry();
			return n - i - 1;
		}
	}


	private final class EntryIterator extends MapIterator<Consumer<? super MAP.Entry KEY_VALUE_GENERIC>> implements ObjectIterator<MAP.Entry KEY_VALUE_GENERIC> {
		private MapEntry entry;

		@Override
		public MapEntry next() {
			return entry = new MapEntry(nextEntry());
		}
		
		// forEachRemaining inherited from MapIterator superclass.

		@Override
		final void acceptOnIndex(final Consumer<? super MAP.Entry KEY_VALUE_GENERIC> action, final int index) {
			action.accept(entry = new MapEntry(index));
		}

		@Override
		public void remove() {
			super.remove();
			entry.index = -1; // You cannot use a deleted entry.
		}
	}

	private final class FastEntryIterator extends MapIterator<Consumer<? super MAP.Entry KEY_VALUE_GENERIC>> implements ObjectIterator<MAP.Entry KEY_VALUE_GENERIC> {
		private final MapEntry entry = new MapEntry();

		@Override
		public MapEntry next() {
			entry.index = nextEntry();
			return entry;
		}

		// forEachRemaining inherited from MapIterator superclass.

		@Override
		final void acceptOnIndex(final Consumer<? super MAP.Entry KEY_VALUE_GENERIC> action, final int index) {
			entry.index = index;
			action.accept(entry);
		}
	}

	private abstract class MapSpliterator<ConsumerType, SplitType extends MapSpliterator<ConsumerType, SplitType>> {
		/** The index (which bucket) of the next item to give to the action.
		 * Unlike {@link SetIterator}, this counts up instead of down.
		 */
		int pos = 0;
		/** The maximum bucket (exclusive) to iterate to */
		int max = n;
		/** An upwards counter counting how many we have given */
		int c = 0;
		/** A boolean telling us whether we should return the null key. */
		boolean mustReturnNull = OPEN_HASH_MAP.this.containsNullKey;
		boolean hasSplit = false;

		MapSpliterator() {}

		MapSpliterator(int pos, int max, boolean mustReturnNull, boolean hasSplit) {
			this.pos = pos;
			this.max = max;
			this.mustReturnNull = mustReturnNull;
			this.hasSplit = hasSplit;
		}

		abstract void acceptOnIndex(final ConsumerType action, final int index);

		abstract SplitType makeForSplit(int pos, int max, boolean mustReturnNull);

		public boolean tryAdvance(final ConsumerType action) {
			if (mustReturnNull) {
				mustReturnNull = false;
				++c;
				acceptOnIndex(action, n);
				return true;
			}
			final KEY_GENERIC_TYPE key[] = OPEN_HASH_MAP.this.key;
			while (pos < max) {
				if (! KEY_IS_NULL(key[pos])) {
					++c;
					acceptOnIndex(action, pos++);
					return true;
				}
				++pos;
			}
			return false;
		}

		public void forEachRemaining(final ConsumerType action) {
			if (mustReturnNull) {
				mustReturnNull = false;
				++c;
				acceptOnIndex(action, n);
			}

			final KEY_GENERIC_TYPE key[] = OPEN_HASH_MAP.this.key;

			while (pos < max) {
				if (! KEY_IS_NULL(key[pos])) {
					acceptOnIndex(action, pos);
					++c;
				}
				++pos;
			}
		}

		public long estimateSize() {
			if (!hasSplit) {
				// Root spliterator; we know how many are remaining.
				return size - c;
			} else {
				// After we split, we can no longer know exactly how many we have (or at least not efficiently).
				// (size / n) * (max - pos) aka currentTableDensity * numberOfBucketsLeft seems like a good estimate.
				return Math.min(size - c, (long)(((double)realSize() / n) * (max - pos)) + (mustReturnNull ? 1 : 0));
			}
		}

		public SplitType trySplit() {
			if (pos >= max - 1) return null;
			int retLen = (max - pos) >> 1;
			if (retLen <= 1) return null;
			int myNewPos = pos + retLen;
			int retPos = pos;
			int retMax = myNewPos;
			// Since null is returned first, and the convention is that the returned split is the prefix of elements,
			// the split will take care of returning null (if needed), and we won't return it anymore.
			SplitType split = makeForSplit(retPos, retMax, mustReturnNull);
			this.pos = myNewPos;
			this.mustReturnNull = false;
			this.hasSplit = true;
			return split;
		}

		public long skip(long n) {
			if (n < 0) throw new IllegalArgumentException("Argument must be nonnegative: " + n);
			if (n == 0) return 0;
			long skipped = 0;
			if (mustReturnNull) {
				mustReturnNull = false;
				++skipped;
				--n;
			}
			final KEY_GENERIC_TYPE key[] = OPEN_HASH_MAP.this.key;
			while (pos < max && n > 0) {
				if (! KEY_IS_NULL(key[pos++])) {
					++skipped;
					--n;
				}
			}
			return skipped;
		}
	}

	private final class EntrySpliterator extends MapSpliterator<Consumer<? super MAP.Entry KEY_VALUE_GENERIC>, EntrySpliterator> implements ObjectSpliterator<MAP.Entry KEY_VALUE_GENERIC> {

		private static final int POST_SPLIT_CHARACTERISTICS = ObjectSpliterators.SET_SPLITERATOR_CHARACTERISTICS & ~java.util.Spliterator.SIZED;

		EntrySpliterator() {}

		EntrySpliterator(int pos, int max, boolean mustReturnNull, boolean hasSplit) {
			super(pos, max, mustReturnNull, hasSplit);
		}

		@Override
		public int characteristics() {
			return hasSplit ? POST_SPLIT_CHARACTERISTICS : ObjectSpliterators.SET_SPLITERATOR_CHARACTERISTICS;
		}

		@Override
		final void acceptOnIndex(final Consumer<? super MAP.Entry KEY_VALUE_GENERIC> action, final int index) {
			action.accept(new MapEntry(index));
		}

		@Override
		final EntrySpliterator makeForSplit(int pos, int max, boolean mustReturnNull) {
			return new EntrySpliterator(pos, max, mustReturnNull, true);
		}
	}

#endif

#ifdef Linked
	private final class MapEntrySet extends AbstractObjectSortedSet<MAP.Entry KEY_VALUE_GENERIC> implements FastSortedEntrySet KEY_VALUE_GENERIC {

		private static final int SPLITERATOR_CHARACTERISTICS = ObjectSpliterators.SET_SPLITERATOR_CHARACTERISTICS | java.util.Spliterator.ORDERED;

		@Override
		public ObjectBidirectionalIterator<MAP.Entry KEY_VALUE_GENERIC> iterator() { return new EntryIterator(); }

		/** {@inheritDoc}
		 *
		 * <p>There isn't a way to split efficiently while still preserving order for a linked data structure,
		 * so this implementation is just backed by the iterator. Thus, this spliterator is not well optimized
		 * for parallel streams.
		 *
		 * <p>Note, contrary to the specification of {@link java.util.SortedSet}, this spliterator does not,
		 * report {@link java.util.Spliterators.SORTED}. This is because iteration order is based on insertion
		 * order, not natural ordering.
		 */
		@Override
		public ObjectSpliterator<MAP.Entry KEY_VALUE_GENERIC> spliterator() {
			return ObjectSpliterators.asSpliterator(
				iterator(), it.unimi.dsi.fastutil.Size64.sizeOf(OPEN_HASH_MAP.this), SPLITERATOR_CHARACTERISTICS);
		}

		@Override
		public Comparator<? super MAP.Entry KEY_VALUE_GENERIC> comparator() { return null; }

		@Override
		public ObjectSortedSet<MAP.Entry KEY_VALUE_GENERIC> subSet(MAP.Entry KEY_VALUE_GENERIC fromElement, MAP.Entry KEY_VALUE_GENERIC toElement) { throw new UnsupportedOperationException(); }

		@Override
		public ObjectSortedSet<MAP.Entry KEY_VALUE_GENERIC> headSet(MAP.Entry KEY_VALUE_GENERIC toElement) { throw new UnsupportedOperationException(); }

		@Override
		public ObjectSortedSet<MAP.Entry KEY_VALUE_GENERIC> tailSet(MAP.Entry KEY_VALUE_GENERIC fromElement) { throw new UnsupportedOperationException(); }

		@Override
		public MAP.Entry KEY_VALUE_GENERIC first() {
			if (size == 0) throw new NoSuchElementException();
			return new MapEntry(OPEN_HASH_MAP.this.first);
		}

		@Override
		public MAP.Entry KEY_VALUE_GENERIC last() {
			if (size == 0) throw new NoSuchElementException();
			return new MapEntry(OPEN_HASH_MAP.this.last);
		}

#else
	private final class MapEntrySet extends AbstractObjectSet<MAP.Entry KEY_VALUE_GENERIC> implements FastEntrySet KEY_VALUE_GENERIC {

		@Override
		public ObjectIterator<MAP.Entry KEY_VALUE_GENERIC> iterator() { return new EntryIterator(); }

		@Override
		public ObjectIterator<MAP.Entry KEY_VALUE_GENERIC> fastIterator() { return new FastEntryIterator(); }

		@Override
		public ObjectSpliterator<MAP.Entry KEY_VALUE_GENERIC> spliterator() { return new EntrySpliterator(); }
		
		// 
#endif

		@Override
		SUPPRESS_WARNINGS_KEY_VALUE_UNCHECKED
		public boolean contains(final Object o) {
			if (!(o instanceof Map.Entry)) return false;
			final Map.Entry<?,?> e = (Map.Entry<?,?>)o;
#if KEYS_PRIMITIVE
			if (e.getKey() == null || ! (e.getKey() instanceof KEY_CLASS)) return false;
#endif
#if VALUES_PRIMITIVE
			if (e.getValue() == null || ! (e.getValue() instanceof VALUE_CLASS)) return false;
#endif
			final KEY_GENERIC_TYPE k = KEY_OBJ2TYPE(KEY_GENERIC_CAST e.getKey());
			final VALUE_GENERIC_TYPE v = VALUE_OBJ2TYPE(VALUE_GENERIC_CAST e.getValue());

			if (KEY_EQUALS_NULL(k)) return OPEN_HASH_MAP.this.containsNullKey && VALUE_EQUALS(value[n], v);

			KEY_GENERIC_TYPE curr;
			final KEY_GENERIC_TYPE[] key = OPEN_HASH_MAP.this.key;
			int pos;

			// The starting point.
			if (KEY_IS_NULL(curr = key[pos = KEY2INTHASH(k) & mask])) return false;
			if (KEY_EQUALS_NOT_NULL(k, curr)) return VALUE_EQUALS(value[pos], v);
			// There's always an unused entry.
			while(true) {
				if (KEY_IS_NULL(curr = key[pos = (pos + 1) & mask])) return false;
				if (KEY_EQUALS_NOT_NULL(k, curr)) return VALUE_EQUALS(value[pos], v);
			}
		}

		@Override
		SUPPRESS_WARNINGS_KEY_VALUE_UNCHECKED
		public boolean remove(final Object o) {
			if (!(o instanceof Map.Entry)) return false;
			final Map.Entry<?,?> e = (Map.Entry<?,?>)o;
#if KEYS_PRIMITIVE
			if (e.getKey() == null || ! (e.getKey() instanceof KEY_CLASS)) return false;
#endif
#if VALUES_PRIMITIVE
			if (e.getValue() == null || ! (e.getValue() instanceof VALUE_CLASS)) return false;
#endif
			final KEY_GENERIC_TYPE k = KEY_OBJ2TYPE(KEY_GENERIC_CAST e.getKey());
			final VALUE_GENERIC_TYPE v = VALUE_OBJ2TYPE(VALUE_GENERIC_CAST e.getValue());


			if (KEY_EQUALS_NULL(k)) {
				if (containsNullKey && VALUE_EQUALS(value[n], v)) {
					removeNullEntry();
					return true;
				}
				return false;
			}

			KEY_GENERIC_TYPE curr;
			final KEY_GENERIC_TYPE[] key = OPEN_HASH_MAP.this.key;
			int pos;

			// The starting point.
			if (KEY_IS_NULL(curr = key[pos = KEY2INTHASH(k) & mask])) return false;
			if (KEY_EQUALS_NOT_NULL(curr, k)) {
				if (VALUE_EQUALS(value[pos], v)) {
					removeEntry(pos);
					return true;
				}
				return false;
			}

			while(true) {
				if (KEY_IS_NULL(curr = key[pos = (pos + 1) & mask])) return false;
				if (KEY_EQUALS_NOT_NULL(curr, k))  {
					if (VALUE_EQUALS(value[pos], v)) {
						removeEntry(pos);
						return true;
					}
				}
			}
		}

		@Override
		public int size() {
			return size;
		}

		@Override
		public void clear() {
			OPEN_HASH_MAP.this.clear();
		}

#ifdef Linked
		/** Returns a type-specific list iterator on the elements in this set, starting from a given element of the set.
		 * Please see the class documentation for implementation details.
		 *
		 * @param from an element to start from.
		 * @return a type-specific list iterator starting at the given element.
		 * @throws IllegalArgumentException if {@code from} does not belong to the set.
		 */
		@Override
		public ObjectListIterator<MAP.Entry KEY_VALUE_GENERIC> iterator(final MAP.Entry KEY_VALUE_GENERIC from) {
			return new EntryIterator(from.ENTRY_GET_KEY());
		}

		/** Returns a type-specific fast list iterator on the elements in this set, starting from the first element.
		 * Please see the class documentation for implementation details.
		 *
		 * @return a type-specific list iterator starting at the first element.
		 */
		@Override
		public ObjectListIterator<MAP.Entry KEY_VALUE_GENERIC> fastIterator() {
			return new FastEntryIterator();
		}

		/** Returns a type-specific fast list iterator on the elements in this set, starting from a given element of the set.
		 * Please see the class documentation for implementation details.
		 *
		 * @param from an element to start from.
		 * @return a type-specific list iterator starting at the given element.
		 * @throws IllegalArgumentException if {@code from} does not belong to the set.
		 */
		@Override
		public ObjectListIterator<MAP.Entry KEY_VALUE_GENERIC> fastIterator(final MAP.Entry KEY_VALUE_GENERIC from) {
			return new FastEntryIterator(from.ENTRY_GET_KEY());
		}

		/** {@inheritDoc} */
		@Override
		public void forEach(final Consumer<? super MAP.Entry KEY_VALUE_GENERIC> consumer) {
			for(int i = size, curr, next = first; i-- != 0;) {
				curr = next;
				next = GET_NEXT(link[curr]);
				consumer.accept(new MapEntry(curr));
			}
		}

		/** {@inheritDoc} */
		@Override
		public void fastForEach(final Consumer<? super MAP.Entry KEY_VALUE_GENERIC> consumer) {
			final MapEntry entry = new MapEntry();
			for(int i = size, next = first; i-- != 0;) {
				entry.index = next;
				next = GET_NEXT(link[next]);
				consumer.accept(entry);
			}
		}

#else

		/** {@inheritDoc} */
		@Override
		public void forEach(final Consumer<? super MAP.Entry KEY_VALUE_GENERIC> consumer) {
			if (containsNullKey) consumer.accept(new MapEntry(n));
			for(int pos = n; pos-- != 0;)
				if (! KEY_IS_NULL(key[pos])) consumer.accept(new MapEntry(pos));
		}

		/** {@inheritDoc} */
		@Override
		public void fastForEach(final Consumer<? super MAP.Entry KEY_VALUE_GENERIC> consumer) {
			final MapEntry entry = new MapEntry();
			if (containsNullKey) {
				entry.index = n;
				consumer.accept(entry);
			}
			for(int pos = n; pos-- != 0;)
				if (! KEY_IS_NULL(key[pos])) {
					entry.index = pos;
					consumer.accept(entry);
				}
		}

#endif
	}


#ifdef Linked
	@Override
	public FastSortedEntrySet KEY_VALUE_GENERIC ENTRYSET() {
		if (entries == null) entries = new MapEntrySet();
#else
	@Override
	public FastEntrySet KEY_VALUE_GENERIC ENTRYSET() {
		if (entries == null) entries = new MapEntrySet();
#endif
		return entries;
	}

	/** An iterator on keys.
	 *
	 * <p>We simply override the {@link java.util.ListIterator#next()}/{@link java.util.ListIterator#previous()} methods
	 * (and possibly their type-specific counterparts) so that they return keys
	 * instead of entries.
	 */

#ifdef Linked
	private final class KeyIterator extends MapIterator<METHOD_ARG_KEY_CONSUMER> implements KEY_LIST_ITERATOR KEY_GENERIC {
		public KeyIterator(final KEY_GENERIC_TYPE k) { super(k); }

		@Override
		public KEY_GENERIC_TYPE PREV_KEY() { return key[previousEntry()]; }
#else
	private final class KeyIterator extends MapIterator<METHOD_ARG_KEY_CONSUMER> implements KEY_ITERATOR KEY_GENERIC {
#endif
		public KeyIterator() { super(); }

		// forEachRemaining inherited from MapIterator superclass.
		// Despite the superclass declared with generics, the way Java inherits and generates bridge methods avoids the boxing/unboxing

		@Override
		final void acceptOnIndex(final METHOD_ARG_KEY_CONSUMER action, final int index) {
			action.accept(key[index]);
		}
		

		@Override
		public KEY_GENERIC_TYPE NEXT_KEY() { return key[nextEntry()]; }
	}

#ifndef Linked
	private final class KeySpliterator extends MapSpliterator<METHOD_ARG_KEY_CONSUMER, KeySpliterator> implements KEY_SPLITERATOR KEY_GENERIC {

		private static final int POST_SPLIT_CHARACTERISTICS = SPLITERATORS.SET_SPLITERATOR_CHARACTERISTICS & ~java.util.Spliterator.SIZED;

		KeySpliterator() {}

		KeySpliterator(int pos, int max, boolean mustReturnNull, boolean hasSplit) {
			super(pos, max, mustReturnNull, hasSplit);
		}

		@Override
		public int characteristics() {
			return hasSplit ? POST_SPLIT_CHARACTERISTICS : SPLITERATORS.SET_SPLITERATOR_CHARACTERISTICS;
		}

		@Override
		final void acceptOnIndex(final METHOD_ARG_KEY_CONSUMER action, final int index) {
			action.accept(key[index]);
		}

		@Override
		final KeySpliterator makeForSplit(int pos, int max, boolean mustReturnNull) {
			return new KeySpliterator(pos, max, mustReturnNull, true);
		}
	}
#endif

#ifdef Linked
	private final class KeySet extends ABSTRACT_SORTED_SET KEY_GENERIC {

		private static final int SPLITERATOR_CHARACTERISTICS = SPLITERATORS.SET_SPLITERATOR_CHARACTERISTICS | java.util.Spliterator.ORDERED;

		@Override
		public KEY_LIST_ITERATOR KEY_GENERIC iterator(final KEY_GENERIC_TYPE from) { return new KeyIterator(from); }

		@Override
		public KEY_LIST_ITERATOR KEY_GENERIC iterator() { return new KeyIterator(); }

		/** {@inheritDoc}
		 * @see EntrySet#spliterator()
		 */
		@Override
		public KEY_SPLITERATOR KEY_GENERIC spliterator() {
			return SPLITERATORS.asSpliterator(
				iterator(), it.unimi.dsi.fastutil.Size64.sizeOf(OPEN_HASH_MAP.this), SPLITERATOR_CHARACTERISTICS);
		}

		/** {@inheritDoc} */
		@Override
		public void forEach(final METHOD_ARG_KEY_CONSUMER consumer) {
			for(int i = size, curr, next = first; i-- != 0;) {
				curr = next;
				next = GET_NEXT(link[curr]);
				consumer.accept(key[curr]);
			}
		}

#else
	private final class KeySet extends ABSTRACT_SET KEY_GENERIC {

		@Override
		public KEY_ITERATOR KEY_GENERIC iterator() { return new KeyIterator(); }

		@Override
		public KEY_SPLITERATOR KEY_GENERIC spliterator() { return new KeySpliterator(); }

		/** {@inheritDoc} */
		@Override
		public void forEach(final METHOD_ARG_KEY_CONSUMER consumer) {
			if (containsNullKey) consumer.accept(key[n]);
			for(int pos = n; pos-- != 0;) {
				final KEY_GENERIC_TYPE k = key[pos];
				if (! KEY_IS_NULL(k)) consumer.accept(k);
			}
		}
#endif

		@Override
		public int size() { return size; }

		@Override
		public boolean contains(KEY_TYPE k) { return containsKey(k); }

		@Override
		public boolean remove(KEY_TYPE k) {
			final int oldSize = size;
			OPEN_HASH_MAP.this.REMOVE_VALUE(k);
			return size != oldSize;
		}

		@Override
		public void clear() { OPEN_HASH_MAP.this.clear();}

#ifdef Linked
		@Override
		public KEY_GENERIC_TYPE FIRST() {
			if (size == 0) throw new NoSuchElementException();
			return key[first];
		}

		@Override
		public KEY_GENERIC_TYPE LAST() {
			if (size == 0) throw new NoSuchElementException();
			return key[last];
		}

		@Override
		public KEY_COMPARATOR KEY_SUPER_GENERIC comparator() { return null; }

		@Override
		public SORTED_SET KEY_GENERIC tailSet(KEY_GENERIC_TYPE from) { throw new UnsupportedOperationException(); }

		@Override
		public SORTED_SET KEY_GENERIC headSet(KEY_GENERIC_TYPE to) { throw new UnsupportedOperationException(); }

		@Override
		public SORTED_SET KEY_GENERIC subSet(KEY_GENERIC_TYPE from, KEY_GENERIC_TYPE to) { throw new UnsupportedOperationException(); }
#endif
	}


#ifdef Linked
	@Override
	public SORTED_SET KEY_GENERIC keySet() {
#else
	@Override
	public SET KEY_GENERIC keySet() {
#endif
		if (keys == null) keys = new KeySet();
		return keys;
	}


	/** An iterator on values.
	 *
	 * <p>We simply override the {@link java.util.ListIterator#next()}/{@link java.util.ListIterator#previous()} methods
	 * (and possibly their type-specific counterparts) so that they return values
	 * instead of entries.
	 */

#ifdef Linked
	private final class ValueIterator extends MapIterator<METHOD_ARG_VALUE_CONSUMER> implements VALUE_LIST_ITERATOR VALUE_GENERIC {
		@Override
		public VALUE_GENERIC_TYPE PREV_VALUE() { return value[previousEntry()]; }
#else
	private final class ValueIterator extends MapIterator<METHOD_ARG_VALUE_CONSUMER> implements VALUE_ITERATOR VALUE_GENERIC {
#endif

		public ValueIterator() { super(); }

		// forEachRemaining inherited from MapIterator superclass.
		// Despite the superclass declared with generics, the way Java inherits and generates bridge methods avoids the boxing/unboxing

		@Override
		final void acceptOnIndex(final METHOD_ARG_VALUE_CONSUMER action, final int index) {
			action.accept(value[index]);
		}

		@Override
		public VALUE_GENERIC_TYPE NEXT_VALUE() { return value[nextEntry()]; }
	}

#ifndef Linked
	private final class ValueSpliterator extends MapSpliterator<METHOD_ARG_VALUE_CONSUMER, ValueSpliterator> implements VALUE_SPLITERATOR VALUE_GENERIC {

		private static final int POST_SPLIT_CHARACTERISTICS = VALUE_SPLITERATORS.COLLECTION_SPLITERATOR_CHARACTERISTICS & ~java.util.Spliterator.SIZED;

		ValueSpliterator() {}

		ValueSpliterator(int pos, int max, boolean mustReturnNull, boolean hasSplit) {
			super(pos, max, mustReturnNull, hasSplit);
		}

		@Override
		public int characteristics() {
			return hasSplit ? POST_SPLIT_CHARACTERISTICS : VALUE_SPLITERATORS.COLLECTION_SPLITERATOR_CHARACTERISTICS;
		}

		@Override
		final void acceptOnIndex(final METHOD_ARG_VALUE_CONSUMER action, final int index) {
			action.accept(value[index]);
		}

		@Override
		final ValueSpliterator makeForSplit(int pos, int max, boolean mustReturnNull) {
			return new ValueSpliterator(pos, max, mustReturnNull, true);
		}
	}
#endif

	@Override
	public VALUE_COLLECTION VALUE_GENERIC values() {
		if (values == null) values = new VALUE_ABSTRACT_COLLECTION VALUE_GENERIC() {
#ifdef Linked
				private static final int SPLITERATOR_CHARACTERISTICS = VALUE_SPLITERATORS.COLLECTION_SPLITERATOR_CHARACTERISTICS | java.util.Spliterator.ORDERED;
#endif
				@Override
				public VALUE_ITERATOR VALUE_GENERIC iterator() { return new ValueIterator(); }
#ifdef Linked
				/** {@inheritDoc}
				 * @see EntrySet#spliterator()
				 */
				@Override
				public VALUE_SPLITERATOR VALUE_GENERIC spliterator() {
					return VALUE_SPLITERATORS.asSpliterator(
						iterator(), it.unimi.dsi.fastutil.Size64.sizeOf(OPEN_HASH_MAP.this), SPLITERATOR_CHARACTERISTICS);
				}

				/** {@inheritDoc} */
				@Override
				public void forEach(final METHOD_ARG_VALUE_CONSUMER consumer) {
					for(int i = size, curr, next = first; i-- != 0;) {
						curr = next;
						next = GET_NEXT(link[curr]);
						consumer.accept(value[curr]);
					}
				}
#else
				@Override
				public VALUE_SPLITERATOR VALUE_GENERIC spliterator() { return new ValueSpliterator(); }

				/** {@inheritDoc} */
				@Override
				public void forEach(final METHOD_ARG_VALUE_CONSUMER consumer) {
					if (containsNullKey) consumer.accept(value[n]);
					for(int pos = n; pos-- != 0;)
						if (! KEY_IS_NULL(key[pos])) consumer.accept(value[pos]);
				}
#endif
				@Override
				public int size() { return size; }
				@Override
				public boolean contains(VALUE_TYPE v) { return containsValue(v); }
				@Override
				public void clear() { OPEN_HASH_MAP.this.clear(); }
			};

		return values;
	}


	/** Rehashes the map, making the table as small as possible.
	 *
	 * <p>This method rehashes the table to the smallest size satisfying the
	 * load factor. It can be used when the set will not be changed anymore, so
	 * to optimize access speed and size.
	 *
	 * <p>If the table size is already the minimum possible, this method
	 * does nothing.
	 *
	 * @return true if there was enough memory to trim the map.
	 * @see #trim(int)
	 */

	public boolean trim() {
		return trim(size);
	}


	/** Rehashes this map if the table is too large.
	 *
	 * <p>Let <var>N</var> be the smallest table size that can hold
	 * <code>max(n,{@link #size()})</code> entries, still satisfying the load factor. If the current
	 * table size is smaller than or equal to <var>N</var>, this method does
	 * nothing. Otherwise, it rehashes this map in a table of size
	 * <var>N</var>.
	 *
	 * <p>This method is useful when reusing maps.  {@linkplain #clear() Clearing a
	 * map} leaves the table size untouched. If you are reusing a map
	 * many times, you can call this method with a typical
	 * size to avoid keeping around a very large table just
	 * because of a few large transient maps.
	 *
	 * @param n the threshold for the trimming.
	 * @return true if there was enough memory to trim the map.
	 * @see #trim()
	 */

	public boolean trim(final int n) {
		final int l = HashCommon.nextPowerOfTwo((int)Math.ceil(n / f));
		if (l >= this.n || size > maxFill(l, f)) return true;
		try {
			rehash(l);
		}
		catch(OutOfMemoryError cantDoIt) { return false; }
		return true;
	}

	/** Rehashes the map.
	 *
	 * <p>This method implements the basic rehashing strategy, and may be
	 * overridden by subclasses implementing different rehashing strategies (e.g.,
	 * disk-based rehashing). However, you should not override this method
	 * unless you understand the internal workings of this class.
	 *
	 * @param newN the new size
	 */

	SUPPRESS_WARNINGS_KEY_VALUE_UNCHECKED
	protected void rehash(final int newN) {
		final KEY_GENERIC_TYPE key[] = this.key;
		final VALUE_GENERIC_TYPE value[] = this.value;

		final int mask = newN - 1; // Note that this is used by the hashing macro
		final KEY_GENERIC_TYPE newKey[] = KEY_GENERIC_ARRAY_CAST new KEY_TYPE[newN + 1];
		final VALUE_GENERIC_TYPE newValue[] = VALUE_GENERIC_ARRAY_CAST new VALUE_TYPE[newN + 1];

#ifdef Linked
		int i = first, prev = -1, newPrev = -1, t, pos;
		final long link[] = this.link;
		final long newLink[] = new long[newN + 1];
		first = -1;

		for(int j = size; j-- != 0;) {
			if (KEY_EQUALS_NULL(key[i])) pos = newN;
			else {
				pos = KEY2INTHASH(key[i]) & mask;
				while (! KEY_IS_NULL(newKey[pos])) pos = (pos + 1) & mask;
			}

			newKey[pos] = key[i];
			newValue[pos] = value[i];

			if (prev != -1) {
				SET_NEXT(newLink[newPrev], pos);
				SET_PREV(newLink[pos], newPrev);
				newPrev = pos;
			}
			else {
				newPrev = first = pos;
				// Special case of SET(newLink[pos], -1, -1);
				newLink[pos] = -1L;
			}

			t = i;
			i = GET_NEXT(link[i]);
			prev = t;
		}

		this.link = newLink;
		this.last = newPrev;
		if (newPrev != -1)
			// Special case of SET_NEXT(newLink[newPrev], -1);
			newLink[newPrev] |= -1 & 0xFFFFFFFFL;
#else
		int i = n, pos;

		for(int j = realSize(); j-- != 0;) {
			while(KEY_IS_NULL(key[--i]));

			if (! KEY_IS_NULL(newKey[pos = KEY2INTHASH(key[i]) & mask]))
				while (! KEY_IS_NULL(newKey[pos = (pos + 1) & mask]));

			newKey[pos] = key[i];
			newValue[pos] = value[i];
		}

		newValue[newN] = value[n];

#endif

		n = newN;
		this.mask = mask;
		maxFill = maxFill(n, f);
		this.key = newKey;
		this.value = newValue;
	}


	/** Returns a deep copy of this map.
	 *
	 * <p>This method performs a deep copy of this hash map; the data stored in the
	 * map, however, is not cloned. Note that this makes a difference only for object keys.
	 *
	 *  @return a deep copy of this map.
	 */
	@Override
	SUPPRESS_WARNINGS_KEY_VALUE_UNCHECKED
	public OPEN_HASH_MAP KEY_VALUE_GENERIC clone() {
		OPEN_HASH_MAP KEY_VALUE_GENERIC c;
		try {
			c = (OPEN_HASH_MAP KEY_VALUE_GENERIC)super.clone();
		}
		catch(CloneNotSupportedException cantHappen) {
			throw new InternalError();
		}

		c.keys = null;
		c.values = null;
		c.entries = null;
		c.containsNullKey = containsNullKey;

		c.key = key.clone();
		c.value = value.clone();
#ifdef Linked
		c.link = link.clone();
#endif
#ifdef Custom
		c.strategy = strategy;
#endif
		return c;
	}


	/** Returns a hash code for this map.
	 *
	 * This method overrides the generic method provided by the superclass.
	 * Since {@code equals()} is not overriden, it is important
	 * that the value returned by this method is the same value as
	 * the one returned by the overriden method.
	 *
	 * @return a hash code for this map.
	 */

	@Override
	public int hashCode() {
		int h = 0;
		for(int j = realSize(), i = 0, t = 0; j-- != 0;) {
			while(KEY_IS_NULL(key[i])) i++;
#if KEYS_REFERENCE
			if (this != key[i])
#endif
				t = KEY2JAVAHASH_NOT_NULL(key[i]);
#if VALUES_REFERENCE
			if (this != value[i])
#endif
				t ^=  VALUE2JAVAHASH(value[i]);
			h += t;
			i++;
		}
		// Zero / null keys have hash zero.
		if (containsNullKey) h += VALUE2JAVAHASH(value[n]);
		return h;
	}



	private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {
		final KEY_GENERIC_TYPE key[] = this.key;
		final VALUE_GENERIC_TYPE value[] = this.value;
		final EntryIterator i = new EntryIterator();
		s.defaultWriteObject();

		for(int j = size, e; j-- != 0;) {
			e = i.nextEntry();
			s.WRITE_KEY(key[e]);
			s.WRITE_VALUE(value[e]);
		}
	}



	SUPPRESS_WARNINGS_KEY_VALUE_UNCHECKED
	private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {
		s.defaultReadObject();

		n = arraySize(size, f);
		maxFill = maxFill(n, f);
		mask = n - 1;

		final KEY_GENERIC_TYPE key[] = this.key = KEY_GENERIC_ARRAY_CAST new KEY_TYPE[n + 1];
		final VALUE_GENERIC_TYPE value[] = this.value = VALUE_GENERIC_ARRAY_CAST new VALUE_TYPE[n + 1];
#ifdef Linked
		final long link[] = this.link = new long[n + 1];
		int prev = -1;
		first = last = -1;
#endif

		KEY_GENERIC_TYPE k;
		VALUE_GENERIC_TYPE v;

		for(int i = size, pos; i-- != 0;) {

			k = KEY_GENERIC_CAST s.READ_KEY();
			v = VALUE_GENERIC_CAST s.READ_VALUE();

			if (KEY_EQUALS_NULL(k)) {
				pos = n;
				containsNullKey = true;
			}
			else {
				pos = KEY2INTHASH(k) & mask;
				while (! KEY_IS_NULL(key[pos])) pos = (pos + 1) & mask;
			}

			key[pos] = k;
			value[pos] = v;

#ifdef Linked
			if (first != -1) {
				SET_NEXT(link[prev], pos);
				SET_PREV(link[pos], prev);
				prev = pos;
			}
			else {
				prev = first = pos;
				// Special case of SET_PREV(newLink[pos], -1);
				link[pos] |= (-1L & 0xFFFFFFFFL) << 32;
			}
#endif
		}

#ifdef Linked
		last = prev;
		if (prev != -1)
			// Special case of SET_NEXT(link[prev], -1);
			link[prev] |= -1 & 0xFFFFFFFFL;
#endif

		if (ASSERTS) checkTable();
	}



#ifdef ASSERTS_CODE
	private void checkTable() {
		assert (n & -n) == n : "Table length is not a power of two: " + n;
		assert n == key.length - 1;
		int n = key.length - 1;
		while(n-- != 0)
			if (! KEY_IS_NULL(key[n]) && ! containsKey(key[n]))
				throw new AssertionError("Hash table has key " + key[n] + " marked as occupied, but the key does not belong to the table");

#if KEYS_PRIMITIVE
		java.util.HashSet<KEY_GENERIC_CLASS> s = new java.util.HashSet<KEY_GENERIC_CLASS> ();
#else
		java.util.HashSet<Object> s = new java.util.HashSet<Object>();
#endif

		for(int i = key.length; i-- != 0;)
			if (! KEY_IS_NULL(key[i]) && ! s.add(key[i])) throw new AssertionError("Key " + key[i] + " appears twice at position " + i);

#ifdef Linked
		KEY_BIDI_ITERATOR KEY_GENERIC i = keySet().iterator();
		KEY_GENERIC_TYPE k;
		n = size();
		while(n-- != 0)
			if (! containsKey(k = i.NEXT_KEY()))
				throw new AssertionError("Linked hash table forward enumerates key " + k + ", but the key does not belong to the table");

		if (i.hasNext()) throw new AssertionError("Forward iterator not exhausted");

		n = size();
		if (n > 0) {
			i = keySet().iterator(LAST_KEY());
			while(n-- != 0)
				if (! containsKey(k = i.PREV_KEY()))
					throw new AssertionError("Linked hash table backward enumerates key " + k + ", but the key does not belong to the table");

			if (i.hasPrevious()) throw new AssertionError("Previous iterator not exhausted");
		}
#endif
	}
#else
	private void checkTable() {}
#endif


#ifdef TEST

	private static long seed = System.currentTimeMillis();
	private static java.util.Random r = new java.util.Random(seed);

	private static KEY_TYPE genKey() {
#if KEY_CLASS_Byte || KEY_CLASS_Short || KEY_CLASS_Character
		return (KEY_TYPE)(r.nextInt());
#elif KEYS_PRIMITIVE
		return r.NEXT_KEY();
#elif !KEYS_USE_REFERENCE_EQUALITY
#ifdef Custom
		int i = r.nextInt(3);
		byte a[] = new byte[i];
		while(i-- != 0) a[i] = (byte)r.nextInt();
		return a;
#else
		return Integer.toBinaryString(r.nextInt());
#endif
#else
		return new java.io.Serializable() {};
#endif
	}

	private static VALUE_TYPE genValue() {
#if VALUE_CLASS_Byte || VALUE_CLASS_Short || VALUE_CLASS_Character
		return (VALUE_TYPE)(r.nextInt());
#elif VALUES_PRIMITIVE
		return r.NEXT_VALUE();
#elif !VALUES_USE_REFERENCE_EQUALITY
		return Integer.toBinaryString(r.nextInt());
#else
		return new java.io.Serializable() {};
#endif
	}

	private static final class ArrayComparator implements java.util.Comparator {
		public int compare(Object a, Object b) {
			byte[] aa = (byte[])a;
			byte[] bb = (byte[])b;
			int length = Math.min(aa.length, bb.length);
			for(int i = 0; i < length; i++) {
				if (aa[i] < bb[i]) return -1;
				if (aa[i] > bb[i]) return 1;
			}
			return aa.length == bb.length ? 0 : (aa.length < bb.length ? -1 : 1);
		}
	}

	private static final class MockMap extends java.util.TreeMap {
		private java.util.List list = new java.util.ArrayList();

		public MockMap(java.util.Comparator c) { super(c); }

		public Object put(Object k, Object v) {
			if (! containsKey(k)) list.add(k);
			return super.put(k, v);
		}

		public void putAll(Map m) {
			java.util.Iterator i = m.entrySet().iterator();
			while(i.hasNext()) {
				Map.Entry e = (Map.Entry)i.next();
				put(e.getKey(), e.getValue());
			}
		}

		public Object remove(Object k) {
			if (containsKey(k)) {
				int i = list.size();
				while(i-- != 0) if (comparator().compare(list.get(i), k) == 0) {
					list.remove(i);
					break;
				}
			}
			return super.remove(k);
		}

		private void justRemove(Object k) { super.remove(k); }
		private java.util.Set justEntrySet() { return super.entrySet(); }
		private java.util.Set justKeySet() { return super.keySet(); }

		public java.util.Set keySet() {
			return new java.util.AbstractSet() {
					final java.util.Set keySet = justKeySet();

					public boolean contains(Object k) { return keySet.contains(k); }
					public int size() { return keySet.size(); }
					public java.util.Iterator iterator() {
						return new java.util.Iterator() {
								final java.util.Iterator iterator = list.iterator();
								Object curr;
								public Object next() { return curr = iterator.next(); }
								public boolean hasNext() { return iterator.hasNext(); }
								public void remove() {
									justRemove(curr);
									iterator.remove();
								}
							};

					}
				};

		}

		public java.util.Set entrySet() {
			return new java.util.AbstractSet() {
					final java.util.Set entrySet = justEntrySet();

					public boolean contains(Object k) { return entrySet.contains(k); }
					public int size() { return entrySet.size(); }
					public java.util.Iterator iterator() {
						return new java.util.Iterator() {
								final java.util.Iterator iterator = list.iterator();
								Object curr;
								public Object next() {
									curr = iterator.next();
#if VALUES_USE_REFERENCE_EQUALITY
#if KEYS_USE_REFERENCE_EQUALITY
									return new ABSTRACT_MAP.BasicEntry((Object)curr, (Object)get(curr)) {
#else
									return new ABSTRACT_MAP.BasicEntry((KEY_CLASS)curr, (Object)get(curr)) {
#endif
#else
#if KEYS_USE_REFERENCE_EQUALITY
									return new ABSTRACT_MAP.BasicEntry((Object)curr, (VALUE_CLASS)get(curr)) {
#else
									return new ABSTRACT_MAP.BasicEntry((KEY_CLASS)curr, (VALUE_CLASS)get(curr)) {
#endif
#endif
											public VALUE_TYPE setValue(VALUE_TYPE v) {
												return VALUE_OBJ2TYPE(put(getKey(), VALUE2OBJ(v)));
											}
										};
								}
								public boolean hasNext() { return iterator.hasNext(); }
								public void remove() {
									justRemove(((Map.Entry)curr).getKey());
									iterator.remove();
								}
							};
					}
				};
		}
	}

	private static java.text.NumberFormat format = new java.text.DecimalFormat("#,###.00");
	private static java.text.FieldPosition fp = new java.text.FieldPosition(0);

	private static String format(double d) {
		StringBuffer s = new StringBuffer();
		return format.format(d, s, fp).toString();
	}


	private static void speedTest(int n, float f, boolean comp) {
#ifndef Custom
		int i, j;
		OPEN_HASH_MAP m;
#ifdef Linked
		java.util.LinkedHashMap t;
#else
		java.util.HashMap t;
#endif
		KEY_TYPE k[] = new KEY_TYPE[n];
		KEY_TYPE nk[] = new KEY_TYPE[n];
		VALUE_TYPE v[] = new VALUE_TYPE[n];
		long ns;

		for(i = 0; i < n; i++) {
			k[i] = genKey();
			nk[i] = genKey();
			v[i] = genValue();
		}

		double totPut = 0, totYes = 0, totNo = 0, totIter = 0, totRemYes = 0, totRemNo = 0, d;

		if (comp) { for(j = 0; j < 20; j++) {

#ifdef Linked
			t = new java.util.LinkedHashMap(16);
#else
			t = new java.util.HashMap(16);
#endif

			/* We put pairs to t. */
			ns = System.nanoTime();
			for(i = 0; i < n;  i++) t.put(KEY2OBJ(k[i]), VALUE2OBJ(v[i]));
			d = (System.nanoTime() - ns) / (double)n;
			if (j > 2) totPut += d;
			System.out.print("Put: " + format(d) + "ns ");

			/* We check for pairs in t. */
			ns = System.nanoTime();
			for(i = 0; i < n;  i++) t.containsKey(KEY2OBJ(k[i]));
			d = (System.nanoTime() - ns) / (double)n;
			if (j > 2) totYes += d;
			System.out.print("Yes: " + format(d) + "ns ");

			/* We check for pairs not in t. */
			ns = System.nanoTime();
			for(i = 0; i < n;  i++) t.containsKey(KEY2OBJ(nk[i]));
			d = (System.nanoTime() - ns) / (double)n;
			if (j > 2) totNo += d;
			System.out.print("No: " + format(d) + "ns ");

			/* We iterate on t. */
			ns = System.nanoTime();
			for(java.util.Iterator it = t.entrySet().iterator(); it.hasNext(); it.next());
			d = (System.nanoTime() - ns) / (double)n;
			if (j > 2) totIter += d;
			System.out.print("Iter: " + format(d) + "ns ");

			/* We delete pairs not in t. */
			ns = System.nanoTime();
			for(i = 0; i < n;  i++) t.remove(KEY2OBJ(nk[i]));
			d = (System.nanoTime() - ns) / (double)n;
			if (j > 2) totRemNo += d;
			System.out.print("RemNo: " + format(d) + "ns ");

			/* We delete pairs in t. */
			ns = System.nanoTime();
			for(i = 0; i < n;  i++) t.remove(KEY2OBJ(k[i]));
			d = (System.nanoTime() - ns) / (double)n;
			if (j > 2) totRemYes += d;
			System.out.print("RemYes: " + format(d) + "ns ");

			System.out.println();
		}

		System.out.println();
		System.out.println("java.util Put: " + format(totPut/(j-3)) + "ns Yes: " + format(totYes/(j-3)) + "ns No: " + format(totNo/(j-3)) + "ns Iter: " + format(totIter/(j-3)) + "ns RemNo: " + format(totRemNo/(j-3)) + "ns RemYes: " + format(totRemYes/(j-3)) + "K/s");

		System.out.println();

		totPut = totYes = totNo = totIter = totRemYes = totRemNo = 0;

		}

		for(j = 0; j < 20; j++) {

			m = new OPEN_HASH_MAP(16, f);

			/* We put pairs to m. */
			ns = System.nanoTime();
			for(i = 0; i < n;  i++) m.put(k[i], v[i]);
			d = (System.nanoTime() - ns) / (double)n;
			if (j > 2) totPut += d;
			System.out.print("Put: " + format(d) + "ns ");

			/* We check for pairs in m. */
			ns = System.nanoTime();
			for(i = 0; i < n;  i++) m.containsKey(k[i]);
			d = (System.nanoTime() - ns) / (double)n;
			if (j > 2) totYes += d;
			System.out.print("Yes: " + format(d) + "ns ");

			/* We check for pairs not in m. */
			ns = System.nanoTime();
			for(i = 0; i < n;  i++) m.containsKey(nk[i]);
			d = (System.nanoTime() - ns) / (double)n;
			if (j > 2) totNo += d;
			System.out.print("No: " + format(d) + "ns ");

			/* We iterate on m. */
			ns = System.nanoTime();
			for(java.util.Iterator it = m.entrySet().iterator(); it.hasNext(); it.next());
			d = (System.nanoTime() - ns) / (double)n;
			if (j > 2) totIter += d;
			System.out.print("Iter: " + format(d) + "ns ");

			/* We delete pairs not in m. */
			ns = System.nanoTime();
			for(i = 0; i < n;  i++) m.remove(nk[i]);
			d = (System.nanoTime() - ns) / (double)n;
			if (j > 2) totRemNo += d;
			System.out.print("RemNo: " + format(d) + "ns ");

			/* We delete pairs in m. */
			ns = System.nanoTime();
			for(i = 0; i < n;  i++) m.remove(k[i]);
			d = (System.nanoTime() - ns) / (double)n;
			if (j > 2) totRemYes += d;
			System.out.print("RemYes: " + format(d) + "ns ");

			System.out.println();
		}


		System.out.println();
		System.out.println("fastutil Put: " + format(totPut/(j-3)) + "ns Yes: " + format(totYes/(j-3)) + "ns No: " + format(totNo/(j-3)) + "ns Iter: " + format(totIter/(j-3)) + "ns RemNo: " + format(totRemNo/(j-3)) + "ns RemYes: " + format(totRemYes/(j-3)) + "ns");

		System.out.println();
#endif
	}

	private static void fatal(String msg) {
		throw new AssertionError(msg);
	}

	private static void ensure(boolean cond, String msg) {
		if (cond) return;
		fatal(msg);
	}

	protected static void runTest(int n, float f) throws Exception {
#if !defined(Custom) || KEYS_REFERENCE

#ifdef Custom
		OPEN_HASH_MAP m = new OPEN_HASH_MAP(Hash.DEFAULT_INITIAL_SIZE, f, it.unimi.dsi.fastutil.bytes.ByteArrays.HASH_STRATEGY);
#else
		OPEN_HASH_MAP m = new OPEN_HASH_MAP(Hash.DEFAULT_INITIAL_SIZE, f);
#endif

#ifdef Linked
#ifdef Custom
		Map t = new MockMap(new ArrayComparator());
#else
		Map t = new java.util.LinkedHashMap();
#endif
#else
#ifdef Custom
		Map t = new java.util.TreeMap(new ArrayComparator());
#else
		Map t = new java.util.HashMap();
#endif
#endif

		/* First of all, we fill t with random data. */

		for(int i=0; i<n;  i++) t.put(KEY2OBJ(genKey()), VALUE2OBJ(genValue()));

		/* Now we add to m the same data */

		m.putAll(t);

		ensure(m.equals(t), "Error (" + seed + "): !m.equals(t) after insertion");;
		ensure(t.equals(m), "Error (" + seed + "): !t.equals(m) after insertion");;

		/* Now we check that m actually holds that data. */

		for(java.util.Iterator i=t.entrySet().iterator(); i.hasNext();) {
			java.util.Map.Entry e = (java.util.Map.Entry)i.next();
			ensure(java.util.Objects.equals(e.getValue(), m.get(e.getKey())), "Error (" + seed + "): m and t differ on an entry ("+e+") after insertion (iterating on t)");
		}

		/* Now we check that m actually holds that data, but iterating on m. */

		for(java.util.Iterator i=m.entrySet().iterator(); i.hasNext();) {
			java.util.Map.Entry e = (java.util.Map.Entry)i.next();
			ensure(java.util.Objects.equals(e.getValue(), t.get(e.getKey())), "Error (" + seed + "): m and t differ on an entry ("+e+") after insertion (iterating on m)");
		}

		/* Now we check that m actually holds the same keys. */

		for(java.util.Iterator i=t.keySet().iterator(); i.hasNext();) {
			Object o = i.next();
			ensure(m.containsKey(o), "Error (" + seed + "): m and t differ on a key ("+o+") after insertion (iterating on t)");
			ensure(m.keySet().contains(o), "Error (" + seed + "): m and t differ on a key ("+o+", in keySet()) after insertion (iterating on t)");
		}

		/* Now we check that m actually holds the same keys, but iterating on m. */

		for(java.util.Iterator i=m.keySet().iterator(); i.hasNext();) {
			Object o = i.next();
			ensure(t.containsKey(o), "Error (" + seed + "): m and t differ on a key after insertion (iterating on m)");
			ensure(t.keySet().contains(o), "Error (" + seed + "): m and t differ on a key (in keySet()) after insertion (iterating on m)");
		}


		/* Now we check that m actually hold the same values. */

		for(java.util.Iterator i=t.values().iterator(); i.hasNext();) {
			Object o = i.next();
			ensure(m.containsValue(o), "Error (" + seed + "): m and t differ on a value after insertion (iterating on t)");
			ensure(m.values().contains(o), "Error (" + seed + "): m and t differ on a value (in values()) after insertion (iterating on t)");
		}

		/* Now we check that m actually hold the same values, but iterating on m. */

		for(java.util.Iterator i=m.values().iterator(); i.hasNext();) {
			Object o = i.next();
			ensure(t.containsValue(o), "Error (" + seed + "): m and t differ on a value after insertion (iterating on m)");
			ensure(t.values().contains(o), "Error (" + seed + "): m and t differ on a value (in values()) after insertion (iterating on m)");
		}

		/* Now we check that inquiries about random data give the same answer in m and t. For
		   m we use the polymorphic method. */

		for(int i=0; i<n;  i++) {
			KEY_TYPE T = genKey();
			ensure(m.containsKey(KEY2OBJ(T)) == t.containsKey(KEY2OBJ(T)), "Error (" + seed + "): divergence in keys between t and m (polymorphic method)");

#if (KEYS_REFERENCE) && ! (VALUES_REFERENCE)
			if ((m.GET_VALUE(T) != VALUE_NULL) != ((t.get(KEY2OBJ(T)) == null ? VALUE_NULL : VALUE_OBJ2TYPE(t.get(KEY2OBJ(T)))) != VALUE_NULL) ||
				t.get(KEY2OBJ(T)) != null &&
				! VALUE2OBJ(m.GET_VALUE(T)).equals(t.get(KEY2OBJ(T))))
#else
				if ((m.get(T) != VALUE_NULL) != ((t.get(KEY2OBJ(T)) == null ? VALUE_NULL : VALUE_OBJ2TYPE(t.get(KEY2OBJ(T)))) != VALUE_NULL) ||
					t.get(KEY2OBJ(T)) != null &&
					! m.get(KEY2OBJ(T)).equals(t.get(KEY2OBJ(T))))
#endif
					{
						ensure(false, "Error (" + seed + "): divergence between t and m (polymorphic method)");
					}
		}

		/* Again, we check that inquiries about random data give the same answer in m and t, but
		   for m we use the standard method. */

		for(int i=0; i<n;  i++) {
			KEY_TYPE T = genKey();
			ensure(java.util.Objects.equals(m.get(KEY2OBJ(T)), t.get(KEY2OBJ(T))), "Error (" + seed + "): divergence between t and m (standard method)");
		}

		/* Now we put and remove random data in m and t, checking that the result is the same. */

		for(int i=0; i<20*n;  i++) {
			KEY_TYPE T = genKey();
			VALUE_TYPE U = genValue();
			ensure(java.util.Objects.equals(m.put(KEY2OBJ(T), VALUE2OBJ(U)), t.put(KEY2OBJ(T), VALUE2OBJ(U))), "Error (" + seed + "): divergence in put() between t and m");
			T = genKey();
			ensure(java.util.Objects.equals(m.remove(KEY2OBJ(T)), t.remove(KEY2OBJ(T))), "Error (" + seed + "): divergence in remove() between t and m");
		}

		ensure(m.equals(t), "Error (" + seed + "): !m.equals(t) after removal");;
		ensure(t.equals(m), "Error (" + seed + "): !t.equals(m) after removal");;


		/* Now we check that m actually holds the same data. */

		for(java.util.Iterator i=t.entrySet().iterator(); i.hasNext();) {
			java.util.Map.Entry e = (java.util.Map.Entry)i.next();
			ensure(java.util.Objects.equals(e.getValue(), m.get(e.getKey())), "Error (" + seed + "): m and t differ on an entry ("+e+") after removal (iterating on t)");
		}

		/* Now we check that m actually holds that data, but iterating on m. */

		for(java.util.Iterator i=m.entrySet().iterator(); i.hasNext();) {
			java.util.Map.Entry e = (java.util.Map.Entry)i.next();
			ensure(java.util.Objects.equals(e.getValue(), t.get(e.getKey())), "Error (" + seed + "): m and t differ on an entry ("+e+") after removal (iterating on m)");
		}

		/* Now we check that m actually holds the same keys. */

		for(java.util.Iterator i=t.keySet().iterator(); i.hasNext();) {
			Object o = i.next();
			ensure(m.containsKey(o), "Error (" + seed + "): m and t differ on a key ("+o+") after removal (iterating on t)");
			ensure(m.keySet().contains(o), "Error (" + seed + "): m and t differ on a key ("+o+", in keySet()) after removal (iterating on t)");
		}

		/* Now we check that m actually holds the same keys, but iterating on m. */

		for(java.util.Iterator i=m.keySet().iterator(); i.hasNext();) {
			Object o = i.next();
			ensure(t.containsKey(o), "Error (" + seed + "): m and t differ on a key after removal (iterating on m)");
			ensure(t.keySet().contains(o), "Error (" + seed + "): m and t differ on a key (in keySet()) after removal (iterating on m)");
		}


		/* Now we check that m actually hold the same values. */

		for(java.util.Iterator i=t.values().iterator(); i.hasNext();) {
			Object o = i.next();
			ensure(m.containsValue(o), "Error (" + seed + "): m and t differ on a value after removal (iterating on t)");
			ensure(m.values().contains(o), "Error (" + seed + "): m and t differ on a value (in values()) after removal (iterating on t)");
		}

		/* Now we check that m actually hold the same values, but iterating on m. */

		for(java.util.Iterator i=m.values().iterator(); i.hasNext();) {
			Object o = i.next();
			ensure(t.containsValue(o), "Error (" + seed + "): m and t differ on a value after removal (iterating on m)");
			ensure(t.values().contains(o), "Error (" + seed + "): m and t differ on a value (in values()) after removal (iterating on m)");
		}


		int h = m.hashCode();


		/* Now we save and read m. */

		{
			java.io.File ff = new java.io.File("it.unimi.dsi.fastutil.test." + m.getClass().getSimpleName() + "." + n);
			java.io.OutputStream os = new java.io.FileOutputStream(ff);
			java.io.ObjectOutputStream oos = new java.io.ObjectOutputStream(os);

			oos.writeObject(m);
			oos.close();

			java.io.InputStream is = new java.io.FileInputStream(ff);
			java.io.ObjectInputStream ois = new java.io.ObjectInputStream(is);

			m = (OPEN_HASH_MAP)ois.readObject();
			ois.close();
			ff.delete();
		}


#if !KEYS_USE_REFERENCE_EQUALITY && !VALUES_USE_REFERENCE_EQUALITY
		ensure(m.hashCode() == h, "Error (" + seed + "): hashCode() changed after save/read");;

		/* Now we check that m actually holds that data. */

		for(java.util.Iterator i=t.keySet().iterator(); i.hasNext();) {
			Object o = i.next();
			ensure(java.util.Objects.equals(m.get(o),t.get(o)), "Error (" + seed + "): m and t differ on an entry after save/read");
		}
#else
		m.clear();
		m.putAll(t);
#endif

		/* Now we put and remove random data in m and t, checking that the result is the same. */

		for(int i=0; i<20*n;  i++) {
			KEY_TYPE T = genKey();
			VALUE_TYPE U = genValue();
			ensure(java.util.Objects.equals(m.put(KEY2OBJ(T), VALUE2OBJ(U)), t.put(KEY2OBJ(T), VALUE2OBJ(U))), "Error (" + seed + "): divergence in put() between t and m after save/read");
			T = genKey();
			ensure(java.util.Objects.equals(m.remove(KEY2OBJ(T)), t.remove(KEY2OBJ(T))), "Error (" + seed + "): divergence in remove() between t and m after save/read");
		}

		ensure(m.equals(t), "Error (" + seed + "): !m.equals(t) after post-save/read removal");;
		ensure(t.equals(m), "Error (" + seed + "): !t.equals(m) after post-save/read removal");;



#ifdef Linked


		/* Now we play with iterators. */

		{
			java.util.ListIterator i, j;
			Object J;
			Map.Entry E, F;
			i = (java.util.ListIterator)m.entrySet().iterator();
			j = new java.util.LinkedList(t.entrySet()).listIterator();

			for(int k = 0; k < 2*n; k++) {
				ensure(i.hasNext() == j.hasNext(), "Error (" + seed + "): divergence in hasNext()");
				ensure(i.hasPrevious() == j.hasPrevious(), "Error (" + seed + "): divergence in hasPrevious()");

				if (r.nextFloat() < .8 && i.hasNext()) {
#ifdef Custom
					ensure(m.strategy().equals((E=(java.util.Map.Entry)i.next()).getKey(), J = (F=(Map.Entry)j.next()).getKey()), "Error (" + seed + "): divergence in next()");
#else
					ensure((E=(java.util.Map.Entry)i.next()).getKey().equals(J = (F=(Map.Entry)j.next()).getKey()), "Error (" + seed + "): divergence in next()");
#endif

					if (r.nextFloat() < 0.3) {
						i.remove();
						j.remove();
						t.remove(J);
					}
					else if (r.nextFloat() < 0.3) {
						Object U = VALUE2OBJ(genValue());
						E.setValue(U);
						t.put(F.getKey(), U);
					}
				}
				else if (r.nextFloat() < .2 && i.hasPrevious()) {
#ifdef Custom
					ensure(m.strategy().equals((E=(java.util.Map.Entry)i.previous()).getKey(), J = (F=(Map.Entry)j.previous()).getKey()), "Error (" + seed + "): divergence in previous()");
#else
					ensure((E=(java.util.Map.Entry)i.previous()).getKey().equals(J = (F=(Map.Entry)j.previous()).getKey()), "Error (" + seed + "): divergence in previous()");
#endif

					if (r.nextFloat() < 0.3) {
						i.remove();
						j.remove();
						t.remove(J);
					}
					else if (r.nextFloat() < 0.3) {
						Object U = VALUE2OBJ(genValue());
						E.setValue(U);
						t.put(F.getKey(), U);
					}
				}

				ensure(i.nextIndex() == j.nextIndex(), "Error (" + seed + "): divergence in nextIndex()");
				ensure(i.previousIndex() == j.previousIndex(), "Error (" + seed + "): divergence in previousIndex()");

			}

		}

		if (t.size() > 0) {
			java.util.ListIterator i, j;
			Object J;
			j = new java.util.LinkedList(t.keySet()).listIterator();
			int e = r.nextInt(t.size());
			Object from;
			do from = j.next(); while(e-- != 0);

			i = (java.util.ListIterator)((SORTED_SET)m.keySet()).iterator(KEY_OBJ2TYPE(from));

			for(int k = 0; k < 2*n; k++) {
				ensure(i.hasNext() == j.hasNext(), "Error (" + seed + "): divergence in hasNext() (iterator with starting point " + from + ")");
				ensure(i.hasPrevious() == j.hasPrevious(), "Error (" + seed + "): divergence in hasPrevious() (iterator with starting point " + from + ")");

				if (r.nextFloat() < .8 && i.hasNext()) {
#ifdef Custom
					ensure(m.strategy().equals(i.next(), J = j.next()), "Error (" + seed + "): divergence in next() (iterator with starting point " + from + ")");
#else
					ensure(i.next().equals(J = j.next()), "Error (" + seed + "): divergence in next() (iterator with starting point " + from + ")");
#endif

					if (r.nextFloat() < 0.5) {
						i.remove();
						j.remove();
						t.remove(J);
					}
				}
				else if (r.nextFloat() < .2 && i.hasPrevious()) {
#ifdef Custom
					ensure(m.strategy().equals(i.previous(), J = j.previous()), "Error (" + seed + "): divergence in previous() (iterator with starting point " + from + ")");
#else
					ensure(i.previous().equals(J = j.previous()), "Error (" + seed + "): divergence in previous() (iterator with starting point " + from + ")");
#endif

					if (r.nextFloat() < 0.5) {
						i.remove();
						j.remove();
						t.remove(J);
					}
				}

				ensure(i.nextIndex() == j.nextIndex(), "Error (" + seed + "): divergence in nextIndex() (iterator with starting point " + from + ")");
				ensure(i.previousIndex() == j.previousIndex(), "Error (" + seed + "): divergence in previousIndex() (iterator with starting point " + from + ")");

			}

		}



		/* Now we check that m actually holds that data. */

		ensure(m.equals(t), "Error (" + seed + "): ! m.equals(t) after iteration");
		ensure(t.equals(m), "Error (" + seed + "): ! t.equals(m) after iteration");

#endif


		/* Now we take out of m everything, and check that it is empty. */

		for(java.util.Iterator i=t.keySet().iterator(); i.hasNext();) m.remove(i.next());

		ensure(m.isEmpty(), "Error (" + seed + "): m is not empty (as it should be)");

#ifdef NumericEnhancements
#if VALUE_CLASS_Byte || VALUE_CLASS_Character || VALUE_CLASS_Short || VALUE_CLASS_Integer || VALUE_CLASS_Long
		/* Now we check that increment works properly, using random data */

		{
			t.clear();
			m.clear();

			for(int k = 0; k < 2*n; k++) {
				KEY_TYPE T = genKey();
				VALUE_TYPE U = genValue();

				VALUE_TYPE rU = m.increment(T, U);
				VALUE_GENERIC_CLASS tU = (VALUE_GENERIC_CLASS) t.get(KEY2OBJ(T));
				if (null == tU) {
					ensure(m.defaultReturnValue() == rU, "Error (" + seed + "): map increment does not return proper starting value.");
					t.put(KEY2OBJ(T), VALUE2OBJ((VALUE_TYPE) (m.defaultReturnValue() + U)));
				}
				else {
					t.put(KEY2OBJ(T), VALUE2OBJ((VALUE_TYPE) (((VALUE_TYPE) tU) + U)));
				}
			}

			// Maps should contain identical values
			ensure(new java.util.HashMap(m).equals(new java.util.HashMap(t)),
				"Error(" + seed + "): incremented maps are not equal.");
		}
#endif
#endif


#if (KEY_CLASS_Integer || KEY_CLASS_Long) && (VALUE_CLASS_Integer || VALUE_CLASS_Long)
		m = new OPEN_HASH_MAP(n, f);
		t.clear();
		int x;

		/* Now we torture-test the hash table. This part is implemented only for integers and longs. */

		int p = m.key.length;

		for(int i=0; i<p; i++) {
			for (int j=0; j<20; j++) {
				m.put(i+(r.nextInt() % 10)*p, 1);
				m.remove(i+(r.nextInt() % 10)*p);
			}

			for (int j=-10; j<10; j++) m.remove(i+j*p);
		}

		t.putAll(m);

		/* Now all table entries are REMOVED. */

		for(int i=0; i<(p*f)/10; i++) {
			for (int j=0; j<10; j++) {
				ensure(java.util.Objects.equals(m.put(KEY2OBJ(x = i+(r.nextInt() % 10)*p), VALUE2OBJ(1)), t.put(KEY2OBJ(x), VALUE2OBJ(1))),
					"Error (" + seed + "): m and t differ on an entry during torture-test insertion.");
			}
		}

		ensure(m.equals(t), "Error (" + seed + "): !m.equals(t) after torture-test insertion");;
		ensure(t.equals(m), "Error (" + seed + "): !t.equals(m) after torture-test insertion");;

		for(int i=0; i<p/10; i++) {
			for (int j=0; j<10; j++) {
				ensure(java.util.Objects.equals(m.remove(KEY2OBJ(x = i+(r.nextInt() % 10)*p)), t.remove(KEY2OBJ(x))),
					"Error (" + seed + "): m and t differ on an entry during torture-test removal.");
			}
		}

		ensure(m.equals(t), "Error (" + seed + "): !m.equals(t) after torture-test removal");;
		ensure(t.equals(m), "Error (" + seed + "): !t.equals(m) after torture-test removal");;

		ensure(m.equals(m.clone()), "Error (" + seed + "): !m.equals(m.clone()) after torture-test removal");;
		ensure(((OPEN_HASH_MAP)m.clone()).equals(m), "Error (" + seed + "): !m.clone().equals(m) after torture-test removal");;

		m.trim();

		ensure(m.equals(t), "Error (" + seed + "): !m.equals(t) after trim()");;
		ensure(t.equals(m), "Error (" + seed + "): !t.equals(m) after trim()");;
#endif

		System.out.println("Test OK");
		return;

#endif
	}


	public static void main(String args[]) throws Exception {
		float f = Hash.DEFAULT_LOAD_FACTOR;
		int n  = Integer.parseInt(args[1]);
		if (args.length>2) f = Float.parseFloat(args[2]);
		if (args.length > 3) r = new java.util.Random(seed = Long.parseLong(args[3]));

		try {
			if ("speedTest".equals(args[0]) || "speedComp".equals(args[0])) speedTest(n, f, "speedComp".equals(args[0]));
			else if ("test".equals(args[0])) runTest(n, f);
		} catch(Throwable e) {
			e.printStackTrace(System.err);
			System.err.println("seed: " + seed);
			throw e;
		}

	}

#endif

}
