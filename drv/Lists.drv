/*
 * Copyright (C) 2002-2020 Sebastiano Vigna
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package PACKAGE;

import java.util.List;
import java.util.Collection;
import java.util.Objects;
import java.util.Random;
import java.util.RandomAccess;
import java.util.function.Consumer;
#if KEYS_BYTE_CHAR_SHORT_FLOAT
import WIDENED_PACKAGE.KEY_WIDENED_ITERATOR;
import WIDENED_PACKAGE.WIDENED_ITERATORS;
import WIDENED_PACKAGE.KEY_WIDENED_SPLITERATOR;
import WIDENED_PACKAGE.WIDENED_SPLITERATORS;
#endif

#if KEYS_REFERENCE
import java.util.function.Predicate;
#endif

/** A class providing static methods and objects that do useful things with type-specific lists.
 *
 * @see java.util.Collections
 */

public final class LISTS {

#if KEYS_PRIMITIVE && !KEY_TYPE_Boolean
	/* Only in the EmptyList and Singleton classes, where performance is critical, do we override
	 * the deprecated, Object based functional methods. For the rest, we just override the
	 * non-deprecated type-specific method, and let the default method from the interface
	 * filter into that. This is an extra method call and lambda creation, but it isn't worth
	 * complexifying the code generation for a case that is already marked as being inefficient.
	 */
#endif

	private LISTS() {}

	/** Shuffles the specified list using the specified pseudorandom number generator.
	 *
	 * @param l the list to be shuffled.
	 * @param random a pseudorandom number generator.
	 * @return {@code l}.
	 */
	public static KEY_GENERIC LIST KEY_GENERIC shuffle(final LIST KEY_GENERIC l, final Random random) {
		for(int i = l.size(); i-- != 0;) {
			final int p = random.nextInt(i + 1);
			final KEY_GENERIC_TYPE t = l.GET_KEY(i);
			l.set(i, l.GET_KEY(p));
			l.set(p, t);
		}
		return l;
	}

	/** An immutable class representing an empty type-specific list.
	 *
	 * <p>This class may be useful to implement your own in case you subclass
	 * a type-specific list.
	 */

	public static class EmptyList KEY_GENERIC extends COLLECTIONS.EmptyCollection KEY_GENERIC implements LIST KEY_GENERIC, RandomAccess, java.io.Serializable, Cloneable {

		private static final long serialVersionUID = -7046029254386353129L;

		protected EmptyList() {}

		@Override
		public KEY_GENERIC_TYPE GET_KEY(int i) { throw new IndexOutOfBoundsException(); }

		@Override
		public boolean REMOVE(KEY_TYPE k) { throw new UnsupportedOperationException(); }

		@Override
		public KEY_GENERIC_TYPE REMOVE_KEY(int i) { throw new UnsupportedOperationException(); }

		@Override
		public void add(final int index, final KEY_GENERIC_TYPE k) { throw new UnsupportedOperationException(); }

		@Override
		public KEY_GENERIC_TYPE set(final int index, final KEY_GENERIC_TYPE k) { throw new UnsupportedOperationException(); }

		@Override
		public int indexOf(KEY_TYPE k) { return -1; }

		@Override
		public int lastIndexOf(KEY_TYPE k) { return -1; }

		@Override
		public boolean addAll(int i, Collection<? extends KEY_GENERIC_CLASS> c) { throw new UnsupportedOperationException(); }

#if KEYS_INT_LONG_DOUBLE
		@Deprecated
#endif
		@Override
		public void replaceAll(final java.util.function.UnaryOperator<KEY_GENERIC_CLASS> operator) {
			Objects.requireNonNull(operator);
		}

#if KEYS_PRIMITIVE
		@Override
		public boolean addAll(LIST c) { throw new UnsupportedOperationException(); }

		@Override
		public boolean addAll(int i, COLLECTION c) { throw new UnsupportedOperationException(); }

		@Override
		public boolean addAll(int i, LIST c) { throw new UnsupportedOperationException(); }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@SuppressWarnings("deprecation")
		@Deprecated
		@Override
		public void add(final int index, final KEY_GENERIC_CLASS k) { throw new UnsupportedOperationException(); }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@SuppressWarnings("deprecation")
		@Deprecated
		@Override
		public KEY_CLASS get(final int index) { throw new UnsupportedOperationException(); }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@SuppressWarnings("deprecation")
		@Deprecated
		@Override
		public boolean add(final KEY_GENERIC_CLASS k) { throw new UnsupportedOperationException(); }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@SuppressWarnings("deprecation")
		@Deprecated
		@Override
		public KEY_GENERIC_CLASS set(final int index, final KEY_GENERIC_CLASS k) { throw new UnsupportedOperationException(); }

#if KEYS_INT_LONG_DOUBLE
		@Override
		public void REPLACE_ALL_KEY(final JDK_PRIMITIVE_UNARY_OPERATOR operator) {
			Objects.requireNonNull(operator);
		}
#endif

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@SuppressWarnings("deprecation")
		@Deprecated
		@Override
		public KEY_GENERIC_CLASS remove(int k) { throw new UnsupportedOperationException(); }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@SuppressWarnings("deprecation")
		@Deprecated
		@Override
		public int indexOf(Object k) { return -1; }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@SuppressWarnings("deprecation")
		@Deprecated
		@Override
		public int lastIndexOf(Object k) { return -1; }

		// Empty lists are trivially always sorted
		@Override
		public void sort(final KEY_COMPARATOR comparator) { }

		@Override
		public void unstableSort(final KEY_COMPARATOR comparator) { }
#endif

		// Empty lists are trivially always sorted
		DEPRECATED_IF_KEYS_PRIMITIVE
		@Override
		public void sort(final java.util.Comparator<? super KEY_GENERIC_CLASS> comparator) { }

		DEPRECATED_IF_KEYS_PRIMITIVE
		@Override
		public void unstableSort(final java.util.Comparator<? super KEY_GENERIC_CLASS> comparator) { }

		SUPPRESS_WARNINGS_KEY_UNCHECKED
		@Override
		public KEY_LIST_ITERATOR KEY_GENERIC listIterator() { return ITERATORS.EMPTY_ITERATOR; }

		SUPPRESS_WARNINGS_KEY_UNCHECKED
		@Override
		public KEY_LIST_ITERATOR KEY_GENERIC iterator() { return ITERATORS.EMPTY_ITERATOR; }

		SUPPRESS_WARNINGS_KEY_UNCHECKED
		@Override
		public KEY_LIST_ITERATOR KEY_GENERIC listIterator(int i) { if (i == 0) return ITERATORS.EMPTY_ITERATOR; throw new IndexOutOfBoundsException(String.valueOf(i)); }

		@Override
		public LIST KEY_GENERIC subList(int from, int to) { if (from == 0 && to == 0) return this; throw new IndexOutOfBoundsException(); }

		@Override
		public void getElements(int from, KEY_TYPE[] a, int offset, int length) { if (from == 0 && length == 0 && offset >= 0 && offset <= a.length) return; throw new IndexOutOfBoundsException(); }

		@Override
		public void removeElements(int from, int to) { throw new UnsupportedOperationException(); }

		@Override
		public void addElements(int index, final KEY_GENERIC_TYPE a[], int offset, int length) { throw new UnsupportedOperationException(); }

		@Override
		public void addElements(int index, final KEY_GENERIC_TYPE a[]) { throw new UnsupportedOperationException(); }

		@Override
		public void setElements(final KEY_GENERIC_TYPE a[]) { throw new UnsupportedOperationException(); }

		@Override
		public void setElements(int index, final KEY_GENERIC_TYPE a[]) { throw new UnsupportedOperationException(); }

		@Override
		public void setElements(int index, final KEY_GENERIC_TYPE a[], int offset, int length) { throw new UnsupportedOperationException(); }

		@Override
		public void size(int s)  { throw new UnsupportedOperationException(); }

#if ! KEY_CLASS_Reference
		@Override
		public int compareTo(final List<? extends KEY_GENERIC_CLASS> o) {
			if (o == this) return 0;
			return ((List<?>)o).isEmpty() ? 0 : -1;
		}
#endif

		@Override
		public Object clone() { return EMPTY_LIST; }

		@Override
		public int hashCode() { return 1; }

		@Override
		@SuppressWarnings("rawtypes")
		public boolean equals(Object o) { return o instanceof List && ((List)o).isEmpty(); }

		@Override
		public String toString() { return "[]"; }

		private Object readResolve() { return EMPTY_LIST; }
	}

	/** An empty list (immutable). It is serializable and cloneable.
	 */
	SUPPRESS_WARNINGS_KEY_RAWTYPES
	public static final EmptyList EMPTY_LIST = new EmptyList();

	/** Returns an empty list (immutable). It is serializable and cloneable.
	 *
	 * <p>This method provides a typesafe access to {@link #EMPTY_LIST}.
	 * @return an empty list (immutable).
	 */
	@SuppressWarnings("unchecked")
	public static KEY_GENERIC LIST KEY_GENERIC emptyList() {
		return EMPTY_LIST;
	}

	/** An immutable class representing a type-specific singleton list.
	 *
	 * <p>This class may be useful to implement your own in case you subclass
	 * a type-specific list.
	 */

	public static class Singleton KEY_GENERIC extends ABSTRACT_LIST KEY_GENERIC implements RandomAccess, java.io.Serializable, Cloneable {

		private static final long serialVersionUID = -7046029254386353129L;

		private final KEY_GENERIC_TYPE element;

		protected Singleton(final KEY_GENERIC_TYPE element) { this.element = element; }

		@Override
		public KEY_GENERIC_TYPE GET_KEY(final int i) { if (i == 0) return element; throw new IndexOutOfBoundsException(); }

		@Override
		public boolean REMOVE(KEY_TYPE k) { throw new UnsupportedOperationException(); }

		@Override
		public KEY_GENERIC_TYPE REMOVE_KEY(final int i) { throw new UnsupportedOperationException(); }

		@Override
		public boolean contains(final KEY_TYPE k) { return KEY_EQUALS(k, element); }

		@Override
		public int indexOf(final KEY_TYPE k) { return KEY_EQUALS(k, element) ? 0 : -1; }

		/* Slightly optimized w.r.t. the one in ABSTRACT_SET. */

		@Override
		public KEY_TYPE[] TO_KEY_ARRAY() { return new KEY_TYPE[]{element}; }

		@Override
		public KEY_LIST_ITERATOR KEY_GENERIC listIterator() { return ITERATORS.singleton(element); }

		@Override
		public KEY_LIST_ITERATOR KEY_GENERIC iterator() { return listIterator(); }

		@Override
		public KEY_SPLITERATOR KEY_GENERIC spliterator() { return SPLITERATORS.singleton(element); }

		@Override
		public KEY_LIST_ITERATOR KEY_GENERIC listIterator(final int i) {
			if (i > 1 || i < 0) throw new  IndexOutOfBoundsException();
			final KEY_LIST_ITERATOR KEY_GENERIC l = listIterator();
			if (i == 1) l.NEXT_KEY();
			return l;
		}

		@Override
		SUPPRESS_WARNINGS_KEY_UNCHECKED
		public LIST KEY_GENERIC subList(final int from, final int to) {
			ensureIndex(from);
			ensureIndex(to);
			if (from > to) throw new IndexOutOfBoundsException("Start index (" + from + ") is greater than end index (" + to + ")");
			if (from != 0 || to != 1) return EMPTY_LIST;
			return this;
		}

		DEPRECATED_IF_KEYS_PRIMITIVE
		@Override
		public void forEach(final Consumer<? super KEY_GENERIC_CLASS> action) { action.accept(KEY2OBJ(element)); }

		@Override
		public boolean addAll(int i, Collection<? extends KEY_GENERIC_CLASS> c) { throw new UnsupportedOperationException(); }

		@Override
		public boolean addAll(final Collection<? extends KEY_GENERIC_CLASS> c) { throw new UnsupportedOperationException(); }

		@Override
		public boolean removeAll(final Collection<?> c) { throw new UnsupportedOperationException(); }

		@Override
		public boolean retainAll(final Collection<?> c) { throw new UnsupportedOperationException(); }

#if KEYS_PRIMITIVE
		@Deprecated
#endif
		@Override
		public boolean removeIf(final java.util.function.Predicate<? super KEY_GENERIC_CLASS> filter) { throw new UnsupportedOperationException(); }

#if KEYS_PRIMITIVE
		@Deprecated
#endif
		@Override
		public void replaceAll(final java.util.function.UnaryOperator<KEY_GENERIC_CLASS> operator) { throw new UnsupportedOperationException(); }

#if KEYS_PRIMITIVE

		@Override
		public void forEach(final METHOD_ARG_KEY_CONSUMER action) {	action.accept(element); }

		@Override
		public boolean addAll(LIST c) { throw new UnsupportedOperationException(); }

		@Override
		public boolean addAll(int i, LIST c) { throw new UnsupportedOperationException(); }

		@Override
		public boolean addAll(int i, COLLECTION c) { throw new UnsupportedOperationException(); }

		@Override
		public boolean addAll(final COLLECTION c) { throw new UnsupportedOperationException(); }

		@Override
		public boolean removeAll(final COLLECTION c) { throw new UnsupportedOperationException(); }

		@Override
		public boolean retainAll(final COLLECTION c) { throw new UnsupportedOperationException(); }

#if ! KEY_CLASS_Boolean
		@Override
		public void REPLACE_ALL_KEY(final JDK_PRIMITIVE_UNARY_OPERATOR operator) { throw new UnsupportedOperationException(); }
#endif

#if ! KEY_CLASS_Boolean
		@Override
		public boolean removeIf(final METHOD_ARG_PREDICATE filter) { throw new UnsupportedOperationException(); }
#endif

#if KEYS_BYTE_CHAR_SHORT_FLOAT
		@Override
		public KEY_WIDENED_ITERATOR KEY_WIDENED_ITERATOR_METHOD() { return WIDENED_ITERATORS.singleton(element); }

		@Override
		public KEY_WIDENED_SPLITERATOR KEY_WIDENED_SPLITERATOR_METHOD() { return WIDENED_SPLITERATORS.singleton(element); }
#endif

		@Deprecated
		@Override
		public Object[] toArray() { return new Object[]{ KEY2OBJ(element) }; }

		// Lists of size 1 are trivially always sorted
		@Override
		public void sort(final KEY_COMPARATOR comparator) { }

		@Override
		public void unstableSort(final KEY_COMPARATOR comparator) { }
#endif

		// Lists of size 1 are trivially always sorted
		DEPRECATED_IF_KEYS_PRIMITIVE
		@Override
		public void sort(final java.util.Comparator<? super KEY_GENERIC_CLASS> comparator) { }

		DEPRECATED_IF_KEYS_PRIMITIVE
		@Override
		public void unstableSort(final java.util.Comparator<? super KEY_GENERIC_CLASS> comparator) { }

		@Override
		public void getElements(int from, KEY_TYPE a[], int offset, int length) {
			if (offset < 0) throw new ArrayIndexOutOfBoundsException("Offset (" + offset + ") is negative");
			if (offset + length > a.length) throw new ArrayIndexOutOfBoundsException("End index (" + (offset + length) + ") is greater than array length (" + a.length + ")");
			if (from + length > size()) throw new IndexOutOfBoundsException("End index (" + (from + length) + ") is greater than list size (" + size() + ")");
			// Should be from == 0
			if (length <= 0) return;
			a[offset] = element;
		}

		@Override
		public void removeElements(int from, int to) { throw new UnsupportedOperationException(); }

		@Override
		public void addElements(int index, KEY_GENERIC_TYPE a[]) { throw new UnsupportedOperationException(); }

		@Override
		public void addElements(int index, KEY_GENERIC_TYPE a[], int offset, int length) { throw new UnsupportedOperationException(); }

		@Override
		public void setElements(final KEY_GENERIC_TYPE a[]) { throw new UnsupportedOperationException(); }

		@Override
		public void setElements(int index, final KEY_GENERIC_TYPE a[]) { throw new UnsupportedOperationException(); }

		@Override
		public void setElements(int index, final KEY_GENERIC_TYPE a[], int offset, int length) { throw new UnsupportedOperationException(); }

		@Override
		public int size() { return 1; }

		@Override
		public void size(final int size) { throw new UnsupportedOperationException(); }

		@Override
		public void clear() { throw new UnsupportedOperationException(); }

		@Override
		public Object clone() { return this; }
	}

	/** Returns a type-specific immutable list containing only the specified element. The returned list is serializable and cloneable.
	 *
	 * @param element the only element of the returned list.
	 * @return a type-specific immutable list containing just {@code element}.
	 */

	public static KEY_GENERIC LIST KEY_GENERIC singleton(final KEY_GENERIC_TYPE element) { return new Singleton KEY_GENERIC_DIAMOND(element); }

#if KEYS_PRIMITIVE

	/** Returns a type-specific immutable list containing only the specified element. The returned list is serializable and cloneable.
	 *
	 * @param element the only element of the returned list.
	 * @return a type-specific immutable list containing just {@code element}.
	 */

	public static KEY_GENERIC LIST KEY_GENERIC singleton(final Object element) { return new Singleton KEY_GENERIC_DIAMOND(KEY_OBJ2TYPE(element)); }

#endif


	/** A synchronized wrapper class for lists. */

	public static class SynchronizedList KEY_GENERIC extends COLLECTIONS.SynchronizedCollection KEY_GENERIC implements LIST KEY_GENERIC, java.io.Serializable {

		private static final long serialVersionUID = -7046029254386353129L;

		protected final LIST KEY_GENERIC list; // Due to the large number of methods that are not in COLLECTION, this is worth caching.

		protected SynchronizedList(final LIST KEY_GENERIC l, final Object sync) {
			super(l, sync);
			this.list = l;
		}

		protected SynchronizedList(final LIST KEY_GENERIC l) {
			super(l);
			this.list = l;
		}

		@Override
		public KEY_GENERIC_TYPE GET_KEY(final int i) { synchronized(sync) { return list.GET_KEY(i); } }

		@Override
		public KEY_GENERIC_TYPE set(final int i, final KEY_GENERIC_TYPE k) { synchronized(sync) { return list.set(i, k); } }

		@Override
		public void add(final int i, final KEY_GENERIC_TYPE k) { synchronized(sync) { list.add(i, k); } }

		@Override
		public KEY_GENERIC_TYPE REMOVE_KEY(final int i) { synchronized(sync) { return list.REMOVE_KEY(i); } }

		@Override
		public int indexOf(final KEY_TYPE k) { synchronized(sync) { return list.indexOf(k); } }

		@Override
		public int lastIndexOf(final KEY_TYPE k) { synchronized(sync) { return list.lastIndexOf(k); } }

		@Override
		public boolean removeIf(final METHOD_ARG_PREDICATE filter) { synchronized(sync) { return list.removeIf(filter); } }

		@Override
#ifdef  JDK_PRIMITIVE_UNARY_OPERATOR
		public void REPLACE_ALL_KEY(final METHOD_ARG_UNARY_OPERATOR operator) { synchronized(sync) { list.REPLACE_ALL_KEY(operator); } }
#else
		public void replaceAll(final METHOD_ARG_UNARY_OPERATOR operator) { synchronized(sync) { list.replaceAll(operator); } }
#endif
		@Override
		public boolean addAll(final int index, final Collection<? extends KEY_GENERIC_CLASS> c) { synchronized(sync) { return list.addAll(index, c); } }

		@Override
		public void getElements(final int from, final KEY_TYPE a[], final int offset, final int length) { synchronized(sync) { list.getElements(from, a, offset, length); } }

		@Override
		public void removeElements(final int from, final int to) { synchronized(sync) { list.removeElements(from, to); } }

		@Override
		public void addElements(int index, final KEY_GENERIC_TYPE a[], int offset, int length) { synchronized(sync) { list.addElements(index, a, offset, length); } }

		@Override
		public void addElements(int index, final KEY_GENERIC_TYPE a[]) { synchronized(sync) { list.addElements(index, a); } }

		@Override
		public void setElements(final KEY_GENERIC_TYPE a[]) { synchronized(sync) { list.setElements(a); } }

		@Override
		public void setElements(int index, final KEY_GENERIC_TYPE a[]) { synchronized(sync) { list.setElements(index, a); } }

		@Override
		public void setElements(int index, final KEY_GENERIC_TYPE a[], int offset, int length) { synchronized(sync) { list.setElements(index, a, offset, length); } }

		@Override
		public void size(final int size) { synchronized(sync) { list.size(size); } }

		@Override
		public KEY_LIST_ITERATOR KEY_GENERIC listIterator() { return list.listIterator(); }

		@Override
		public KEY_LIST_ITERATOR KEY_GENERIC iterator() { return listIterator(); }

		@Override
		public KEY_LIST_ITERATOR KEY_GENERIC listIterator(final int i) { return list.listIterator(i); }

		@Override
		public LIST KEY_GENERIC subList(final int from, final int to) { synchronized(sync) { return new SynchronizedList KEY_GENERIC_DIAMOND(list.subList(from, to), sync); } }

		@Override
		public boolean equals(final Object o) { if (o == this) return true; synchronized(sync) { return collection.equals(o); } }

		@Override
		public int hashCode() { synchronized(sync) { return collection.hashCode(); } }

#if ! KEY_CLASS_Reference
		@Override
		public int compareTo(final List<? extends KEY_GENERIC_CLASS> o) { synchronized(sync) { return list.compareTo(o); } }
#endif

#if KEYS_PRIMITIVE
		@Override
		public boolean addAll(final int index, final COLLECTION c) { synchronized(sync) { return list.addAll(index, c); } }

		@Override
		public boolean addAll(final int index, LIST l) { synchronized(sync) { return list.addAll(index, l); } }

		@Override
		public boolean addAll(LIST l) { synchronized(sync) { return list.addAll(l); } }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public KEY_GENERIC_CLASS get(final int i) { synchronized(sync) { return list.get(i); } }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public void add(final int i, KEY_GENERIC_CLASS k) { synchronized(sync) { list.add(i, k); } }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public KEY_GENERIC_CLASS set(final int index, KEY_GENERIC_CLASS k) { synchronized(sync) { return list.set(index, k); } }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public KEY_GENERIC_CLASS remove(final int i) { synchronized(sync) { return list.remove(i); } }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public int indexOf(final Object o) { synchronized(sync) { return list.indexOf(o); } }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public int lastIndexOf(final Object o) { synchronized(sync) { return list.lastIndexOf(o); } }

		@Override
		public void sort(final KEY_COMPARATOR comparator) { synchronized(sync) { list.sort(comparator); } }

		@Override
		public void unstableSort(final KEY_COMPARATOR comparator) { synchronized(sync) { list.unstableSort(comparator); } }
#endif

		DEPRECATED_IF_KEYS_PRIMITIVE
		@Override
		public void sort(final java.util.Comparator<? super KEY_GENERIC_CLASS> comparator) { synchronized(sync) {list.sort(comparator); } }

		DEPRECATED_IF_KEYS_PRIMITIVE
		@Override
		public void unstableSort(final java.util.Comparator<? super KEY_GENERIC_CLASS> comparator) { synchronized(sync) {list.unstableSort(comparator); } }

		private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {
			synchronized(sync) { s.defaultWriteObject(); }
		}
	}


	/** A synchronized wrapper class for random-access lists. */

	public static class SynchronizedRandomAccessList KEY_GENERIC extends SynchronizedList KEY_GENERIC implements RandomAccess, java.io.Serializable {
		private static final long serialVersionUID = 0L;

		protected SynchronizedRandomAccessList(final LIST KEY_GENERIC l, final Object sync) {
			super(l, sync);
		}

		protected SynchronizedRandomAccessList(final LIST KEY_GENERIC l) {
			super(l);
		}

		@Override
		public LIST KEY_GENERIC subList(final int from, final int to) { synchronized(sync) { return new SynchronizedRandomAccessList KEY_GENERIC_DIAMOND(list.subList(from, to), sync); } }
	}


	/** Returns a synchronized type-specific list backed by the given type-specific list.
	 *
	 * @param l the list to be wrapped in a synchronized list.
	 * @return a synchronized view of the specified list.
	 * @see java.util.Collections#synchronizedList(List)
	 */
	public static KEY_GENERIC LIST KEY_GENERIC synchronize(final LIST KEY_GENERIC l) {
		return l instanceof RandomAccess ? new SynchronizedRandomAccessList KEY_GENERIC_DIAMOND(l) : new SynchronizedList KEY_GENERIC_DIAMOND(l);
	}

	/** Returns a synchronized type-specific list backed by the given type-specific list, using an assigned object to synchronize.
	 *
	 * @param l the list to be wrapped in a synchronized list.
	 * @param sync an object that will be used to synchronize the access to the list.
	 * @return a synchronized view of the specified list.
	 * @see java.util.Collections#synchronizedList(List)
	 */

	public static KEY_GENERIC LIST KEY_GENERIC synchronize(final LIST KEY_GENERIC l, final Object sync) {
		return l instanceof RandomAccess ? new SynchronizedRandomAccessList KEY_GENERIC_DIAMOND(l, sync) : new SynchronizedList KEY_GENERIC_DIAMOND(l, sync);
	}



	/** An unmodifiable wrapper class for lists. */

	public static class UnmodifiableList KEY_GENERIC extends COLLECTIONS.UnmodifiableCollection KEY_GENERIC implements LIST KEY_GENERIC, java.io.Serializable {

		private static final long serialVersionUID = -7046029254386353129L;

		protected final LIST KEY_GENERIC list; // Due to the large number of methods that are not in COLLECTION, this is worth caching.

		protected UnmodifiableList(final LIST KEY_GENERIC l) {
			super(l);
			this.list = l;
		}

		@Override
		public KEY_GENERIC_TYPE GET_KEY(final int i) { return list.GET_KEY(i); }

		@Override
		public KEY_GENERIC_TYPE set(final int i, final KEY_GENERIC_TYPE k) { throw new UnsupportedOperationException(); }

		@Override
		public void add(final int i, final KEY_GENERIC_TYPE k) { throw new UnsupportedOperationException(); }

		@Override
		public KEY_GENERIC_TYPE REMOVE_KEY(final int i) { throw new UnsupportedOperationException(); }

		@Override
		public int indexOf(final KEY_TYPE k) { return list.indexOf(k); }

		@Override
		public int lastIndexOf(final KEY_TYPE k) { return list.lastIndexOf(k); }

		@Override
		public boolean addAll(final int index, final Collection<? extends KEY_GENERIC_CLASS> c) { throw new UnsupportedOperationException(); }

#if defined JDK_PRIMITIVE_UNARY_OPERATOR && KEYS_PRIMITIVE
		@Deprecated
#endif
		@Override
		public void replaceAll(final java.util.function.UnaryOperator<KEY_GENERIC_CLASS> operator) { throw new UnsupportedOperationException(); }

		@Override
		public void getElements(final int from, final KEY_TYPE a[], final int offset, final int length) { list.getElements(from, a, offset, length); }

		@Override
		public void removeElements(final int from, final int to) { throw new UnsupportedOperationException(); }

		@Override
		public void addElements(int index, final KEY_GENERIC_TYPE a[], int offset, int length) { throw new UnsupportedOperationException(); }

		@Override
		public void addElements(int index, final KEY_GENERIC_TYPE a[]) { throw new UnsupportedOperationException(); }

		@Override
		public void setElements(final KEY_GENERIC_TYPE a[]) { throw new UnsupportedOperationException(); }

		@Override
		public void setElements(int index, final KEY_GENERIC_TYPE a[]) { throw new UnsupportedOperationException(); }

		@Override
		public void setElements(int index, final KEY_GENERIC_TYPE a[], int offset, int length) { throw new UnsupportedOperationException(); }

		@Override
		public void size(final int size) { list.size(size); }

		@Override
		public KEY_LIST_ITERATOR KEY_GENERIC listIterator() { return ITERATORS.unmodifiable(list.listIterator()); }

		@Override
		public KEY_LIST_ITERATOR KEY_GENERIC iterator() { return listIterator(); }

		@Override
		public KEY_LIST_ITERATOR KEY_GENERIC listIterator(final int i) { return ITERATORS.unmodifiable(list.listIterator(i)); }

		@Override
		public LIST KEY_GENERIC subList(final int from, final int to) { return new UnmodifiableList KEY_GENERIC_DIAMOND(list.subList(from, to)); }

		@Override
		public boolean equals(final Object o) { if (o == this) return true; return collection.equals(o); }

		@Override
		public int hashCode() { return collection.hashCode(); }

#if ! KEY_CLASS_Reference
		@Override
		public int compareTo(final List<? extends KEY_GENERIC_CLASS> o) { return list.compareTo(o); }
#endif

#if KEYS_PRIMITIVE
		@Override
		public boolean addAll(final int index, final COLLECTION c) { throw new UnsupportedOperationException(); }

		@Override
		public boolean addAll(final LIST l) { throw new UnsupportedOperationException(); }

		@Override
		public boolean addAll(final int index, final LIST l) { throw new UnsupportedOperationException(); }

#if defined JDK_PRIMITIVE_UNARY_OPERATOR
		@Override
		public void REPLACE_ALL_KEY(final JDK_PRIMITIVE_UNARY_OPERATOR operator) { throw new UnsupportedOperationException(); }
#endif

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public KEY_GENERIC_CLASS get(final int i) { return list.get(i); }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public void add(final int i, KEY_GENERIC_CLASS k) { throw new UnsupportedOperationException(); }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public KEY_GENERIC_CLASS set(final int index, KEY_GENERIC_CLASS k) { throw new UnsupportedOperationException(); }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public KEY_GENERIC_CLASS remove(final int i) { throw new UnsupportedOperationException(); }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public int indexOf(final Object o) { return list.indexOf(o); }

		/** {@inheritDoc}
		 * @deprecated Please use the corresponding type-specific method instead. */
		@Deprecated
		@Override
		public int lastIndexOf(final Object o) { return list.lastIndexOf(o); }

		@Override
		public void sort(final KEY_COMPARATOR comparator) { throw new UnsupportedOperationException(); }

		@Override
		public void unstableSort(final KEY_COMPARATOR comparator) { throw new UnsupportedOperationException(); }
#endif
		DEPRECATED_IF_KEYS_PRIMITIVE
		@Override
		public void sort(final java.util.Comparator<? super KEY_GENERIC_CLASS> comparator) { throw new UnsupportedOperationException(); }

		DEPRECATED_IF_KEYS_PRIMITIVE
		@Override
		public void unstableSort(final java.util.Comparator<? super KEY_GENERIC_CLASS> comparator) { throw new UnsupportedOperationException(); }
	}


	/** An unmodifiable wrapper class for random-access lists. */

	public static class UnmodifiableRandomAccessList KEY_GENERIC extends UnmodifiableList KEY_GENERIC implements RandomAccess, java.io.Serializable {

		private static final long serialVersionUID = 0L;

		protected UnmodifiableRandomAccessList(final LIST KEY_GENERIC l) {
			super(l);
		}

		@Override
		public LIST KEY_GENERIC subList(final int from, final int to) { return new UnmodifiableRandomAccessList KEY_GENERIC_DIAMOND(list.subList(from, to)); }
	}


	/** Returns an unmodifiable type-specific list backed by the given type-specific list.
	 *
	 * @param l the list to be wrapped in an unmodifiable list.
	 * @return an unmodifiable view of the specified list.
	 * @see java.util.Collections#unmodifiableList(List)
	 */
	public static KEY_GENERIC LIST KEY_GENERIC unmodifiable(final LIST KEY_GENERIC l) {
		return l instanceof RandomAccess ? new UnmodifiableRandomAccessList KEY_GENERIC_DIAMOND(l) : new UnmodifiableList KEY_GENERIC_DIAMOND(l);
	}




#ifdef TEST

	private static KEY_TYPE genKey() {
#if KEY_CLASS_Byte || KEY_CLASS_Short || KEY_CLASS_Character
		return (KEY_TYPE)(r.nextInt());
#elif KEYS_PRIMITIVE
		return r.NEXT_KEY();
#elif KEY_CLASS_Object
		return Integer.toBinaryString(r.nextInt());
#else
		return new java.io.Serializable() {};
#endif
	}


	private static void testLists(KEY_TYPE k, LIST m, List t, int level) throws Exception {
		int n = 100;
		int c;

		long ms;
		boolean mThrowsIllegal, tThrowsIllegal, mThrowsNoElement, tThrowsNoElement, mThrowsIndex, tThrowsIndex, mThrowsUnsupp, tThrowsUnsupp;
		boolean rt = false, rm = false;
		Object Rt = null, Rm = null;

		if (level == 0) return;

		/* Now we check that m and t are equal. */
		if (!m.equals(t) || ! t.equals(m)) System.err.println("m: " + m + " t: " + t);

		ensure(m.equals(t), "Error (" + level + ", " + seed + "): ! m.equals(t) at start");
		ensure(t.equals(m), "Error (" + level + ", " + seed + "): ! t.equals(m) at start");

		/* Now we check that m actually holds that data. */
		for(java.util.Iterator i=t.iterator(); i.hasNext();) {
			ensure(m.contains(i.next()), "Error (" + level + ", " + seed + "): m and t differ on an entry after insertion (iterating on t)");
		}

		/* Now we check that m actually holds that data, but iterating on m. */
		for(java.util.Iterator i=m.listIterator(); i.hasNext();) {
			ensure(t.contains(i.next()), "Error (" + level + ", " + seed + "): m and t differ on an entry after insertion (iterating on m)");
		}

		/* Now we check that inquiries about random data give the same answer in m and t. For
		   m we use the polymorphic method. */

		for(int i=0; i<n;  i++) {
			KEY_TYPE T = genKey();

			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			try {
				m.contains(T);
			}
			catch (java.util.NoSuchElementException e) { mThrowsNoElement = true; }
			catch (IllegalArgumentException e) { mThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { mThrowsIndex = true; }

			try {
				t.contains(KEY2OBJ(T));
			}
			catch (java.util.NoSuchElementException e) { tThrowsNoElement = true; }
			catch (IllegalArgumentException e) { tThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { tThrowsIndex = true; }

			ensure(mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): contains() divergence in java.util.NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m);
			ensure(mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): contains() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m);
			ensure(mThrowsIndex == tThrowsIndex, "Error (" + level + ", " + seed + "): contains() divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m);
			if (!mThrowsNoElement && !mThrowsIllegal && !mThrowsIndex) ensure(m.contains(KEY2OBJ(T)) == t.contains(KEY2OBJ(T)), "Error (" + level + ", " + seed + "): divergence in keys between t and m (polymorphic method) " + m);
		}

		/* Again, we check that inquiries about random data give the same answer in m and t, but
		   for m we use the standard method. */

		for(int i=0; i<n;  i++) {
			KEY_TYPE T = genKey();

			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			try {
				m.contains(KEY2OBJ(T));
			}
			catch (java.util.NoSuchElementException e) { mThrowsNoElement = true; }
			catch (IllegalArgumentException e) { mThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { mThrowsIndex = true; }
			catch (UnsupportedOperationException e) { mThrowsUnsupp = true; }

			try {
				t.contains(KEY2OBJ(T));
			}
			catch (java.util.NoSuchElementException e) { tThrowsNoElement = true; }
			catch (IllegalArgumentException e) { tThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { tThrowsIndex = true; }
			catch (UnsupportedOperationException e) { tThrowsUnsupp = true; }

			ensure(mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): contains() divergence in java.util.NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m);
			ensure(mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): contains() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m);
			ensure(mThrowsIndex == tThrowsIndex, "Error (" + level + ", " + seed + "): contains() divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m);
			ensure(mThrowsUnsupp == tThrowsUnsupp, "Error (" + level + ", " + seed + "): contains() divergence in UnsupportedOperationException for " + T + " (" + mThrowsUnsupp + ", " + tThrowsUnsupp + ") " + m);
			if (!mThrowsNoElement && !mThrowsIllegal && !mThrowsIndex && !mThrowsUnsupp) ensure(m.contains(KEY2OBJ(T)) ==  t.contains(KEY2OBJ(T)), "Error (" + level + ", " + seed + "): divergence between t and m (standard method) " + m);
		}

		/* Now we add and remove random data in m and t, checking that the result is the same. */

		for(int i=0; i<20*n;  i++) {
			KEY_TYPE T = genKey();

			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			try {
				rm = m.add(KEY2OBJ(T));
			}
			catch (java.util.NoSuchElementException e) { mThrowsNoElement = true; }
			catch (IllegalArgumentException e) { mThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { mThrowsIndex = true; }
			catch (UnsupportedOperationException e) { mThrowsUnsupp = true; }

			try {
				rt = t.add(KEY2OBJ(T));
			}
			catch (java.util.NoSuchElementException e) { tThrowsNoElement = true; }
			catch (IllegalArgumentException e) { tThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { tThrowsIndex = true; }
			catch (UnsupportedOperationException e) { tThrowsUnsupp = true; }

			ensure(mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): add() divergence in java.util.NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m);
			ensure(mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): add() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m);
			ensure(mThrowsIndex == tThrowsIndex, "Error (" + level + ", " + seed + "): add() divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m);
			ensure(mThrowsUnsupp == tThrowsUnsupp, "Error (" + level + ", " + seed + "): add() divergence in UnsupportedOperationException for " + T + " (" + mThrowsUnsupp + ", " + tThrowsUnsupp + ") " + m);
			if (!mThrowsNoElement && !mThrowsIllegal && !mThrowsIndex && !mThrowsUnsupp) ensure(rm == rt, "Error (" + level + ", " + seed + "): divergence in add() between t and m " + m);

			T = genKey();

			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			try {
				rm = m.remove(KEY2OBJ(T));
			}
			catch (java.util.NoSuchElementException e) { mThrowsNoElement = true; }
			catch (IllegalArgumentException e) { mThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { mThrowsIndex = true; }
			catch (UnsupportedOperationException e) { mThrowsUnsupp = true; }

			try {
				rt = t.remove(KEY2OBJ(T));
			}
			catch (java.util.NoSuchElementException e) { tThrowsNoElement = true; }
			catch (IllegalArgumentException e) { tThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { tThrowsIndex = true; }
			catch (UnsupportedOperationException e) { tThrowsUnsupp = true; }

			if (! KEY_EQUALS(T, k) && mThrowsUnsupp && ! tThrowsUnsupp) mThrowsUnsupp = true; // Stupid bug in Collections.singleton()

			ensure(mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): remove() divergence in java.util.NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m);
			ensure(mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): remove() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m);
			ensure(mThrowsIndex == tThrowsIndex, "Error (" + level + ", " + seed + "): remove() divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m);
			ensure(mThrowsUnsupp == tThrowsUnsupp, "Error (" + level + ", " + seed + "): remove() divergence in UnsupportedOperationException for " + T + " (" + mThrowsUnsupp + ", " + tThrowsUnsupp + ") " + m);
			if (!mThrowsNoElement && !mThrowsIllegal && !mThrowsIndex && !mThrowsUnsupp) ensure(rm == rt, "Error (" + level + ", " + seed + "): divergence in remove() between t and m " + m);
		}

		ensure(m.equals(t), "Error (" + level + ", " + seed + "): ! m.equals(t) after removal " + m);
		ensure(t.equals(m), "Error (" + level + ", " + seed + "): ! t.equals(m) after removal " + m);

		/* Now we add and remove random data in m and t at specific positions, checking that the result is the same. */

		for(int i=0; i<20*n;  i++) {
			KEY_TYPE T = genKey();

			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			int pos = r.nextInt(2);

			try {
				m.add(pos, KEY2OBJ(T));
			}
			catch (java.util.NoSuchElementException e) { mThrowsNoElement = true; }
			catch (IllegalArgumentException e) { mThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { mThrowsIndex = true; }
			catch (UnsupportedOperationException e) { mThrowsUnsupp = true; }

			try {
				t.add(pos, KEY2OBJ(T));
			}
			catch (java.util.NoSuchElementException e) { tThrowsNoElement = true; }
			catch (IllegalArgumentException e) { tThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { tThrowsIndex = true; }
			catch (UnsupportedOperationException e) { tThrowsUnsupp = true; }

			ensure(mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): add() at " + pos + " divergence in java.util.NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m);
			ensure(mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): add() at " + pos + " divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m);
			ensure(mThrowsIndex == tThrowsIndex, "Error (" + level + ", " + seed + "): add() at " + pos + " divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m);
			ensure(mThrowsUnsupp == tThrowsUnsupp, "Error (" + level + ", " + seed + "): add() at " + pos + " divergence in UnsupportedOperationException for " + T + " (" + mThrowsUnsupp + ", " + tThrowsUnsupp + ") " + m);

			T = genKey();

			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			pos = r.nextInt(2);

			try {
				Rm = m.remove(pos);
			}
			catch (java.util.NoSuchElementException e) { mThrowsNoElement = true; }
			catch (IllegalArgumentException e) { mThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { mThrowsIndex = true; }
			catch (UnsupportedOperationException e) { mThrowsUnsupp = true; }

			try {
				Rt = t.remove(pos);
			}
			catch (java.util.NoSuchElementException e) { tThrowsNoElement = true; }
			catch (IllegalArgumentException e) { tThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { tThrowsIndex = true; }
			catch (UnsupportedOperationException e) { tThrowsUnsupp = true; }


			ensure(mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): remove() at " + pos + " divergence in java.util.NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m);
			ensure(mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): remove() at " + pos + " divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m);
			ensure(mThrowsIndex == tThrowsIndex, "Error (" + level + ", " + seed + "): remove() at " + pos + " divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m);
			ensure(mThrowsUnsupp == tThrowsUnsupp, "Error (" + level + ", " + seed + "): remove() at " + pos + " divergence in UnsupportedOperationException for " + T + " (" + mThrowsUnsupp + ", " + tThrowsUnsupp + ") " + m);
			if (!mThrowsNoElement && !mThrowsIllegal && !mThrowsIndex && !mThrowsUnsupp) ensure(Rm == Rt || Rm != null && Rm.equals(Rt), "Error (" + level + ", " + seed + "): divergence in remove() at " + pos + " between t and m " + m);
		}

		ensure(m.equals(t), "Error (" + level + ", " + seed + "): ! m.equals(t) after removal " + m);
		ensure(t.equals(m), "Error (" + level + ", " + seed + "): ! t.equals(m) after removal " + m);

		/* Now we add and remove random collections in m and t, checking that the result is the same. */

		for(int i=0; i<20*n;  i++) {
			KEY_TYPE T = genKey();

			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			try {
				rm = m.addAll(java.util.Collections.singleton(KEY2OBJ(T)));
			}
			catch (java.util.NoSuchElementException e) { mThrowsNoElement = true; }
			catch (IllegalArgumentException e) { mThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { mThrowsIndex = true; }
			catch (UnsupportedOperationException e) { mThrowsUnsupp = true; }

			try {
				rt = t.addAll(java.util.Collections.singleton(KEY2OBJ(T)));
			}
			catch (java.util.NoSuchElementException e) { tThrowsNoElement = true; }
			catch (IllegalArgumentException e) { tThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { tThrowsIndex = true; }
			catch (UnsupportedOperationException e) { tThrowsUnsupp = true; }

			ensure(mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): addAll() divergence in java.util.NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m);
			ensure(mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): addAll() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m);
			ensure(mThrowsIndex == tThrowsIndex, "Error (" + level + ", " + seed + "): addAll() divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m);
			ensure(mThrowsUnsupp == tThrowsUnsupp, "Error (" + level + ", " + seed + "): addAll() divergence in UnsupportedOperationException for " + T + " (" + mThrowsUnsupp + ", " + tThrowsUnsupp + ") " + m);
			if (!mThrowsNoElement && !mThrowsIllegal && !mThrowsIndex && !mThrowsUnsupp) ensure(rm == rt, "Error (" + level + ", " + seed + "): divergence in addAll() between t and m " + m);

			T = genKey();

			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			try {
				rm = m.removeAll(java.util.Collections.singleton(KEY2OBJ(T)));
			}
			catch (java.util.NoSuchElementException e) { mThrowsNoElement = true; }
			catch (IllegalArgumentException e) { mThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { mThrowsIndex = true; }
			catch (UnsupportedOperationException e) { mThrowsUnsupp = true; }

			try {
				rt = t.removeAll(java.util.Collections.singleton(KEY2OBJ(T)));
			}
			catch (java.util.NoSuchElementException e) { tThrowsNoElement = true; }
			catch (IllegalArgumentException e) { tThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { tThrowsIndex = true; }
			catch (UnsupportedOperationException e) { tThrowsUnsupp = true; }


			ensure(mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): removeAll() divergence in java.util.NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m);
			ensure(mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): removeAll() divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m);
			ensure(mThrowsIndex == tThrowsIndex, "Error (" + level + ", " + seed + "): removeAll() divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m);
			ensure(mThrowsUnsupp == tThrowsUnsupp, "Error (" + level + ", " + seed + "): removeAll() divergence in UnsupportedOperationException for " + T + " (" + mThrowsUnsupp + ", " + tThrowsUnsupp + ") " + m);
			if (!mThrowsNoElement && !mThrowsIllegal && !mThrowsIndex && !mThrowsUnsupp) ensure(rm == rt, "Error (" + level + ", " + seed + "): divergence in removeAll() between t and m " + m);
		}

		ensure(m.equals(t), "Error (" + level + ", " + seed + "): ! m.equals(t) after set removal " + m);
		ensure(t.equals(m), "Error (" + level + ", " + seed + "): ! t.equals(m) after set removal " + m);

		/* Now we add random collections at specific positions in m and t, checking that the result is the same. */

		for(int i=0; i<20*n;  i++) {
			KEY_TYPE T = genKey();

			mThrowsIndex = tThrowsIndex = mThrowsNoElement = tThrowsNoElement = mThrowsIllegal = tThrowsIllegal = mThrowsUnsupp = tThrowsUnsupp = false;

			int pos = r.nextInt(2);

			try {
				rm = m.addAll(pos, java.util.Collections.singleton(KEY2OBJ(T)));
			}
			catch (java.util.NoSuchElementException e) { mThrowsNoElement = true; }
			catch (IllegalArgumentException e) { mThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { mThrowsIndex = true; }
			catch (UnsupportedOperationException e) { mThrowsUnsupp = true; }

			try {
				rt = t.addAll(pos, java.util.Collections.singleton(KEY2OBJ(T)));
			}
			catch (java.util.NoSuchElementException e) { tThrowsNoElement = true; }
			catch (IllegalArgumentException e) { tThrowsIllegal = true; }
			catch (IndexOutOfBoundsException e) { tThrowsIndex = true; }
			catch (UnsupportedOperationException e) { tThrowsUnsupp = true; }

			ensure(mThrowsNoElement == tThrowsNoElement, "Error (" + level + ", " + seed + "): addAll() at " + pos + " divergence in java.util.NoSuchElementException for " + T + " (" + mThrowsNoElement + ", " + tThrowsNoElement + ") " + m);
			ensure(mThrowsIllegal == tThrowsIllegal, "Error (" + level + ", " + seed + "): addAll() at " + pos + " divergence in IllegalArgumentException for " + T + " (" + mThrowsIllegal + ", " + tThrowsIllegal + ") " + m);
			ensure(mThrowsIndex == tThrowsIndex, "Error (" + level + ", " + seed + "): addAll() at " + pos + " divergence in IndexOutOfBoundsException for " + T + " (" + mThrowsIndex + ", " + tThrowsIndex + ") " + m);
			ensure(mThrowsUnsupp == tThrowsUnsupp, "Error (" + level + ", " + seed + "): addAll() at " + pos + " divergence in UnsupportedOperationException for " + T + " (" + mThrowsUnsupp + ", " + tThrowsUnsupp + ") " + m);
			if (!mThrowsNoElement && !mThrowsIllegal && !mThrowsIndex && !mThrowsUnsupp) ensure(rm == rt, "Error (" + level + ", " + seed + "): divergence in addAll() at " + pos + " between t and m " + m);

		}

		ensure(m.equals(t), "Error (" + level + ", " + seed + "): ! m.equals(t) after set removal " + m);
		ensure(t.equals(m), "Error (" + level + ", " + seed + "): ! t.equals(m) after set removal " + m);

		/* Now we check that m actually holds the same data. */

		for(java.util.Iterator i=t.iterator(); i.hasNext();) {
			ensure(m.contains(i.next()), "Error (" + level + ", " + seed + "): m and t differ on an entry after removal (iterating on t)");
		}

		/* Now we check that m actually holds that data, but iterating on m. */

		for(java.util.Iterator i=m.listIterator(); i.hasNext();) {
			ensure(t.contains(i.next()), "Error (" + level + ", " + seed + "): m and t differ on an entry after removal (iterating on m)");
		}

		if (m instanceof Singleton) {
			ensure(m.equals(((Singleton)m).clone()), "Error (" + level + ", " + seed + "): m does not equal m.clone()");
			ensure(((Singleton)m).clone().equals(m), "Error (" + level + ", " + seed + "): m.clone() does not equal m");
		}

		int h = m.hashCode();

		/* Now we save and read m. */

		LIST m2 = null;

		{
			java.io.File ff = new java.io.File("it.unimi.dsi.fastutil.test." + m.getClass().getSimpleName() + "." + n);
			java.io.OutputStream os = new java.io.FileOutputStream(ff);
			java.io.ObjectOutputStream oos = new java.io.ObjectOutputStream(os);

			oos.writeObject(m);
			oos.close();

			java.io.InputStream is = new java.io.FileInputStream(ff);
			java.io.ObjectInputStream ois = new java.io.ObjectInputStream(is);

			m2 = (LIST)ois.readObject();
			ois.close();
			ff.delete();
		}

#if ! KEY_CLASS_Reference

		ensure(m2.hashCode() == h, "Error (" + level + ", " + seed + "): hashCode() changed after save/read");

		/* Now we check that m2 actually holds that data. */

		ensure(m2.equals(t), "Error (" + level + ", " + seed + "): ! m2.equals(t) after save/read");
		ensure(t.equals(m2), "Error (" + level + ", " + seed + "): ! t.equals(m2) after save/read");
#endif

		if (! m.isEmpty()) {
			int start = r.nextInt(m.size());
			int end = start + r.nextInt(m.size() - start);
			//System.err.println("Checking subList from " + start + " to " + end + " (level=" + (level+1) + ")...");
			testLists(k, m.subList(start, end), t.subList(start, end), level - 1);

			ensure(m.equals(t), () -> "Error (" + level + ", " + seed + m + t + "): ! m.equals(t) after subList");
			ensure(t.equals(m), "Error (" + level + ", " + seed + "): ! t.equals(m) after subList");

		}

		return;
	}

	private static void test() throws Exception {
		KEY_TYPE k = genKey();
		LIST m = new Singleton(k);
		List u = java.util.Collections.singletonList(KEY2OBJ(k));
		testLists(k, m, java.util.Collections.unmodifiableList(u), 3);
		System.out.println("Test OK");
	}

	private static long seed = System.currentTimeMillis();
	private static java.util.Random r = new java.util.Random(seed);

	private static java.text.NumberFormat format = new java.text.DecimalFormat("#,###.00");
	private static java.text.FieldPosition fp = new java.text.FieldPosition(0);

	private static String format(double d) {
		StringBuffer s = new StringBuffer();
		return format.format(d, s, fp).toString();
	}

	private static void fatal(String msg) {
		throw new AssertionError(msg);
	}

	private static void ensure(boolean cond, String msg) {
		if (cond) return;
		fatal(msg);
	}

	private static void ensure(boolean cond, java.util.function.Supplier<String> msgSupplier) {
		if (cond) return;
		fatal(msgSupplier.get());
	}

	/** This method expects as first argument a lower-cased type (e.g., "int"),
	 * and as second optional argument a seed. */

	public static void main(String arg[]) throws Exception {
		if (arg.length > 1) r = new java.util.Random(seed = Long.parseLong(arg[1]));

		try {
			test();
		} catch(Throwable e) {
			e.printStackTrace(System.err);
			System.err.println("seed: " + seed);
			throw e;
		}
	}

#endif

}
