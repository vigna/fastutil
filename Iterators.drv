/*		 
 * fastutil: Fast & compact type-specific collections for Java
 *
 * Copyright (C) 2002, 2003, 2004, 2005 Sebastiano Vigna 
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

package PACKAGE;

import it.unimi.dsi.fastutil.Iterators;

import java.util.Iterator;
import java.util.ListIterator;
import java.util.NoSuchElementException;

/** A class providing static methods and objects that do useful things with type-specific iterators.
 *
 * @see Iterator
 */

public class ITERATORS {

	private ITERATORS() {}
	
	/** Returns an empty type-specific list iterator.
	 *
	 * @return an empty type-specific list iterator.
	 * @deprecated As of <code>fastutil</code> 3.1, replaced by {@link Iterators#EMPTY_ITERATOR}.
	 */
	public static KEY_LIST_ITERATOR KEY_EMPTY_ITERATOR_METHOD() {
		return Iterators.EMPTY_ITERATOR;
	}

	/** A class to wrap arrays in iterators. */

	private static class ArrayIterator extends KEY_ABSTRACT_LIST_ITERATOR {
		private final KEY_TYPE array[];
		private final int offset, length;
		private int curr;

		public ArrayIterator( final KEY_TYPE array[], final int offset, final int length ) {
			this.array = array;
			this.offset = offset;
			this.length = length;
		}
	
		public boolean hasNext() { return curr < length; }
		public boolean hasPrevious() { return curr > 0; }

		public KEY_TYPE NEXT_KEY() {
			if ( ! hasNext() ) throw new NoSuchElementException();
			return array[ offset + curr++ ];
		}

		public KEY_TYPE PREV_KEY() {
			if ( ! hasPrevious() ) throw new NoSuchElementException();
			return array[ offset + --curr ];
		}

		public int skip( int n ) {
			if ( n <= length - curr ) {
				curr += n;
				return n;
			}
			else {
				n = length - curr;
				curr = length;
				return n;
			}
		}

		public int back( int n ) {
			if ( n <= curr ) {
				curr -= n;
				return n;
			}
			else {
				n = curr;
				curr = 0;
				return n;
			}
		}

		public int nextIndex() {
			return curr;
		}

		public int previousIndex() {
			return curr - 1;
		}
	}


	/** Wraps the given part of an array into a type-specific list iterator.
	 *
	 * <P>The type-specific list iterator returned by this method will iterate
	 * <code>length</code> times, returning consecutive elements of the given
	 * array starting from the one with index <code>offset</code>.
	 *
	 * @param array an array to wrap into a type-specific list iterator.
	 * @param offset the first element of the array to be returned.
	 * @param length the number of elements to return.
	 */
	public static KEY_LIST_ITERATOR wrap( final KEY_TYPE array[], final int offset, final int length ) {
		ARRAYS.ensureOffsetLength( array, offset, length );
		return new ArrayIterator( array, offset, length );
	}

	/** Wraps the given array into a type-specific list iterator.
	 *
	 * <P>The type-specific list iterator returned by this method will return
	 * all elements of the given array.
	 *
	 * @param array an array to wrap into a type-specific list iterator.
	 */
	public static KEY_LIST_ITERATOR wrap( final KEY_TYPE array[] ) {
		return new ArrayIterator( array, 0, array.length );
	}


	/** Unwraps an iterator into an array starting at a given offset for a given number of elements.
	 *
	 * <P>This method iterates over the given type-specific iterator and stores the elements
	 * returned, up to a maximum of <code>length</code>, in the given array starting at <code>offset</code>.
	 * The number of actually unwrapped elements is returned (it may be less than <code>max</code> if
	 * the iterator emits less than <code>max</code> elements).
	 *
	 * @param i a type-specific iterator.
	 * @param array an array to contain the output of the iterator.
	 * @param offset the first element of the array to be returned.
	 * @param max the maximum number of elements to unwrap.
	 * @return the number of elements unwrapped.
	 */
	public static int unwrap( final STD_KEY_ITERATOR i, final KEY_TYPE array[], int offset, final int max ) {
		if ( max < 0 ) throw new IllegalArgumentException( "The maximum number of elements (" + max + ") is negative" );
		if ( offset < 0 || offset + max > array.length ) throw new IllegalArgumentException();
		int j = max;
		while( j-- != 0 && i.hasNext() ) array[ offset++ ] = i.NEXT_KEY();
		return max - j - 1;
	}

	/** Unwraps an iterator into an array.
	 *
	 * <P>This method iterates over the given type-specific iterator and stores the
	 * elements returned in the given array. The iteration will stop when the
	 * iterator has no more elements or when the end of the array has been reached.
	 *
	 * @param i a type-specific iterator.
	 * @param array an array to contain the output of the iterator.
	 * @return the number of elements unwrapped.
	 */
	public static int unwrap( final STD_KEY_ITERATOR i, final KEY_TYPE array[] ) {
		return unwrap( i, array, 0, array.length );
	}

	/** Unwraps an iterator, returning an array, with a limit on the number of elements.
	 *
	 * <P>This method iterates over the given type-specific iterator and returns an array
	 * containing the elements returned by the iterator. At most <code>max</code> elements
	 * will be returned.
	 *
	 * @param i a type-specific iterator.
	 * @param max the maximum number of elements to be unwrapped.
	 * @return an array containing the elements returned by the iterator (at most <ocde>max</code>).
	 */
	public static KEY_TYPE[] unwrap( final STD_KEY_ITERATOR i, int max ) {
		if ( max < 0 ) throw new IllegalArgumentException( "The maximum number of elements (" + max + ") is negative" );
		KEY_TYPE array[] = new KEY_TYPE[ 16 ];
		int j = 0;

		while( max-- != 0 && i.hasNext() ) {
			if ( j == array.length ) array = ARRAYS.grow( array, j + 1 );
			array[ j++ ] = i.NEXT_KEY();
		}

		return ARRAYS.trim( array, j );
	}


	/** Unwraps an iterator, returning an array.
	 *
	 * <P>This method iterates over the given type-specific iterator and returns an array
	 * containing the elements returned by the iterator.
	 *
	 * @param i a type-specific iterator.
	 * @return an array containing the elements returned by the iterator.
	 */

	public static KEY_TYPE[] unwrap( final STD_KEY_ITERATOR i ) {
		return unwrap( i, Integer.MAX_VALUE );
	}


	/** Unwraps an iterator into a type-specific collection,  with a limit on the number of elements.
	 *
	 * <P>This method iterates over the given type-specific iterator and stores the elements
	 * returned, up to a maximum of <code>max</code>, in the given type-specific collection.
	 * The number of actually unwrapped elements is returned (it may be less than <code>max</code> if
	 * the iterator emits less than <code>max</code> elements).
	 *
	 * @param i a type-specific iterator.
	 * @param c a type-specific collection array to contain the output of the iterator.
	 * @param max the maximum number of elements to unwrap.
	 * @return the number of elements unwrapped. Note that
	 * this is the number of elements returned by the iterator, which is not necessarily the number
	 * of elements that have been added to the collection (because of duplicates).
	 */
	public static int unwrap( final STD_KEY_ITERATOR i, final COLLECTION c, final int max ) {
		if ( max < 0 ) throw new IllegalArgumentException( "The maximum number of elements (" + max + ") is negative" );
		int j = max;
		while( j-- != 0 && i.hasNext() ) c.add( i.NEXT_KEY() );
		return max - j - 1;
	}

	/** Unwraps an iterator into a type-specific collection.
	 *
	 * <P>This method iterates over the given type-specific iterator and stores the
	 * elements returned in the given type-specific collection. The returned count on the number
	 * unwrapped elements is a long, so that it will work also with very large collections.
	 *
	 * @param i a type-specific iterator.
	 * @param c a type-specific collection to contain the output of the iterator.
	 * @return the number of elements unwrapped. Note that
	 * this is the number of elements returned by the iterator, which is not necessarily the number
	 * of elements that have been added to the collection (because of duplicates).
	 */
	public static long unwrap( final STD_KEY_ITERATOR i, final COLLECTION c ) {
		long n = 0;
		while( i.hasNext() ) {
			c.add( i.NEXT_KEY() );
			n++;
		}
		return n;
	}


	/** Pours an iterator into a type-specific collection, with a limit on the number of elements.
	 *
	 * <P>This method iterates over the given type-specific iterator and adds
	 * the returned elements to the given collection (up to <code>max</code>).
	 *
	 * @param i a type-specific iterator.
	 * @param s a type-specific collection.
	 * @param max the maximum number of elements to be poured.
	 * @return the number of elements poured. Note that
	 * this is the number of elements returned by the iterator, which is not necessarily the number
	 * of elements that have been added to the collection (because of duplicates).
	 */

	public static int pour( final STD_KEY_ITERATOR i, final COLLECTION s, final int max ) {
		if ( max < 0 ) throw new IllegalArgumentException( "The maximum number of elements (" + max + ") is negative" );
		int j = max;
		while( j-- != 0 && i.hasNext() ) s.add( i.NEXT_KEY() );
		return max - j - 1;
	}

	/** Pours an iterator into a type-specific collection.
	 *
	 * <P>This method iterates over the given type-specific iterator and adds
	 * the returned elements to the given collection.
	 *
	 * @param i a type-specific iterator.
	 * @param s a type-specific collection.
	 * @return the number of elements poured. Note that
	 * this is the number of elements returned by the iterator, which is not necessarily the number
	 * of elements that have been added to the collection (because of duplicates).
	 */

	public static int pour( final STD_KEY_ITERATOR i, final COLLECTION s ) {
		return pour( i, s, Integer.MAX_VALUE );
	}

	/** Pours an iterator, returning a type-specific list, with a limit on the number of elements.
	 *
	 * <P>This method iterates over the given type-specific iterator and returns
	 * a type-specific list containing the returned elements (up to <code>max</code>). Iteration
	 * on the returned list is guaranteed to produce the elements in the same order
	 * in which they appeared in the iterator.
	 *
	 *
	 * @param i a type-specific iterator.
	 * @param max the maximum number of elements to be poured.
	 * @return a type-specific list containing the returned elements, up to <code>max</code>.
	 */

	public static LIST pour( final STD_KEY_ITERATOR i, int max ) {
		final ARRAY_LIST l = new ARRAY_LIST();
		pour( i, l, max );
		l.trim();
		return l;
	}

	/** Pours an iterator, returning a type-specific list.
	 *
	 * <P>This method iterates over the given type-specific iterator and returns
	 * a list containing the returned elements. Iteration
	 * on the returned list is guaranteed to produce the elements in the same order
	 * in which they appeared in the iterator.
	 *
	 * @param i a type-specific iterator.
	 * @return a type-specific list containing the returned elements.
	 */

	public static LIST pour( final STD_KEY_ITERATOR i ) {
		return pour( i, Integer.MAX_VALUE );
	}

	private static class IteratorWrapper extends KEY_ABSTRACT_ITERATOR {
		final Iterator i;

		public IteratorWrapper( final Iterator i ) {
			this.i = i;
		}

		public boolean hasNext() { return i.hasNext(); }
		public void remove() { i.remove(); }

		public KEY_TYPE NEXT_KEY() { return KEY2TYPE( i.next() ); }
	}

	/** Wraps a standard iterator into a type-specific iterator.
	 *
	 * <P>This method wraps a standard iterator into a type-specific one which will handle the
	 * type conversions for you. Of course, any attempt to wrap an iterator returning the
	 * instances of the wrong class will generate a {@link ClassCastException}. The
	 * returned iterator is backed by <code>i</code>: changes to one of the iterators
	 * will affect the other, too.
	 *
	 * <P>If <code>i</code> is already type-specific, it will returned and no new object
	 * will be generated.
	 *
	 * @param i an iterator.
	 * @return a type-specific iterator  backed by <code>i</code>.
	 */
	public static KEY_LIST_ITERATOR AS_KEY_ITERATOR( final ListIterator i ) {
		if ( i instanceof KEY_LIST_ITERATOR ) return (KEY_LIST_ITERATOR)i;
		return new ListIteratorWrapper( i );
	}


	private static class ListIteratorWrapper extends KEY_ABSTRACT_LIST_ITERATOR {
		final ListIterator i;

		public ListIteratorWrapper( final ListIterator i ) {
			this.i = i;
		}

		public boolean hasNext() { return i.hasNext(); }
		public boolean hasPrevious() { return i.hasPrevious(); }
		public int nextIndex() { return i.nextIndex(); }
		public int previousIndex() { return i.previousIndex(); }
		public void set( KEY_TYPE k ) { i.set( KEY2OBJ( k ) ); }
		public void add( KEY_TYPE k ) { i.add( KEY2OBJ( k ) ); }
		public void remove() { i.remove(); }

		public KEY_TYPE NEXT_KEY() { return KEY2TYPE( i.next() ); }
		public KEY_TYPE PREV_KEY() { return KEY2TYPE( i.previous() ); }
	}

	/** Wraps a standard list iterator into a type-specific list iterator.
	 *
	 * <P>This method wraps a standard list iterator into a type-specific one
	 * which will handle the type conversions for you. Of course, any attempt
	 * to wrap an iterator returning the instances of the wrong class will
	 * generate a {@link ClassCastException}. The
	 * returned iterator is backed by <code>i</code>: changes to one of the iterators
	 * will affect the other, too.
	 *
	 * <P>If <code>i</code> is already type-specific, it will returned and no new object
	 * will be generated.
	 *
	 * @param i a list iterator.
	 * @return a type-specific list iterator backed by <code>i</code>.
	 */
	public static KEY_ITERATOR AS_KEY_ITERATOR( final Iterator i ) {
		if ( i instanceof KEY_ITERATOR ) return (KEY_ITERATOR)i;
		return new IteratorWrapper( i );
	}


#if #keyclass(Integer) || #keyclass(Byte) || #keyclass(Short) || #keyclass(Character) || #keyclass(Long)

#if #keyclass(Long)
	private static class IntervalIterator extends KEY_ABSTRACT_BIDI_ITERATOR {
#else
	private static class IntervalIterator extends KEY_ABSTRACT_LIST_ITERATOR {
#endif
		private final KEY_TYPE from, to;
		KEY_TYPE curr;

		public IntervalIterator( final KEY_TYPE from, final KEY_TYPE to ) {
			this.from = this.curr = from;
			this.to = to;
		}

		public boolean hasNext() { return curr < to; }
		public boolean hasPrevious() { return curr > from; }

		public KEY_TYPE NEXT_KEY() { 
			if ( ! hasNext() ) throw new NoSuchElementException();
			return curr++; 
		}
		public KEY_TYPE PREV_KEY() { 
			if ( ! hasPrevious() ) throw new NoSuchElementException();
			return --curr; 
		}

#if ! #keyclass(Long)
		public int nextIndex() { return curr - from; }
		public int previousIndex() { return curr - from - 1; }
#endif

		public int skip( int n ) {
			if ( curr + n <= to ) {
				curr += n;
				return n;
			}
			else {
				n = (int)( to - curr );
				curr = to;
				return n;
			}
		}

		public int back( int n ) {
			if ( curr - n >= from ) {
				curr -= n;
				return n;
			}
			else {
				n = (int)( curr - from );
				curr = from;
				return n;
			}
		}
	}
		
#if #keyclass(Long)
	/** Creates a type-specific bidirectional iterator over an interval.
	 *
	 * <P>The type-specific bidirectional iterator returned by this method will return the
	 * elements <code>from</code>, <code>from+1</code>,&hellip;, <code>to-1</code>.
	 *
	 * <P>Note that all other type-specific interval iterator are <em>list</em>
	 * iterators. Of course, this is not possible with longs as the index
	 * returned by {@link java.util.ListIterator#nextIndex() nextIndex()}/{@link
	 * java.util.ListIterator#previousIndex() previousIndex()} would exceed an integer.
	 *
	 * @param from the starting element (inclusive).
	 * @param to the ending element (exclusive).
	 * @return a type-specific bidirectional iterator enumerating the elements from <code>from</code> to <code>to</code>.
	 */
	public static KEY_BIDI_ITERATOR fromTo( final KEY_TYPE from, final KEY_TYPE to ) {
		return new IntervalIterator( from, to );
	}
#else

	/** Creates a type-specific list iterator over an interval.
	 *
	 * <P>The type-specific list iterator returned by this method will return the
	 * elements <code>from</code>, <code>from+1</code>,&hellip;, <code>to-1</code>.
	 *
	 * @param from the starting element (inclusive).
	 * @param to the ending element (exclusive).
	 * @return a type-specific list iterator enumerating the elements from <code>from</code> to <code>to</code>.
	 */
	public static KEY_LIST_ITERATOR fromTo( final KEY_TYPE from, final KEY_TYPE to ) {
		return new IntervalIterator( from, to );
	}

#endif

#endif

	private static class IteratorConcatenator extends KEY_ABSTRACT_ITERATOR {
		final KEY_ITERATOR a[];
		int offset, length, lastOffset = -1;

		public IteratorConcatenator( final KEY_ITERATOR a[], int offset, int length ) {
			this.a = a;
			this.offset = offset;
			this.length = length;
			advance();
		}

		private void advance() {
			while( length != 0 ) {
				if ( a[ offset ].hasNext() ) break;
				length--;
				offset++;
			}

			return;
		}

		public boolean hasNext() {
			return length > 0;
		}

		public KEY_TYPE NEXT_KEY() {
			if ( ! hasNext() ) throw new NoSuchElementException();
			KEY_TYPE next = a[ lastOffset = offset ].NEXT_KEY();
			advance();
			return next;
		}

		public void remove() {
			if ( lastOffset == -1 ) throw new IllegalStateException();
			a[ lastOffset ].remove();
		}

		public int skip( int n ) {
			lastOffset = -1;

			int skipped = 0;

			while( skipped < n && length != 0 ) {
				skipped += a[ offset ].skip( n - skipped );
				if ( a[ offset ].hasNext() ) break;
				length--;
				offset++;
			}
			
			return skipped;
		}

	}


	/** Concatenates all iterators contained in an array.
	 *
	 * <P>This method returns an iterator that will enumerate in order the elements returned
	 * by all iterators contained in the given array.
	 *
	 * @param a an array of iterators.
	 * @return an iterator obtained by concatenation.
	 */

	public static KEY_ITERATOR concat( final KEY_ITERATOR a[] ) {
		return concat( a, 0, a.length );
	}


	/** Concatenates a sequence of iterators contained in an array.
	 *
	 * <P>This method returns an iterator that will enumerate in order the elements returned
	 * by <code>a[ offset ]</code>, then those returned 
	 * by <code>a[ offset + 1 ]</code>, and so on up to 
	 * <code>a[ offset + length - 1 ]</code>. 
	 *
	 * @param a an array of iterators.
	 * @param offset the index of the first iterator to concatenate.
	 * @param length the number of iterators to concatenate.
	 * @return an iterator obtained by concatenation of <code>length</code> elements of <code>a</code> starting at <code>offset</code>.
	 */

	public static KEY_ITERATOR concat( final KEY_ITERATOR a[], final int offset, final int length ) {
		return new IteratorConcatenator( a, offset, length );
	}


  	/** An unmodifiable wrapper class for iterators. */


	public static class UnmodifiableIterator extends KEY_ABSTRACT_ITERATOR {
		final protected KEY_ITERATOR i;

		public UnmodifiableIterator( final KEY_ITERATOR i ) {
			this.i = i;
		}

		public boolean hasNext() { return i.hasNext(); }

		public KEY_TYPE NEXT_KEY() { return i.NEXT_KEY(); }
#if ! #keyclass(Object) && ! #keyclass(Reference)
		public Object next() { return i.next(); }
#endif
	}


	/** Returns an unmodifiable iterator backed by the specified iterator.
	 *
	 * @param i the iterator to be wrapped in an unmodifiable iterator.
	 * @return an unmodifiable view of the specified iterator.
	 */
	public static KEY_ITERATOR unmodifiable( final KEY_ITERATOR i ) { return new UnmodifiableIterator( i ); }



  	/** An unmodifiable wrapper class for bidirectional iterators. */

	public static class UnmodifiableBidirectionalIterator extends KEY_ABSTRACT_BIDI_ITERATOR  {
		final protected KEY_BIDI_ITERATOR i;

		public UnmodifiableBidirectionalIterator( final KEY_BIDI_ITERATOR i ) {
			this.i = i;
		}

		public boolean hasNext() { return i.hasNext(); }
		public boolean hasPrevious() { return i.hasPrevious(); }
		public KEY_TYPE NEXT_KEY() { return i.NEXT_KEY(); }
		public KEY_TYPE PREV_KEY() { return i.PREV_KEY(); }
#if ! #keyclass(Object) && ! #keyclass(Reference)
		public Object next() { return i.next(); }
		public Object previous() { return i.previous(); }
#endif
	}


	/** Returns an unmodifiable bidirectional iterator backed by the specified bidirectional iterator.
	 *
	 * @param i the bidirectional iterator to be wrapped in an unmodifiable bidirectional iterator.
	 * @return an unmodifiable view of the specified bidirectional iterator.
	 */
	public static KEY_BIDI_ITERATOR unmodifiable( final KEY_BIDI_ITERATOR i ) { return new UnmodifiableBidirectionalIterator( i ); }


  	/** An unmodifiable wrapper class for list iterators. */

	public static class UnmodifiableListIterator extends KEY_ABSTRACT_LIST_ITERATOR {
		final protected KEY_LIST_ITERATOR i;

		public UnmodifiableListIterator( final KEY_LIST_ITERATOR i ) {
			this.i = i;
		}

		public boolean hasNext() { return i.hasNext(); }
		public boolean hasPrevious() { return i.hasPrevious(); }
		public KEY_TYPE NEXT_KEY() { return i.NEXT_KEY(); }
		public KEY_TYPE PREV_KEY() { return i.PREV_KEY(); }
		public int nextIndex() { return i.nextIndex(); }
		public int previousIndex() { return i.previousIndex(); }
#if ! #keyclass(Object) && ! #keyclass(Reference)
		public Object next() { return i.next(); }
		public Object previous() { return i.previous(); }
#endif
	}

	/** Returns an unmodifiable list iterator backed by the specified list iterator.
	 *
	 * @param i the list iterator to be wrapped in an unmodifiable list iterator.
	 * @return an unmodifiable view of the specified list iterator.
	 */
	public static KEY_LIST_ITERATOR unmodifiable( final KEY_LIST_ITERATOR i ) { return new UnmodifiableListIterator( i ); }

}

// Local Variables:
// mode: jde
// tab-width: 4
// End:
